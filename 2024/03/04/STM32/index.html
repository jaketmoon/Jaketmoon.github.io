<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>STM32库函数学习 | Jaketmoon の 博客</title><meta name="author" content="Jaketmoon"><meta name="copyright" content="Jaketmoon"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="自己学习stm32的一些整理，本人并不是专业的的，写的并不是很规范，可能有点小错误，如果要看的话一定要搭配正点原子的库函数源码来看，最好是直接看不完全手册，本文也是基于这些手册的来整理的，每个人也有每个人的情况 tips：使用stlink的话要打开reset and run位于这里 简介STM32是ST公司基于ARMCortex-M内核开发的32位微控制器STM32 常应用在嵌入式领域如智能车、">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32库函数学习">
<meta property="og:url" content="http://yourwebsite.com/2024/03/04/STM32/index.html">
<meta property="og:site_name" content="Jaketmoon の 博客">
<meta property="og:description" content="自己学习stm32的一些整理，本人并不是专业的的，写的并不是很规范，可能有点小错误，如果要看的话一定要搭配正点原子的库函数源码来看，最好是直接看不完全手册，本文也是基于这些手册的来整理的，每个人也有每个人的情况 tips：使用stlink的话要打开reset and run位于这里 简介STM32是ST公司基于ARMCortex-M内核开发的32位微控制器STM32 常应用在嵌入式领域如智能车、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-03-04T05:42:35.000Z">
<meta property="article:modified_time" content="2024-07-18T10:40:51.000Z">
<meta property="article:author" content="Jaketmoon">
<meta property="article:tag" content="嵌入式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yourwebsite.com/2024/03/04/STM32/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.11.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32库函数学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-18 18:40:51'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Jaketmoon の 博客"><span class="site-name">Jaketmoon の 博客</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">STM32库函数学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-04T05:42:35.000Z" title="发表于 2024-03-04 13:42:35">2024-03-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-18T10:40:51.000Z" title="更新于 2024-07-18 18:40:51">2024-07-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="STM32库函数学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p> 自己学习stm32的一些整理，本人并不是专业的的，写的并不是很规范，可能有点小错误，如果要看的话一定要搭配正点原子的库函数源码来看，最好是直接看不完全手册，本文也是基于这些手册的来整理的，每个人也有每个人的情况</p>
<p>tips：使用stlink的话要打开reset and run<img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240525143425721.png" alt="image-20240525143425721" style="zoom: 50%;" />位于这里</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>STM32是ST公司基于ARMCortex-M内核开发的32位微控制器STM32</strong></p>
<p><strong>常应用在嵌入式领域如智能车、无人机、机器人、无线通信、物联网、工业控制、娱乐电子产品等</strong></p>
<p><strong>STM32功能强大、性能优异片上资源丰富、功耗低，是一款经典的嵌入式微控制器</strong></p>
<h1 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h1><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240319134339167.png" alt="image-20240319134339167"></p>
<p>1.建立工程文件夹，Kei中新建工程，选择型号工程文件夹里建立Start、Library、User等文件夹，复制固件库里面的文件到工程文件夹</p>
<p>2.工程里对应建立Start、Library、User等同名称的分组，然后将文件夹内的文件添加到工程分组里</p>
<p>3.工程选项，C&#x2F;C++，Include Paths内声明所有包含头文件的文件夹</p>
<p>4.工程选项，C&#x2F;C++，Define内定义USE STDPERIPH DRIVER</p>
<p>5.工程选项，Debug，下拉列表选择对应调试器，Settings，FlashDownload里勾选Reset and Run</p>
<h1 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h1><h3 id="1-UART（Universal-Asynchronous-Receiver-Transmitter，通用异步收发传输器）"><a href="#1-UART（Universal-Asynchronous-Receiver-Transmitter，通用异步收发传输器）" class="headerlink" title="1. UART（Universal Asynchronous Receiver&#x2F;Transmitter，通用异步收发传输器）"></a>1. UART（Universal Asynchronous Receiver&#x2F;Transmitter，通用异步收发传输器）</h3><ul>
<li><strong>类型</strong>：异步串行通信</li>
<li><strong>特点</strong>：UART 通信只需要两根线（发送TX和接收RX），用于两个设备之间的双向串行通信。它不要求发送方和接收方的时钟同步，因为它在每个字节的开始发送一个起始位，结束时发送一个或多个停止位来标示数据的开始和结束。</li>
<li><strong>应用</strong>：广泛用于串口通信，如与PC通信、串口调试等。</li>
</ul>
<h3 id="2-I2C（Inter-Integrated-Circuit，集成电路总线）"><a href="#2-I2C（Inter-Integrated-Circuit，集成电路总线）" class="headerlink" title="2. I2C（Inter-Integrated Circuit，集成电路总线）"></a>2. I2C（Inter-Integrated Circuit，集成电路总线）</h3><ul>
<li><strong>类型</strong>：同步串行通信</li>
<li><strong>特点</strong>：I2C 使用两根线（串行数据线SDA和串行时钟线SCL）进行通信，支持多主机和多从机。一个主机可以与多个从机通信，每个从机有唯一的地址。I2C速度一般，但连接设备多时非常高效。</li>
<li><strong>应用</strong>：常用于连接低速外围设备，如传感器、EEPROM等。</li>
</ul>
<h3 id="3-SPI（Serial-Peripheral-Interface，串行外围设备接口）"><a href="#3-SPI（Serial-Peripheral-Interface，串行外围设备接口）" class="headerlink" title="3. SPI（Serial Peripheral Interface，串行外围设备接口）"></a>3. SPI（Serial Peripheral Interface，串行外围设备接口）</h3><ul>
<li><strong>类型</strong>：同步串行通信</li>
<li><strong>特点</strong>：SPI 至少需要四根线（串行时钟SCLK、主出从入MOSI、主入从出MISO、从设备选择SS）。它支持一个主设备与一个或多个从设备的全双工通信，传输速度比I2C快。</li>
<li><strong>应用</strong>：常用于需要高速通信的设备，如SD卡、LCD显示屏等。</li>
</ul>
<h3 id="其他协议："><a href="#其他协议：" class="headerlink" title="其他协议："></a>其他协议：</h3><ul>
<li><strong>CAN（Controller Area Network）</strong>：一种用于汽车和工业控制中的多主机串行总线标准，特别适用于复杂的电子系统中的通信。</li>
<li><strong>USB（Universal Serial Bus）</strong>：广泛用于计算机和其他设备之间的连接和通信，支持热插拔和即插即用。</li>
<li><strong>Ethernet</strong>：用于局域网（LAN）的通信标准，提供高速的网络连接。</li>
<li><strong>1-Wire</strong>：一种仅使用一根数据线（加上地线）进行通信的协议，适用于低速数据通信，特别是在连接空间受限制时。</li>
</ul>
<h1 id="系统时钟"><a href="#系统时钟" class="headerlink" title="系统时钟"></a>系统时钟</h1><h2 id="五个时钟源"><a href="#五个时钟源" class="headerlink" title="五个时钟源"></a>五个时钟源</h2><p>①、HSI 是高速内部时钟，RC 振荡器，频率为 8MHz。</p>
<p>②、HSE 是高速外部时钟，可接石英&#x2F;陶瓷谐振器，或者接外部时钟源，频率范围为 4MHz~16MHz。</p>
<p>我们的开发板接的是 8M 的晶振。</p>
<p>③、LSI 是低速内部时钟，RC 振荡器，频率为 40kHz。独立看门狗的时钟源只能是 LSI，同</p>
<p>时 LSI 还可以作为 RTC 的时钟源。</p>
<p>④、LSE 是低速外部时钟，接频率为 32.768kHz 的石英晶体。这个主要是 RTC 的时钟源。</p>
<p>⑤、PLL 为锁相环倍频输出，其时钟输入源可选择为 HSI&#x2F;2、HSE 或者 HSE&#x2F;2。倍频可选择为2~16 倍，但是其输出频率最大不得超过 72MHz。</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240320232853894.png" alt="image-20240320232853894"></p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h5 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h5><blockquote>
<p>MCO 是 STM32 的一个时钟输出 IO(PA8)，它可以选择一个时钟信号输出，可以选择为 PLL 输出的 2 分频、HSI、HSE、或者系统时钟。这个时钟可以用来给外部其他系统提供时钟源。</p>
</blockquote>
<h5 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h5><blockquote>
<p>这里是 RTC 时钟源，从图上可以看出，RTC 的时钟源可以选择 LSI，LSE，以及HSE 的 128 分频。</p>
</blockquote>
<h5 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h5><blockquote>
<p>从图中可以看出 C 处 USB 的时钟是来自 PLL 时钟源。STM32 中有一个全速功能的 USB 模块，其串行接口引擎需要一个频率为 48MHz 的时钟源。该时钟源只能从 PLL 输出端获取，可以选择为 1.5 分频或者 1 分频，也就是，当需要使用 USB模块时，PLL 必须使能，并且时钟频率配置为 48MHz 或 72MHz。</p>
</blockquote>
<h5 id="D"><a href="#D" class="headerlink" title="D."></a>D.</h5><blockquote>
<p>D 处就是 STM32 的系统时钟 SYSCLK，它是供 STM32 中绝大部分部件工作的时钟源。系统时钟可选择为 PLL 输出、HSI 或者 HSE。系统时钟最大频率为 72MHz，当然你也可以超频，不过一般情况为了系统稳定性是没有必要冒风险去超频的。</p>
</blockquote>
<h5 id="E"><a href="#E" class="headerlink" title="E."></a>E.</h5><blockquote>
<p>这里的 E 处是指其他所有外设了。从时钟图上可以看出，其他所有外设的时钟最终来源都是 SYSCLK。SYSCLK 通过 AHB 分频器分频后送给各模块使用。这些模块包括：</p>
</blockquote>
<p><strong>①、AHB 总线、内核、内存和 DMA 使用的 HCLK 时钟。</strong></p>
<p><strong>②、通过 8 分频后送给 Cortex 的系统定时器时钟，也就是 systick 了。</strong></p>
<p><strong>③、直接送给 Cortex 的空闲运行时钟 FCLK。</strong></p>
<p><strong>④、送给 APB1 分频器。APB1 分频器输出一路供 APB1 外设使用(PCLK1，最大</strong></p>
<p><strong>频率 36MHz)，另一路送给定时器(Timer)2、3、4 倍频器使用。</strong></p>
<p><strong>⑤、送给 APB2 分频器。APB2 分频器分频输出一路供 APB2 外设使用(PCLK2，</strong></p>
<p><strong>最大频率 72MHz)，另一路送给定时器(Timer)1 倍频器使用。</strong></p>
<h1 id="初始化GPIO"><a href="#初始化GPIO" class="headerlink" title="初始化GPIO"></a>初始化GPIO</h1><p>我们可以通过MDK的固件库来开发，首先在头文件 stm32f10x_gpio.h</p>
<p>定义 GPIO 初始化函数为：</p>
<p><code>void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);</code></p>
<p>我们先处理 GPIO_InitTypeDef，右键选择“Go to definition…”，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> GPIO_Pin;             <span class="comment">/*!&lt; Specifies the GPIO pins to be configured.</span></span><br><span class="line"><span class="comment">                                      This parameter can be any value of @ref GPIO_pins_define */</span></span><br><span class="line"></span><br><span class="line">  GPIOSpeed_TypeDef GPIO_Speed;  <span class="comment">/*!&lt; Specifies the speed for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */</span></span><br><span class="line"></span><br><span class="line">  GPIOMode_TypeDef GPIO_Mode;    <span class="comment">/*!&lt; Specifies the operating mode for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOMode_TypeDef */</span></span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们要先定义结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br></pre></td></tr></table></figure>

<p>然后要初始化各个成员变量，但是不知道要具体怎么设置值。</p>
<p>我们直接再c文件里面定位GPIO_Init.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span><br><span class="line">&#123;</span><br><span class="line">……</span><br><span class="line"> <span class="comment">/* Check the parameters */</span></span><br><span class="line"> assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line"> assert_param(IS_GPIO_MODE(GPIO_InitStruct-&gt;GPIO_Mode));</span><br><span class="line"> assert_param(IS_GPIO_PIN(GPIO_InitStruct-&gt;GPIO_Pin)); </span><br><span class="line">……</span><br><span class="line"> assert_param(IS_GPIO_SPEED(GPIO_InitStruct-&gt;GPIO_Speed));</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顾名思义，assert_param 函数式对入口参数的有效性进行判断，所以我们可以从这个函数入手，确定我们的入口参数的范围。第一行是对第一个参数 GPIOx 进行有效性判断，双击“IS_GPIO_ALL_PERIPH”右键点击“go to defition of…” 定位到了下面的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \</span></span><br><span class="line"><span class="meta"> ((PERIPH) == GPIOB) || \</span></span><br><span class="line"><span class="meta"> ((PERIPH) == GPIOC) || \</span></span><br><span class="line"><span class="meta"> ((PERIPH) == GPIOD) || \</span></span><br><span class="line"><span class="meta"> ((PERIPH) == GPIOE) || \</span></span><br><span class="line"><span class="meta"> ((PERIPH) == GPIOF) || \</span></span><br><span class="line"><span class="meta"> ((PERIPH) == GPIOG))</span></span><br></pre></td></tr></table></figure>

<p>很明显可以看出，GPIOx 的取值规定只允许是 GPIOA~GPIOG。</p>
<p>同样的办法，我们双击“IS_GPIO_MODE” </p>
<p>右键点击“go to defition of…”,定位到下面的定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> GPIO_Mode_AIN = <span class="number">0x0</span>,</span><br><span class="line">  GPIO_Mode_IN_FLOATING = <span class="number">0x04</span>,</span><br><span class="line">  GPIO_Mode_IPD = <span class="number">0x28</span>,</span><br><span class="line">  GPIO_Mode_IPU = <span class="number">0x48</span>,</span><br><span class="line">  GPIO_Mode_Out_OD = <span class="number">0x14</span>,</span><br><span class="line">  GPIO_Mode_Out_PP = <span class="number">0x10</span>,</span><br><span class="line">  GPIO_Mode_AF_OD = <span class="number">0x1C</span>,</span><br><span class="line">  GPIO_Mode_AF_PP = <span class="number">0x18</span></span><br><span class="line">&#125;GPIOMode_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_AIN) || ((MODE) == GPIO_Mode_IN_FLOATING) || \</span></span><br><span class="line"><span class="meta">                            ((MODE) == GPIO_Mode_IPD) || ((MODE) == GPIO_Mode_IPU) || \</span></span><br><span class="line"><span class="meta">                            ((MODE) == GPIO_Mode_Out_OD) || ((MODE) == GPIO_Mode_Out_PP) || \</span></span><br><span class="line"><span class="meta">                            ((MODE) == GPIO_Mode_AF_OD) || ((MODE) == GPIO_Mode_AF_PP))</span></span><br></pre></td></tr></table></figure>

<p>取值范围就是下面的define，其他的参数也是同样的道理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; <span class="comment">//</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure>

<h5 id="如何初始化多个IO口："><a href="#如何初始化多个IO口：" class="headerlink" title="如何初始化多个IO口："></a>如何初始化多个IO口：</h5><p>这里又有一个小技巧了。从上面的 GPIO_Pin_x 的宏定义我们可以看出，这些值是 0,1,2,4这样的数字，所以每个 IO 口选定都是对着一个位，16 位的数据一共对应 16 个 IO 口。这个位为 0 那么这个对应的 IO 口不选定，这个位为 1 对应的 IO 口选定。如果多个 IO 口，他们都是对应同一个 GPIOx，那么我们可以通过|（或）的方式同时初始化多个 IO 口。这样操作的前提是，他们的 Mode 和 Speed 参数相同，因为 Mode 和 Speed 参数并不能一次定义多种。所以初始化多个 IO 口的方式可以是如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5| GPIO_Pin_6| GPIO_Pin_7; <span class="comment">//指定端口</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//端口模式：推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; <span class="comment">//速度</span></span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure); <span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>

<h1 id="system文件夹介绍"><a href="#system文件夹介绍" class="headerlink" title="system文件夹介绍"></a>system文件夹介绍</h1><blockquote>
<p>SYSTEM 文件夹下包含了 delay、sys、usart 等三个文件夹。分别包含了 delay.c、sys.c、usart.c 及其头文件 delay.h,sys.h,usart.h。</p>
</blockquote>
<h2 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_osschedlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_osschedunlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ostimedly</span><span class="params">(u32 ticks)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 nms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(u32 nus)</span>;</span><br></pre></td></tr></table></figure>

<p>前面 4 个函数，仅在支持操作系统（OS）的时候，需要用到，而后面三个函数，则不论是否支持 OS 都需要用到。</p>
<h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><p>sys 文件夹内包含了 sys.c 和 sys.h 两个文件。在 sys.h 里面定义了 STM32 的 IO 口输入读取宏定义和输出宏定义。sys.c 里面只定义了一个中断分组函数。</p>
<h2 id="usart"><a href="#usart" class="headerlink" title="usart"></a>usart</h2><p>usart 文件夹内包含了 usart.c 和 usart.h 两个文件。这两个文件用于串口的初始化和中断接收。</p>
<h1 id="跑马灯实验"><a href="#跑马灯实验" class="headerlink" title="跑马灯实验"></a>跑马灯实验</h1><p>首先，找到之前 的 Template 工程，在该文件夹下面新建一个HARDWARE 的文件夹，用来存储以后与硬件相关的代码，然后在HARDWARE 文件夹下新建一个 LED 文件夹，用来存放与 LED 相关的代码。</p>
<p>然后我们打开 USER 文件夹下的 LED.uvprojx 工程(如果是使用的上面新建的工程模板，那么就是 Template. uvprojx，大家可以将其重命名为LED. uvprojx)，右键target1目录下新建一个group HANDWARE,添加新文件led.c，然后保存在 HARDWARE-&gt;LED 文件夹下面。</p>
<img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240509193416858.png" alt="image-20240509193416858"  />

<p><strong>要注意的是，添加新文件到里面的时候，要添加路径</strong></p>
<p>然后在这里要检查自己添加的files有没有出现在右边。</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240509193630866.png" alt="image-20240509193630866"></p>
<blockquote>
<p>目的：理解IO口的输出</p>
</blockquote>
<p>组 HARDWARE 下面存放的是每个实验的外设驱动代码，他的实现是通过调用 FWLib组 HARDWARE 下面存放的是每个实验的外设驱动代码，他的实现是通过调用 FWLib下面的固件库文件实现的，比如 led.c 里面调用 stm32f10x_gpio.c 里面的函数对 led 进行初始化，这里面的函数是讲解的重点。后面的实验中可以看到会引入多个源文件。</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240321144018150.png" alt="image-20240321144018150"></p>
<p>从层次图中可以看出，我们的用户代码和 HARDWARE 下面的外设驱动代码再不需要直接操作寄存器，而是直接或间接操作官方提供的固件库函数。</p>
<h2 id="MODE"><a href="#MODE" class="headerlink" title="MODE"></a>MODE</h2><p><strong>STM32 的 IO 口相比 51 而言要复杂得多，所以使用起来也困难很多。首先 STM32 的 IO 口可以由软件配置成如下 8 种模式：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span> </span><br><span class="line">GPIO_Mode_AIN = <span class="number">0x0</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟输入</span></span><br><span class="line"></span><br><span class="line"> GPIO_Mode_IN_FLOATING = <span class="number">0x04</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//浮空输入</span></span><br><span class="line"></span><br><span class="line"> GPIO_Mode_IPD = <span class="number">0x28</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//下拉输入</span></span><br><span class="line"></span><br><span class="line"> GPIO_Mode_IPU = <span class="number">0x48</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//上拉输入</span></span><br><span class="line"></span><br><span class="line"> GPIO_Mode_Out_OD = <span class="number">0x14</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//开漏输出</span></span><br><span class="line"></span><br><span class="line"> GPIO_Mode_Out_PP = <span class="number">0x10</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//通用推挽输出</span></span><br><span class="line"></span><br><span class="line"> GPIO_Mode_AF_OD = <span class="number">0x1C</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//复用开漏输出</span></span><br><span class="line"></span><br><span class="line"> GPIO_Mode_AF_PP = <span class="number">0x18</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//复用推挽</span></span><br><span class="line"></span><br><span class="line">&#125;GPIOMode_TypeDef;</span><br></pre></td></tr></table></figure>





<h2 id="LED-c"><a href="#LED-c" class="headerlink" title="LED.c"></a>LED.c</h2><p>在这个文件中，我们先进行GPIO的初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"> 	</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOD, ENABLE);	 <span class="comment">//使能了GPIOA和GPIOD两个GPIO端口的时钟。</span></span><br><span class="line">	</span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;				 <span class="comment">//	初始化哪个IO口/LED0--&gt;PB.5 端口配置</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 <span class="comment">//对应IO口的输入模式为推免输出</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		 <span class="comment">//速度50MM</span></span><br><span class="line"> GPIO_Init(GPIOA, &amp;GPIO_InitStructure);					 <span class="comment">//根据设定参数配置 GPIO</span></span><br></pre></td></tr></table></figure>

<p>然后就可以对PIN8进行操作</p>
<p><code>GPIO_SetBits(GPIOA,GPIO_Pin_8)</code>将pin8电平设置为高</p>
<p>现在Pin8电平设置为1，初始化成功</p>
<p>然后再初始化PIN2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;	    	</span><br><span class="line">GPIO_Init(GPIOD, &amp;GPIO_InitStructure);	  		</span><br><span class="line">GPIO_SetBits(GPIOD,GPIO_Pin_2); 				</span><br></pre></td></tr></table></figure>

<p><strong>因为之前的InitStructure里面初始化过了其他内容，因此不必多设置</strong></p>
<p>至此，LED.c的文件已经设置完成</p>
<p>LED.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="comment">//LED 端口定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0 PAout(8) <span class="comment">// PA8</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1 PDout(2) <span class="comment">// PD2</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//初始化 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>这段代码里面最关键就是 2 个宏定义：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED0 PAout(8) <span class="comment">// PA8</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1 PDout(2) <span class="comment">// PD2</span></span></span><br></pre></td></tr></table></figure>

<p>LED0&#x3D;1; &#x2F;&#x2F;通过位带操作控制 LED0 的引脚 PA8 输出高电平</p>
<p>LED0&#x3D;0; &#x2F;&#x2F;通过位带操作控制 LED0 的引脚 PA8 输出低电平</p>
<p>但是我们主函数中还是使用库函数来操作灯的亮灭</p>
<p>接下来我们将 led.h 也保存一下。接着，我们在 Manage Project Items 管理里面新建一个HARDWARE 的组，并把 led.c 加入到这个组里面</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240322131904714.png" alt="image-20240322131904714"></p>
<p>然后在c&#x2F;c++里面再把h文件路径添加到工程中</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240322132014736.png" alt="image-20240322132014736"></p>
<p>最后在main函数中实现跑马灯效果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;	</span><br><span class="line">	delay_init();	     </span><br><span class="line">	LED_Init();		  	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_ResetBits(GPIOA,GPIO_Pin_8); </span><br><span class="line">		GPIO_SetBits(GPIOD,GPIO_Pin_2);</span><br><span class="line">		delay_ms(<span class="number">1000</span>);</span><br><span class="line">		GPIO_SetBits(GPIOA,GPIO_Pin_8);</span><br><span class="line">		GPIO_ResetBits(GPIOD,GPIO_Pin_2);</span><br><span class="line">		delay_ms(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="按键输入实验"><a href="#按键输入实验" class="headerlink" title="按键输入实验"></a>按键输入实验</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><strong>这一节，我们将通过 MiniSTM32 开发板上载有的 3 个按钮（KEY0&#x2F;KEY1&#x2F;WK_UP），来控制板上的 2 个 LED，其中 KEY0 控制 DS0，按一次亮，再按一次，就灭。KEY1 控制 DS1，效果同 KEY0。WK_UP 按键则同时控制 DS0 和 DS1，按一次，他们的状态就翻转一次。</strong></p>
<h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><p>其实就只有两个函数：KEY_Init()和KEY_Scan(u8 mode)，使用的时候只需使用先Init之后再通过Scan来读取键值。</p>
<p>可以再main.c来看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;	</span><br><span class="line">	u8 t=<span class="number">0</span>;	  </span><br><span class="line">	delay_init();	    	  </span><br><span class="line">	LED_Init();		  	 	</span><br><span class="line">	KEY_Init();          	</span><br><span class="line">	LED0=<span class="number">0</span>;					</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		t=KEY_Scan(<span class="number">0</span>);		<span class="comment">//得到键值</span></span><br><span class="line">		<span class="keyword">switch</span>(t)</span><br><span class="line">		&#123;				 </span><br><span class="line">			<span class="keyword">case</span> KEY0_PRES:</span><br><span class="line">				LED0=!LED0;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY1_PRES:</span><br><span class="line">				LED1=!LED1;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> WKUP_PRES:				</span><br><span class="line">				LED0=!LED0;</span><br><span class="line">				LED1=!LED1;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				delay_ms(<span class="number">10</span>);	</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;		 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以通过按键来控制LED的亮灭了。</p>
<h1 id="串口实验"><a href="#串口实验" class="headerlink" title="串口实验"></a>串口实验</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p><strong>本章，我们将实现利用串口 1 不停的打印信息到电脑上，同时接收从串口发过来的数据，把发送过来的数据直接送回给电脑。miniSTM32 开发板板载了 1 个 USB 串口和 1 个 RS232 串口，我们本章介绍的是通过 USB 串口和电脑通信。</strong></p>
<h2 id="软件设计-1"><a href="#软件设计-1" class="headerlink" title="软件设计"></a>软件设计</h2><p>因为有关串口的函数已经再System的usart.c的文件下面了，所以我们直接看如何再main.c上使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 t;</span><br><span class="line">    u8 len;</span><br><span class="line">    u16 times=<span class="number">0</span>; </span><br><span class="line">    delay_init(); <span class="comment">//延时函数初始化</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); <span class="comment">//设置中断分组 </span></span><br><span class="line">    uart_init(<span class="number">9600</span>); <span class="comment">//串口初始化为 9600</span></span><br><span class="line">    LED_Init(); <span class="comment">//初始化与 LED 连接的硬件接口</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x8000</span>)</span><br><span class="line">    &#123; </span><br><span class="line">    len=USART_RX_STA&amp;<span class="number">0x3fff</span>;<span class="comment">//得到此次接收到的数据长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n 您发送的消息为:\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)&#123;</span><br><span class="line">    	USART1-&gt;DR=USART_RX_BUF[t];<span class="comment">//想串口1发送数据</span></span><br><span class="line">    	<span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//等待发送结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n\r\n&quot;</span>);<span class="comment">//插入换行</span></span><br><span class="line">    USART_RX_STA=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        times++;</span><br><span class="line">        <span class="keyword">if</span>(times%<span class="number">5000</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r\nALIENTEK MiniSTM32 开发板 串口实验\r\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正点原子@ALIENTEK\r\n\r\n\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times%<span class="number">200</span>==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;请输入数据,以回车键结束\r\n&quot;</span>); </span><br><span class="line">        <span class="keyword">if</span>(times%<span class="number">30</span>==<span class="number">0</span>)LED0=!LED0;<span class="comment">//闪烁 LED,提示系统正在运行.</span></span><br><span class="line">        delay_ms(<span class="number">10</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动XCOM，选择开放板的串口。</p>
<h1 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h1><p>STM32 的定时器功能十分强大，有 TIME1 和 TIME8 等高级定时器，也有 TIME2~TIME5 等通用定时器，还有 TIME6 和TIME7 等基本定时器。</p>
<p>我们将使用 TIM3 的定时器中断来控制 DS1 的翻转，在主函数用 DS0 的翻转来提示程序正在运行。</p>
<h2 id="STM32通用定时器简介"><a href="#STM32通用定时器简介" class="headerlink" title="STM32通用定时器简介"></a>STM32通用定时器简介</h2><p>其实和51单片机的差不多，都是测量输入信号的脉冲长度，或者产生输出波形，STM32的每个通用定时器都是相互独立的。为了加快速度，我们就不了解寄存器的作用了。直接看如何使用定时器中断。</p>
<h3 id="1-TIM3时钟使能"><a href="#1-TIM3时钟使能" class="headerlink" title="1.TIM3时钟使能"></a>1.TIM3时钟使能</h3><p><strong>TIM3 是挂载在 APB1 之下，所以我们通过 APB1 总线下的时钟使能函数来使能 TIM3。调用的函数是：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); <span class="comment">//时钟使能</span></span><br></pre></td></tr></table></figure>



<h3 id="2-初始化定时器参数-设置自动重装值，分频系数，计数方式等。"><a href="#2-初始化定时器参数-设置自动重装值，分频系数，计数方式等。" class="headerlink" title="2.初始化定时器参数,设置自动重装值，分频系数，计数方式等。"></a>2.初始化定时器参数,设置自动重装值，分频系数，计数方式等。</h3><p><strong>在库函数中，定时器的初始化参数是通过初始化函数TIM_TimeBaseInit 实现的：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">voidTIM_TimeBaseInit(TIM_TypeDef*TIMx,TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);</span><br></pre></td></tr></table></figure>

<p>第一个参数是确定是哪个定时器，这个比较容易理解。第二个参数是定时器初始化参数结构体指针，结构体类型TIM_TimeBaseInitTypeDef，下面我们看看这个结构体的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">uint16_t</span> TIM_Prescaler; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_CounterMode; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_Period; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_ClockDivision; </span><br><span class="line"> <span class="type">uint8_t</span> TIM_RepetitionCounter; </span><br><span class="line">&#125; TIM_TimeBaseInitTypeDef;</span><br></pre></td></tr></table></figure>

<p>这个结构体一共有 5 个成员变量，要说明的是，对于通用定时器只有前面四个参数有用，最后一个参数 TIM_RepetitionCounter 是高级定时器才有用的，这里不多解释。</p>
<blockquote>
<p>第一个参数 TIM_Prescaler 是用来设置分频系数的</p>
</blockquote>
<blockquote>
<p>第二个参数 TIM_CounterMode 是用来设置计数方式。比较常用的是向上计数模式 TIM_CounterMode_Up 和向下计数模式 TIM_CounterMode_Down。</p>
</blockquote>
<blockquote>
<p>第三个参数是设置自动重载计数周期值</p>
</blockquote>
<blockquote>
<p>第四个参数是用来设置时钟分频因子</p>
</blockquote>
<p><strong>针对 TIM3 初始化范例代码格式：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;</span><br><span class="line">TIM_TimeBaseStructure.TIM_Period = <span class="number">5000</span>;</span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =<span class="number">7199</span>; </span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; </span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure);</span><br></pre></td></tr></table></figure>

<h3 id="3-设置-TIM3-DIER-允许更新中断"><a href="#3-设置-TIM3-DIER-允许更新中断" class="headerlink" title="3.设置 TIM3_DIER 允许更新中断"></a>3.<strong>设置</strong> <strong>TIM3_DIER</strong> 允许更新中断</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT, FunctionalState NewState)</span>；</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个参数是选择定时器号，这个容易理解，取值为 TIM1~TIM17。</p>
</blockquote>
<blockquote>
<p>第二个参数非常关键，是用来指明我们使能的定时器中断的类型，定时器中断的类型有很多种，包括更新中断 TIM_IT_Update，触发中断 TIM_IT_Trigger，以及输入捕获中断等等。</p>
</blockquote>
<blockquote>
<p>第三个参数就很简单了，就是失能还是使能。</p>
</blockquote>
<h3 id="4-TIM3-中断优先级设置。"><a href="#4-TIM3-中断优先级设置。" class="headerlink" title="4.TIM3 中断优先级设置。"></a>4.<strong>TIM3</strong> <strong>中断优先级设置。</strong></h3><p>在定时器中断使能之后，因为要产生中断，必不可少的要设置 NVIC 相关寄存器，设置中断优先级。这段比较复杂，省略。</p>
<h3 id="5-允许-TIM3-工作，也就是使能-TIM3。"><a href="#5-允许-TIM3-工作，也就是使能-TIM3。" class="headerlink" title="5.允许 TIM3 工作，也就是使能 TIM3。"></a>5.<strong>允许</strong> <strong>TIM3</strong> <strong>工作，也就是使能</strong> <strong>TIM3</strong>。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_Cmd(TIM3, ENABLE); <span class="comment">//使能 TIMx 外设</span></span><br></pre></td></tr></table></figure>

<h3 id="6-编写中断服务函数。"><a href="#6-编写中断服务函数。" class="headerlink" title="6.编写中断服务函数。"></a>6.<strong>编写中断服务函数。</strong></h3><p>在最后，还是要编写定时器中断服务函数，通过该函数来处理定时器产生的相关中断。在中断产生后，通过状态寄存器的值来判断此次产生的中断属于什么类型。然后执行相关的操作，我们这里使用的是更新（溢出）中断，所以在状态寄存器 SR 的最低位。在处理完中断之后应该向 TIM3_SR 的最低位写 0，来清除该中断标志。</p>
<p><strong>在固件库函数里面，用来读取中断状态寄存器的值判断中断类型的函数是:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITStatus <span class="title function_">TIM_GetITStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span>)</span></span><br></pre></td></tr></table></figure>

<p><strong>该函数的作用是，判断定时器 TIMx 的中断类型 TIM_IT 是否发生中断。比如，我们要判断定时器 3 是否发生更新（溢出）中断，方法为：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>固件库中清除中断标志位的函数是：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearITPendingBit</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT)</span></span><br></pre></td></tr></table></figure>

<p>该函数的作用是，清除定时器 TIMx 的中断 TIM_IT 标志位。使用起来非常简单，<strong>比如我们在TIM3 的溢出中断发生后，我们要清除中断标志位，方法是：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_ClearITPendingBit(TIM3, TIM_IT_Update );</span><br></pre></td></tr></table></figure>

<h2 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a><strong>硬件设计</strong></h2><p>本实验用到的硬件资源有：</p>
<blockquote>
<p>1） 指示灯 DS0 和 DS1</p>
</blockquote>
<blockquote>
<p>2） 定时器 TIM3</p>
</blockquote>
<p>本章将通过 TIM3 的中断来控制 DS1 的亮灭，DS0 和 DS1 的电路在前面的跑马灯实验上已经使用过了，我们就直接用之前的led文件。而TIM3 属于 STM32 的内部资源，只需要软件设置即可正常工作。</p>
<h2 id="软件设计-2"><a href="#软件设计-2" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="timer-c"><a href="#timer-c" class="headerlink" title="timer.c"></a>timer.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="comment">//通用定时器 3 中断初始化</span></span><br><span class="line"><span class="comment">//这里时钟选择为 APB1 的 2 倍，而 APB1 为 36M</span></span><br><span class="line"><span class="comment">//arr：自动重装值。</span></span><br><span class="line"><span class="comment">//psc：时钟预分频数</span></span><br><span class="line"><span class="comment">//这里使用的是定时器 3!</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM3_Int_Init</span><span class="params">(u16 arr,u16 psc)</span></span><br><span class="line">&#123;</span><br><span class="line">    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//定义结构体</span></span><br><span class="line"></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); <span class="comment">//时钟TIM3使能</span></span><br><span class="line"></span><br><span class="line">	TIM_TimeBaseStructure.TIM_Period = arr; <span class="comment">//设置自动重装载寄存器周期的值</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_Prescaler =psc; <span class="comment">//设置时钟频率除数的预分频值  </span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>; <span class="comment">///设置时钟分割</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  <span class="comment">//TIM 向上计数</span></span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); <span class="comment">//②初始化 TIM3</span></span><br><span class="line"> </span><br><span class="line">	TIM_ITConfig(TIM3, TIM_IT_Update,ENABLE);<span class="comment">//③允许TIM3更新中断</span></span><br><span class="line">    </span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;  <span class="comment">//TIM3中断</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>;  <span class="comment">//先占优先级0级</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">3</span>;  <span class="comment">//从优先级3级</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//IRQ通道被使能</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);  <span class="comment">//初始化NVIC寄存器</span></span><br><span class="line"></span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);  <span class="comment">//使能TIM3</span></span><br><span class="line">							 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>   <span class="comment">//TIM3中断</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) <span class="comment">//检查TIM1更新中断发生与否</span></span><br><span class="line">		&#123;</span><br><span class="line">		TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  <span class="comment">//清除TIM3更新中断标志</span></span><br><span class="line">		LED1=!LED1;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>这个是中断时间 的计算公式：</strong></p>
<p><code>Tout= ((arr+1)*(psc+1))/Tclk；</code>单位为us</p>
<p>初始化的时候在默认的系统初始化函数 SystemInit 函数里面已经初始化 APB1 的时钟为 2 分频，所以 APB1 的时钟为 36M，而从 STM32 的内部时钟树图得知：当 APB1 的时钟分频数为 1 的时候，TIM2<del>7 的时钟为 APB1 的时钟，而如果 APB1 的时钟分频数不为 1，那么 TIM2</del>7 的时钟频率将为 APB1 时钟的两倍。这里时钟选择为APB1的两倍，而APB1为36M</p>
<h1 id="PWM输出实验"><a href="#PWM输出实验" class="headerlink" title="PWM输出实验"></a>PWM输出实验</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>将数字信号处理为模拟信号：</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240324150011530.png" alt="image-20240324150011530"></p>
<h3 id="1-开启-TIM1-时钟，配置-PA8-为复用输出。"><a href="#1-开启-TIM1-时钟，配置-PA8-为复用输出。" class="headerlink" title="1.开启 TIM1 时钟，配置 PA8 为复用输出。"></a>1.开启 <strong>TIM1</strong> <strong>时钟，配置</strong> <strong>PA8</strong> <strong>为复用输出。</strong></h3><p>要使用 TIM1，我们必须先开启 TIM1 的时钟，这点相信大家看了这么多代码，应该明白了。这里我们还要配置 PA8 为复用输出（当然还要时能 PORTA 的时钟），这是因为 TIM1_CH1 通道将使用 PA8 的复用功能作为输出。库函数使能 TIM3 时钟的方法是：</p>
<p><code>RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //使能定时器 3 时钟</code></p>
<p>设置 PA8 为复用功能输出的方法在前面的几个实验都有类似的讲解，相信大家很明白,这里简单列出 GPIO 初始化的一行代码即可：</p>
<p><code>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出</code></p>
<h3 id="2-设置-TIM1-的-ARR-和-PSC。"><a href="#2-设置-TIM1-的-ARR-和-PSC。" class="headerlink" title="2.设置 TIM1 的 ARR 和 PSC。"></a>2.<strong>设置</strong> <strong>TIM1</strong> <strong>的</strong> <strong>ARR</strong> <strong>和</strong> <strong>PSC</strong>。</h3><p>在开启了 TIM1 的时钟之后，我们要设置 ARR 和 PSC 两个寄存器的值来控制输出 PWM 的周期。当 PWM 周期太慢（低于 50Hz）的时候，我们就会明显感觉到闪烁了。因此，PWM 周期在这里不宜设置的太小。这在库函数是通过 TIM_TimeBaseInit 函数实现的，在上一节定时器中断章节我们已经有讲解，这里就不详细讲解，调用的格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseStructure.TIM_Period = arr; <span class="comment">//设置自动重装载值</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =psc; <span class="comment">//设置预分频值</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>; <span class="comment">//设置时钟分割:TDTS = Tck_tim</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">//向上计数模式</span></span><br><span class="line">TIM_TimeBaseInit(TIM1, &amp;TIM_TimeBaseStructure); <span class="comment">//根据指定的参数初始化 TIMx 的</span></span><br></pre></td></tr></table></figure>

<h3 id="3-设置-TIM1-CH1-的-PWM-模式及通道方向-使能TIM1-的-CH1-输出。"><a href="#3-设置-TIM1-CH1-的-PWM-模式及通道方向-使能TIM1-的-CH1-输出。" class="headerlink" title="3.设置 TIM1_CH1 的 PWM **模式及通道方向, **使能TIM1 的 CH1 输出。"></a>3.<strong>设置</strong> <strong>TIM1_CH1</strong> <strong>的</strong> <strong>PWM</strong> **模式及通道方向, **使能TIM1 <strong>的</strong> <strong>CH1</strong> <strong>输出。</strong></h3><p>接下来，我们要设置 TIM1_CH1 为 PWM 模式（默认是冻结的），因为我们的 DS0 是低电平亮，而我们希望当 CCR1 的值小的时候，DS0 就暗，CCR1 值大的时候，DS0 就亮，所以我们要通过配置 TIM1_CCMR1 的相关位来控制 TIM1_CH1 的模式。在库函数中，PWM 通道设置是通过函数 TIM_OC1Init()~TIM_OC4Init()来设置的，不同的通道的设置函数不一样，这里我们使用的是通道 1，所以使用的函数是 TIM_OC1Init()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>；</span><br></pre></td></tr></table></figure>

<p>这种初始化格式大家学到这里应该也熟悉了，所以我们直接来看看结构体 TIM_OCInitTypeDef的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">uint16_t</span> TIM_OCMode; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_OutputState; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_OutputNState; */</span><br><span class="line"> <span class="type">uint16_t</span> TIM_Pulse; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_OCPolarity; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_OCNPolarity; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_OCIdleState; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_OCNIdleState; </span><br><span class="line">&#125; TIM_OCInitTypeDef;</span><br></pre></td></tr></table></figure>

<p>这里我们讲解一下与我们要求相关的几个成员变量：</p>
<blockquote>
<p><strong>参</strong>数 TIM_OCMode 设置模式是 PWM 还是输出比较，这里我们是 PWM 模式</p>
</blockquote>
<blockquote>
<p>参数 TIM_OutputState 用来设置比较输出使能，也就是使能 PWM 输出到端口。</p>
</blockquote>
<blockquote>
<p>参数 TIM_OCPolarity 用来设置极性是高还是低。</p>
</blockquote>
<blockquote>
<p>其他的参数 TIM_OutputNState，TIM_OCNPolarity，TIM_OCIdleState 和 TIM_OCNIdleState 是高级定时器 TIM1 和 TIM8 才用到的</p>
</blockquote>
<p>要实现我们上面提到的场景，方法是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; <span class="comment">//选择 PWM 模式 2</span></span><br><span class="line">TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; <span class="comment">//比较输出使能</span></span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; <span class="comment">//输出极性高</span></span><br><span class="line">TIM_OC1Init(TIM1, &amp;TIM_OCInitStructure); <span class="comment">//初始化 TIM1 OC1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-使能-TIM1。"><a href="#4-使能-TIM1。" class="headerlink" title="4.使能 TIM1。"></a>4.<strong>使能</strong> <strong>TIM1</strong>。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_Cmd(TIM1, ENABLE); <span class="comment">//使能 TIM1</span></span><br></pre></td></tr></table></figure>

<h3 id="5-设置-MOE-输出，使能-PWM-输出"><a href="#5-设置-MOE-输出，使能-PWM-输出" class="headerlink" title="5.设置 MOE 输出，使能 PWM 输出"></a>5.<strong>设置</strong> <strong>MOE</strong> <strong>输出，使能</strong> <strong>PWM</strong> <strong>输出</strong></h3><p>普通定时器在完成以上设置了之后，就可以输出 PWM 了，但是高级定时器，我们还需要使能刹车和死区寄存器（TIM1_BDTR）的 MOE 位，以使能整个 OCx（即 PWM）输出。库函数的设置函数为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_CtrlPWMOutputs(TIM1,ENABLE);<span class="comment">// MOE 主输出使能</span></span><br></pre></td></tr></table></figure>

<h3 id="6-修改-TIM1-CCR1-来控制占空比。"><a href="#6-修改-TIM1-CCR1-来控制占空比。" class="headerlink" title="6.修改 TIM1_CCR1 来控制占空比。"></a>6.<strong>修改</strong> <strong>TIM1_CCR1</strong> <strong>来控制占空比。</strong></h3><p>最后，在经过以上设置之后，PWM 其实已经开始输出了，只是其占空比和频率都是固定的，而我们通过修改 TIM1_CCR1 则可以控制 CH1 的输出占空比。继而控制 DS0 的亮度。在库函数中，修改 TIM1_CCR1 占空比的函数是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare1</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare1)</span>；</span><br></pre></td></tr></table></figure>

<p>理所当然，对于其他通道，分别有一个函数名字，函数格式为 TIM_SetComparex(x&#x3D;1,2,3,4)。</p>
<h2 id="硬件设计-1"><a href="#硬件设计-1" class="headerlink" title="硬件设计"></a>硬件设计</h2><p>本实验用到的硬件资源有：</p>
<blockquote>
<p>1） 指示灯 DS0 </p>
</blockquote>
<blockquote>
<p>2） 定时器 TIM3</p>
</blockquote>
<p>这两个前面都有介绍，但是我们这里用到了 TIM1_CH1 通道的输出，从原理图可以看到，TIM1_CH1 是和 PA8 相连的，所以电路上并没有任何变化。</p>
<h2 id="软件设计-3"><a href="#软件设计-3" class="headerlink" title="软件设计"></a>软件设计</h2><p>打开光盘里面的 PWM 输出实验代码，可以看见我们在工程中添加了 pwm.c 文件，并且引入了头文件 pwm.h。打开 pwm.c 内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pwm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="comment">//PWM 输出初始化</span></span><br><span class="line"><span class="comment">//arr：自动重装值</span></span><br><span class="line"><span class="comment">//psc：时钟预分频数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1_PWM_Init</span><span class="params">(u16 arr,u16 psc)</span></span><br><span class="line">&#123;  </span><br><span class="line">	 GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">	TIM_OCInitTypeDef  TIM_OCInitStructure;</span><br><span class="line"></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);<span class="comment">// 使能tim1时钟</span></span><br><span class="line"> 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA , ENABLE);  <span class="comment">//使能GPIO外设时钟使能</span></span><br><span class="line">	                                                                     	</span><br><span class="line">	<span class="comment">//设置该引脚为复用输出功能，输出TIMI1 CH1的PWM的脉冲波形</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; <span class="comment">//TIM_CH1</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  <span class="comment">//复用推免输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	TIM_TimeBaseStructure.TIM_Period = arr; <span class="comment">//设置在下一个更新事件装入活动的自动重装载寄存器周期的值 80K</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_Prescaler =psc; <span class="comment">//设置用来作为 TIMx 时钟频率除数的预分频值 不分频</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>; <span class="comment">//设置时钟分割:TDTS = Tck_tim</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  <span class="comment">//向上计数</span></span><br><span class="line">	TIM_TimeBaseInit(TIM1, &amp;TIM_TimeBaseStructure); <span class="comment">//②初始化 TIMx</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; <span class="comment">//脉宽调制模式 2</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; <span class="comment">//比较输出使能</span></span><br><span class="line">	TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>; <span class="comment">//设置待装入捕获比较寄存器的脉冲值</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; <span class="comment">//输出极性高</span></span><br><span class="line">	TIM_OC1Init(TIM1, &amp;TIM_OCInitStructure);  <span class="comment">//初始化外设 TIMx</span></span><br><span class="line"></span><br><span class="line">  TIM_CtrlPWMOutputs(TIM1,ENABLE);	<span class="comment">//MOE 主输出使能</span></span><br><span class="line"></span><br><span class="line">	TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);  <span class="comment">//CH1 预装载使能	 </span></span><br><span class="line">	</span><br><span class="line">	TIM_ARRPreloadConfig(TIM1, ENABLE); <span class="comment">//使能 TIMx 在 ARR 上的预装载寄存器</span></span><br><span class="line">	</span><br><span class="line">	TIM_Cmd(TIM1, ENABLE);  <span class="comment">//使能 TIM1</span></span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>接下来是主函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pwm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;	</span><br><span class="line">	u16 led0pwmval=<span class="number">0</span>;    </span><br><span class="line">	u8 dir=<span class="number">1</span>;	</span><br><span class="line">	delay_init();	    		  </span><br><span class="line">	LED_Init();		  </span><br><span class="line">	TIM1_PWM_Init(<span class="number">899</span>,<span class="number">0</span>);<span class="comment">//不分频。PWM 频率=72000/(899+1)=80Khz</span></span><br><span class="line">   	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"> 		delay_ms(<span class="number">10</span>);	 </span><br><span class="line">		<span class="keyword">if</span>(dir)led0pwmval++;</span><br><span class="line">		<span class="keyword">else</span> led0pwmval--;	 </span><br><span class="line"> 		<span class="keyword">if</span>(led0pwmval&gt;<span class="number">300</span>)dir=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(led0pwmval==<span class="number">0</span>)dir=<span class="number">1</span>;	   					 </span><br><span class="line">		TIM_SetCompare1(TIM1,led0pwmval);	   </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h1 id="编码器接口"><a href="#编码器接口" class="headerlink" title="编码器接口"></a>编码器接口</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><p>这章在正点原子里面没有，所以我参考了普中的实验，并且按照自己的配置修改了，为了显示cnt我决定在通过串口显示在电脑上</p>
<p>1.Encoder Interface 编码器接口可接收增量(正交)编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度</p>
<p>2.每个高级定时器和通用定时器都拥有1个编码器接口</p>
<p>3.两个输入引脚借用了输入捕获的通道1和通道2</p>
<h2 id="软件设计-4"><a href="#软件设计-4" class="headerlink" title="软件设计"></a>软件设计</h2><p>1.RCC开启时钟，开启GPIO和定时器的时钟。</p>
<p>2.配置GPIO，把PA6和PA7配置为输入模式</p>
<p>3.配置时基单元，预分频器选择不分频。自动重装，最大给65535，只需一个CNT执行计数就行了。</p>
<p>4.配置输入捕获单元，只有滤波器和极性两个参数可以用。</p>
<p>5.配置编码器接口模式，直接调用库函数</p>
<p>6.调用TIM_Cmd启动定时器就行了。</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240406220108946.png" alt="image-20240406220108946"></p>
<p>初始化完成之后，CNT会随着编码器旋转而自增自减。</p>
<p>想知道编码器位置，直接读CNT</p>
<p>如果想知道速度与方向，那就需要每隔一段固定的闸门时间，取出一次CNT，然后清零，利用测频法来测量速度。</p>
<h4 id="encoder-c"><a href="#encoder-c" class="headerlink" title="encoder.c"></a>encoder.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Encoder.h&quot;</span></span></span><br><span class="line"><span class="comment">//这里PA6和PA7为接口</span></span><br><span class="line">TIM_ICInitTypeDef  TIM3_ICInitStructure;<span class="comment">//该类型是用于配置TIM3定时器输入捕获的结构体。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span>&#123;<span class="comment">//用于初始化编码器</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;<span class="comment">//结构体用于GPIO初始化配置</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;<span class="comment">//结构体用于定时器基本配置</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);	</span><br><span class="line"> 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  <span class="comment">//这两行代码启用TIM3时钟和GPIOA端口时钟。RCC_APB1PeriphClockCmd`和RCC_APB2PeriphClockCmd是STM32标准库函数，用于控制高级外设（APB2）和低级外设（APB1）的时钟。</span></span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_6 | GPIO_Pin_7;  </span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; </span><br><span class="line">    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;	</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOA的6号和7号引脚。将它们设置为上拉输入模式，这对于编码器的信号线是典型的配置。</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//初始化定时器TIM3</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>; <span class="comment">//此行设置了定时器的周期（ARR - Auto-Reload Register），它决定定时器计数器的最大值。定时器计数器会从0开始计数，一直到这个值然后重新开始（或者在编码器模式下，计数器会增加或减少）。这里设置的值是65535（16位最大值），因为STM32的定时器是16位的（某些型号可能有32位定时器）。由于计数是从0开始的，所以最大值要减1才是65535。当计数器值达到65535后，下一个脉冲会使其回到0，形成一个循环。</span></span><br><span class="line">    </span><br><span class="line">	TIM_TimeBaseStructure.TIM_Prescaler =<span class="number">1</span><span class="number">-1</span>; 	<span class="comment">//分频器（PSC - Prescaler）用于降低定时器输入时钟频率。TIM_Prescaler值定义了时钟频率除数。TIM_Prescaler的值是实际分频值减1。所以这里设置为0，意思是定时器计数器的时钟频率不变，即不分频。如果时钟频率是72MHz，这里的设置意味着定时器的计数频率也将是72MHz。</span></span><br><span class="line">    </span><br><span class="line">	TIM_TimeBaseStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//此字段TIM_RepetitionCounter用于高级定时器，它设置了重复计数器的值。这个计数器用于指定更新事件（UEV）产生的次数，每达到该次数，就会重新加载计数器（仅适用于带有重复功能的定时器）。对于通用定时器，比如TIM3，这个字段通常不起作用，设置为0表示没有重复计数功能。</span></span><br><span class="line">    </span><br><span class="line">	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; <span class="comment">//TIM_ClockDivision字段用于设置时钟分频，这个分频是对定时器的内部时钟（用于数字滤波器）的分频。TIM_CKD_DIV1表示没有分频，即内部时钟与输入时钟相同。其他选项如TIM_CKD_DIV2和TIM_CKD_DIV4会对内部时钟进行相应的分频。</span></span><br><span class="line">    </span><br><span class="line">	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  <span class="comment">//TIM_CounterMode字段设置定时器的计数模式。TIM_CounterMode_Up表示定时器以向上计数模式工作，即计数器从0计数到预设的自动重装载值后溢出，然后重新从0开始计数。其他常见模式包括向下计数模式（TIM_CounterMode_Down）和向上向下计数模式（TIM_CounterMode_CenterAligned）。</span></span><br><span class="line">    </span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); </span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//初始化TIM3输入捕获参数</span></span><br><span class="line">	TIM_ICStructInit(&amp;TIM3_ICInitStructure);<span class="comment">//结构体初始化为默认值</span></span><br><span class="line">    </span><br><span class="line">	TIM3_ICInitStructure.TIM_Channel = TIM_Channel_1; <span class="comment">//这里指定了TIM3定时器的第一个通道（Channel 1）用于输入捕获。STM32的定时器通常有多个通道，可以分别用于输入或输出功能。在这种情况下，我们使用Channel 1来获取外部信号的计时。</span></span><br><span class="line">    </span><br><span class="line">  	TIM3_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;	<span class="comment">//此行代码设置输入捕获的极性。TIM_ICPolarity_Rising的意思是定时器仅在检测到上升沿时触发输入捕获事件。也就是说，当检测到从低电平变为高电平的变化时，定时器会捕获此时的计数器值。相反，如果你想在下降沿捕获计数值，你可以使用TIM_ICPolarity_Falling。有时候你会想要在上升沿和下降沿都捕获计数值，那么可以使用TIM_ICPolarity_BothEdge。</span></span><br><span class="line">    </span><br><span class="line">  	TIM3_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;<span class="comment">//这里通过配置输入捕获滤波器来防止噪声引起的错误触发。0xF（在STM32的标准外设库中是一个4位的值，范围从0x0到0xF）指定了滤波器的级别。一个较高的值表示较强的噪声抑制，意味着输入信号在被认为是有效的上升沿或下降沿之前需要保持一定时间的稳定状态。这能有效地减少由于信号抖动引起的误触发。</span></span><br><span class="line">    </span><br><span class="line">  	TIM_ICInit(TIM3, &amp;TIM3_ICInitStructure);<span class="comment">//最后，这行代码使用前面定义和设置的TIM3_ICInitStructure结构体来初始化TIM3定时器的输入捕获功能。TIM_ICInit是一个库函数，它应用了结构体中的配置并准备定时器去捕获外部信号。</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	TIM3_ICInitStructure.TIM_Channel = TIM_Channel_2; <span class="comment">//通过更改通道参数，对TIM3的第二个输入捕获通道进行类似配置。</span></span><br><span class="line">  	TIM3_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;	</span><br><span class="line">  	TIM3_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">  	TIM_ICInit(TIM3, &amp;TIM3_ICInitStructure);</span><br><span class="line">	</span><br><span class="line">				                  												TIM_EncoderInterfaceConfig(TIM3,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising);<span class="comment">//将TIM3配置为编码器接口模式，此模式同时利用上面配置的两个输入通道（TI1和TI2）。</span></span><br><span class="line">   TIM_Cmd(TIM3,ENABLE ); 	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> TIM_GetCounter(TIM3);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么需要两个通道呢?</p>
<ol>
<li><strong>方向检测：</strong> 一个旋转编码器产生两个波形，分别称为A相和B相，它们是互相位移90度（即四分之一周期）的方波信号。这种位移被称为相位编码，允许我们不仅测量编码器的旋转速度，而且还可以确定其旋转方向。通过比较这两个信号的相位关系，我们可以判断编码器是向前旋转还是向后旋转。<ul>
<li>如果A相在B相前，编码器向一个方向旋转。</li>
<li>如果B相在A相前，编码器向相反方向旋转。</li>
</ul>
</li>
<li><strong>位置计数：</strong> 当编码器旋转时，A相和B相信号会产生脉冲。STM32定时器在编码器模式下能够使用这两个通道的信号来增加或减少计数器的值。这意味着，定时器不仅仅是简单地计数A相的脉冲，它还利用这两个通道来确定旋转的方向，并作出相应地增加或减少计数器数值的动作。</li>
<li><strong>分辨率提高：</strong> 由于A相和B相信号相互之间存在90度的相位差，所以在每个信号的每个上升沿和下降沿之间，定时器可以更新四次计数器的值。这意味着编码器模式可以实现比单独使用一个通道更高的分辨率。</li>
</ol>
<p>结合这两个通道，微控制器可以通过检查计数器的递增和递减来精确测量旋转编码器的位置和方向。在STM32微控制器中，这通常是通过配置定时器在编码器模式下工作来实现的，这样定时器自动处理这两个通道的信号，并维护一个表示编码器旋转位置的计数值。</p>
</blockquote>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240407233404369.png" alt="image-20240407233404369"></p>
<h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Encoder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="comment">//ALIENTEK Mini STM32开发板范例代码7</span></span><br><span class="line"><span class="comment">//定时器中断实验   </span></span><br><span class="line"><span class="comment">//技术支持：www.openedv.com</span></span><br><span class="line"><span class="comment">//广州市星翼电子科技有限公司</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;	</span><br><span class="line">	u8 t;</span><br><span class="line">	u8 len;	</span><br><span class="line">	u16 times=<span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">	delay_init();	    	 <span class="comment">//延时函数初始化	</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">// 设置中断优先级分组2</span></span><br><span class="line">	uart_init(<span class="number">9600</span>);	 <span class="comment">//串口初始化为9600</span></span><br><span class="line">	LED_Init();		  	 <span class="comment">//初始化与LED连接的硬件接口 </span></span><br><span class="line">	Encoder_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x8000</span>)</span><br><span class="line">		&#123;					   </span><br><span class="line">			len=USART_RX_STA&amp;<span class="number">0x3fff</span>;<span class="comment">//得到此次接收到的数据长度</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r\n您发送的消息为:\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)</span><br><span class="line">			&#123;</span><br><span class="line">				USART1-&gt;DR=USART_RX_BUF[t];</span><br><span class="line">				<span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//等待发送结束</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r\n\r\n&quot;</span>);<span class="comment">//插入换行</span></span><br><span class="line">			USART_RX_STA=<span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			times++;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">5000</span>==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\r\nALIENTEK MiniSTM32开发板 串口实验\r\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;正点原子@ALIENTEK\r\n\r\n\r\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>,Encoder_Get());</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">200</span>==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入数据,以回车键结束\r\n&quot;</span>);  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%u\r\n&quot;</span>,Encoder_Get());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">30</span>==<span class="number">0</span>)LED0=!LED0;<span class="comment">//闪烁LED,提示系统正在运行.</span></span><br><span class="line">			delay_ms(<span class="number">10</span>);   </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就可以显示在电脑上了</p>
<h1 id="SPI实验（flash外部储存）"><a href="#SPI实验（flash外部储存）" class="headerlink" title="SPI实验（flash外部储存）"></a>SPI实验（flash外部储存）</h1><p>我们将使用 STM32 自带的 SPI 来实现对外部 FLASH（W25Q64）的读写，并将结果显示在 TFTLCD 模块上。本章分为如下几个部分</p>
<h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><p>由于过于复杂，我们直接由上而下，看怎么用。</p>
<h3 id="配置相关引脚的复用功能，使能-SPI1-时钟。"><a href="#配置相关引脚的复用功能，使能-SPI1-时钟。" class="headerlink" title="配置相关引脚的复用功能，使能 SPI1 时钟。"></a><strong>配置相关引脚的复用功能，使能</strong> <strong>SPI1</strong> <strong>时钟。</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE );<span class="comment">//PORTA 时钟使能</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI1, ENABLE );<span class="comment">//SPI1 时钟使能</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class="comment">//PA5,6,7 复用推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化 GPIOB</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化-SPI1-设置-SPI1-工作模式"><a href="#初始化-SPI1-设置-SPI1-工作模式" class="headerlink" title="初始化 **SPI1,**设置 SPI1 工作模式"></a><strong>初始化</strong> **SPI1,**设置 <strong>SPI1</strong> <strong>工作模式</strong></h3><p>接下来我们要初始化 SPI1,设置 SPI1 为主机模式，设置数据格式为 8 位，然后设置 SCK 时钟极性及采样方式。并设置 SPI1 的时钟频率（最大 18Mhz），以及数据的格式（MSB 在前还是LSB 在前）。这在库函数中是通过 SPI_Init 函数来实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_Init</span><span class="params">(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)</span>；</span><br></pre></td></tr></table></figure>

<p>跟其他外设初始化一样，第一个参数是 SPI 标号，这里我们是使用的 SPI1。下面我们来看看第二个参数结构体类型SPI_InitTypeDef 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">uint16_t</span> SPI_Direction;</span><br><span class="line"> <span class="type">uint16_t</span> SPI_Mode; </span><br><span class="line"> <span class="type">uint16_t</span> SPI_DataSize; </span><br><span class="line"> <span class="type">uint16_t</span> SPI_CPOL; </span><br><span class="line"> <span class="type">uint16_t</span> SPI_CPHA; </span><br><span class="line"> <span class="type">uint16_t</span> SPI_NSS; </span><br><span class="line"> <span class="type">uint16_t</span> SPI_BaudRatePrescaler; </span><br><span class="line"> <span class="type">uint16_t</span> SPI_FirstBit; </span><br><span class="line"> <span class="type">uint16_t</span> SPI_CRCPolynomial; </span><br><span class="line">&#125;SPI_InitTypeDef</span><br></pre></td></tr></table></figure>

<p>我们设置成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SPI_InitTypeDef SPI_InitStructure;</span><br><span class="line">SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; <span class="comment">//双线双向全双工</span></span><br><span class="line">SPI_InitStructure.SPI_Mode = SPI_Mode_Master; <span class="comment">//主 SPI</span></span><br><span class="line">SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; <span class="comment">// SPI 发送接收 8 位帧结构</span></span><br><span class="line">SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;<span class="comment">//串行同步时钟的空闲状态为高电平</span></span><br><span class="line">SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;<span class="comment">//第二个跳变沿数据被采样</span></span><br><span class="line">SPI_InitStructure.SPI_NSS = SPI_NSS_Soft; <span class="comment">//NSS 信号由软件控制</span></span><br><span class="line">SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256; <span class="comment">//预分频 256</span></span><br><span class="line">SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; <span class="comment">//数据传输从 MSB 位开始</span></span><br><span class="line">SPI_InitStructure.SPI_CRCPolynomial = <span class="number">7</span>; <span class="comment">//CRC 值计算的多项式</span></span><br><span class="line">SPI_Init(SPI1, &amp;SPI_InitStructure); <span class="comment">//根据指定的参数初始化外设 SPIx 寄存器</span></span><br></pre></td></tr></table></figure>

<h3 id="使能-SPI1"><a href="#使能-SPI1" class="headerlink" title="使能 SPI1"></a><strong>使能</strong> <strong>SPI1</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPI_Cmd(SPI1, ENABLE); <span class="comment">//使能 SPI 外设</span></span><br></pre></td></tr></table></figure>

<h3 id="传输和接受数据"><a href="#传输和接受数据" class="headerlink" title="传输和接受数据"></a>传输和接受数据</h3><p>发送数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_SendData</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> Data)</span>；</span><br></pre></td></tr></table></figure>

<p>接收数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI_I2S_ReceiveData</span><span class="params">(SPI_TypeDef* SPIx)</span> ；</span><br></pre></td></tr></table></figure>

<h2 id="软件设计-5"><a href="#软件设计-5" class="headerlink" title="软件设计"></a>软件设计</h2><p>开机的时候先检测 W25Q64 是否存在，然后在主循环里面检测两个按键，其中 1 个按键（WK_UP）用来执行写入 W25Q64 的操作，另外一个按键（KEY0）用来执行读出操作，在 TFTLCD 模块上显示相关信息。同时用 DS0 提示程序正在运行。</p>
<p>由于文件数量过大，我就不在此处展示，可以到正点原子官方那里去要源码，这里直接看main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ALIENTEK Mini STM32开发板范例代码20</span></span><br><span class="line"><span class="comment">//SPI实验  </span></span><br><span class="line"><span class="comment">//技术支持：www.openedv.com</span></span><br><span class="line"><span class="comment">//广州市星翼电子科技有限公司</span></span><br><span class="line">   	</span><br><span class="line"><span class="comment">//要写入到W25Q64的字符串数组</span></span><br><span class="line"><span class="type">const</span> u8 TEXT_Buffer[]=&#123;<span class="string">&quot;MiniSTM32 SPI TEST&quot;</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE sizeof(TEXT_Buffer)	 </span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123; </span><br><span class="line">	u8 key;</span><br><span class="line">	u16 i=<span class="number">0</span>;</span><br><span class="line">	u8 datatemp[SIZE];</span><br><span class="line">	u32 FLASH_SIZE;</span><br><span class="line">    u16 id = <span class="number">0</span>;</span><br><span class="line">	delay_init();	    	 <span class="comment">//延时函数初始化	  </span></span><br><span class="line">	uart_init(<span class="number">9600</span>);	 	<span class="comment">//串口初始化为9600</span></span><br><span class="line">	LED_Init();		  		<span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line"> 	LCD_Init();</span><br><span class="line">	KEY_Init();				<span class="comment">//按键初始化		 	</span></span><br><span class="line">	SPI_Flash_Init();  		<span class="comment">//SPI FLASH 初始化 	 </span></span><br><span class="line"> 	POINT_COLOR=RED;<span class="comment">//设置字体为红色 </span></span><br><span class="line">	LCD_ShowString(<span class="number">60</span>,<span class="number">50</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Mini STM32&quot;</span>);	</span><br><span class="line">	LCD_ShowString(<span class="number">60</span>,<span class="number">70</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;SPI TEST&quot;</span>);	</span><br><span class="line">	LCD_ShowString(<span class="number">60</span>,<span class="number">90</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;ATOM@ALIENTEK&quot;</span>);</span><br><span class="line">	LCD_ShowString(<span class="number">60</span>,<span class="number">110</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;2014/3/9&quot;</span>);	</span><br><span class="line">	LCD_ShowString(<span class="number">60</span>,<span class="number">130</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;WK_UP:Write  KEY0:Read&quot;</span>);	<span class="comment">//显示提示信息		</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		id = SPI_Flash_ReadID();</span><br><span class="line">		<span class="keyword">if</span> (id == W25Q64 || id == NM25Q64)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		LCD_ShowString(<span class="number">30</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;W25Q64 Check Failed!&quot;</span>);</span><br><span class="line">		delay_ms(<span class="number">500</span>);</span><br><span class="line">		LCD_ShowString(<span class="number">30</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Please Check!        &quot;</span>);</span><br><span class="line">		delay_ms(<span class="number">500</span>);</span><br><span class="line">		LED0=!LED0;<span class="comment">//DS0闪烁</span></span><br><span class="line">	&#125;</span><br><span class="line">	LCD_ShowString(<span class="number">60</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;25Q64 Ready!&quot;</span>);</span><br><span class="line"></span><br><span class="line">	FLASH_SIZE=<span class="number">8</span>*<span class="number">1024</span>*<span class="number">1024</span>;	<span class="comment">//FLASH 大小为8M字节</span></span><br><span class="line">  	POINT_COLOR=BLUE;		<span class="comment">//设置字体为蓝色	  </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		key=KEY_Scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==WKUP_PRES)	<span class="comment">//WK_UP 按下,写入W25Q64</span></span><br><span class="line">		&#123;</span><br><span class="line">			LCD_Fill(<span class="number">0</span>,<span class="number">170</span>,<span class="number">239</span>,<span class="number">319</span>,WHITE);<span class="comment">//清除半屏    </span></span><br><span class="line"> 			LCD_ShowString(<span class="number">60</span>,<span class="number">170</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Start Write W25Q64....&quot;</span>);</span><br><span class="line">			SPI_Flash_Write((u8*)TEXT_Buffer,FLASH_SIZE<span class="number">-100</span>,SIZE);		<span class="comment">//从倒数第100个地址处开始,写入SIZE长度的数据</span></span><br><span class="line">			LCD_ShowString(<span class="number">60</span>,<span class="number">170</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;W25Q64 Write Finished!&quot;</span>);	<span class="comment">//提示传送完成</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(key==KEY0_PRES)	<span class="comment">//KEY0 按下,读取字符串并显示</span></span><br><span class="line">		&#123;</span><br><span class="line"> 			LCD_ShowString(<span class="number">60</span>,<span class="number">170</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Start Read W25Q64.... &quot;</span>);</span><br><span class="line">			SPI_Flash_Read(datatemp,FLASH_SIZE<span class="number">-100</span>,SIZE);				<span class="comment">//从倒数第100个地址处开始,读出SIZE个字节</span></span><br><span class="line">			LCD_ShowString(<span class="number">60</span>,<span class="number">170</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;The Data Readed Is:  &quot;</span>);	<span class="comment">//提示传送完成</span></span><br><span class="line">			LCD_ShowString(<span class="number">60</span>,<span class="number">190</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,datatemp);					<span class="comment">//显示读到的字符串</span></span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">		delay_ms(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LED0=!LED0;<span class="comment">//提示系统正在运行	</span></span><br><span class="line">			i=<span class="number">0</span>;</span><br><span class="line">		&#125;		   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们关注如何进行读写操作，我们把需要读取的数据放在<code>const u8 TEXT_Buffer[]=&#123;&quot;MiniSTM32 SPI TEST&quot;&#125;;</code>，在<code>SPI_Flash_Write((u8*)TEXT_Buffer,FLASH_SIZE-100,SIZE);</code>中把数据写到flash中，然后通过<code>SPI_Flash_Read(datatemp,FLASH_SIZE-100,SIZE);</code>把读取数据到<code>datatemp</code>，然后输出就ok了。</p>
<h1 id="TFLCD显示实验-制作菜单任务"><a href="#TFLCD显示实验-制作菜单任务" class="headerlink" title="TFLCD显示实验(制作菜单任务)"></a>TFLCD显示实验(制作菜单任务)</h1><p>在上一个单元中，我们其实忽略了TFLCD的显示，我们最终的数据其实要显示在LED上的，这次我们就把这个学习一下这个实验，并且实现一下智能车的任务：制作一个菜单。</p>
<blockquote>
<p>任务要求：写个菜单，将其显示在屏幕上，同时利用flash存储与读写数据，同时利用按键选择具体改变的 数据类型并改变数据的大小。</p>
</blockquote>
<h2 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h2><p><strong>一般 TFTLCD 模块的使用流程如图</strong></p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240328234820371.png" alt="image-20240328234820371"></p>
<blockquote>
<p>任何 LCD，使用流程都可以简单的用以上流程图表示。其中硬复位和初始化序列，只需要执行一次即可。而画点流程就是：设置坐标→写 GRAM 指令→写入颜色数据，然后在 LCD 上面，我们就可以看到对应的点显示我们写入的颜色了。读点流程为：设置坐标→读 GRAM 指令→读取颜色数据，这样就可以获取到对应点的颜色数据了。</p>
</blockquote>
<blockquote>
<p>以上只是最简单的操作，也是最常用的操作，有了这些操作，一般就可以正常使用 TFTLCD了。接下来我们将该模块用来来显示字和数字，通过以上介绍，我们可以得出 TFTLCD 显示需要的相关设置步骤如下：</p>
</blockquote>
<h3 id="1-设置-STM32-与-TFTLCD-模块相连接的-IO"><a href="#1-设置-STM32-与-TFTLCD-模块相连接的-IO" class="headerlink" title="1.设置 STM32 与 TFTLCD 模块相连接的 IO"></a>1.<strong>设置</strong> <strong>STM32</strong> <strong>与</strong> <strong>TFTLCD</strong> <strong>模块相连接的</strong> <em>IO</em></h3><p>这一步，先将我们与 TFTLCD 模块相连的 IO 口进行初始化，以便驱动 LCD。这里需要根据连接电路以及 TFTLCD 模块的设置来确定。</p>
<h3 id="2-初始化-TFTLCD-模块"><a href="#2-初始化-TFTLCD-模块" class="headerlink" title="2.初始化 TFTLCD 模块"></a>2.<strong>初始化</strong> <strong>TFTLCD</strong> <strong>模块</strong></h3><p>初始化序列，就是向 LCD 控制器写入一系列的设置值（比如伽马校准），这些初始化序列一般 LCD 供应商会提供给客户，我们直接使用这些序列即可，不需要深入研究。在初始化之后，LCD 才可以正常使用.</p>
<h3 id="3-通过函数将字符和数字显示到-TFTLCD-模块上"><a href="#3-通过函数将字符和数字显示到-TFTLCD-模块上" class="headerlink" title="3.通过函数将字符和数字显示到 TFTLCD 模块上"></a>3.<strong>通过函数将字符和数字显示到</strong> <strong>TFTLCD</strong> <strong>模块上</strong></h3><p>前两步基本不用看，这一步比较重要，设置置坐标→写 GRAM 指令→写 GRAM 来实现，但是这个步骤，只是一个点的处理，我们要显示字符&#x2F;数字，就必须要多次使用这个步骤，从而达到显示字符&#x2F;数字的目标，所以需要设计一个函数来实现数字&#x2F;字符的显示，之后调用该函数，就可以实现数字&#x2F;字符的显示了。</p>
<h2 id="软件设计-6"><a href="#软件设计-6" class="headerlink" title="软件设计"></a>软件设计</h2><p>由于.c文件设计太复杂，我们直接在.h中看怎么用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 width;      <span class="comment">//LCD 宽度</span></span><br><span class="line">    u16 height;     <span class="comment">//LCD 高度</span></span><br><span class="line">    u16 id;         <span class="comment">//LCD ID</span></span><br><span class="line">    u8  dir;        <span class="comment">//横屏还是竖屏控制：0，竖屏；1，横屏。</span></span><br><span class="line">    u16 wramcmd;    <span class="comment">//开始写gram指令</span></span><br><span class="line">    u16 setxcmd;    <span class="comment">//设置x坐标指令</span></span><br><span class="line">    u16  setycmd;   <span class="comment">//设置y坐标指令</span></span><br><span class="line">&#125; _lcd_dev;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个结构体定义了我们lcd的参数，每个lcd的屏幕都是不一样的，可以在这里更改设置</p>
<p>然后是写数据函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写数据函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_WR_DATA(data)&#123;\</span></span><br><span class="line"><span class="meta">LCD_RS_SET;\</span></span><br><span class="line"><span class="meta">LCD_CS_CLR;\</span></span><br><span class="line"><span class="meta">DATAOUT(data);\</span></span><br><span class="line"><span class="meta">LCD_WR_CLR;\</span></span><br><span class="line"><span class="meta">LCD_WR_SET;\</span></span><br><span class="line"><span class="meta">LCD_CS_SET;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。不行了，正点原子这个地方讲的太烂了，甚至手册里面的代码都不一样，我果断抛弃，直接在spi的基础上写菜单了，因为spi里面也有lcd的文件，直接用就可以了</p>
<h2 id="菜单实现"><a href="#菜单实现" class="headerlink" title="菜单实现"></a>菜单实现</h2><p>写个菜单，将其显示在屏幕上，同时利用flash存储与读写数据，同时利用按键选择具体改变的 数据类型并改变数据的大小。重新看一下任务的要求 ,其实大部分已经帮我们实现好了，接下来就是关于具体功能的实现。</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>我们一共有三个按键，我打算把<code>WK_UP</code>设为改变数据类型，从小到大改变，用三的余数来控制类型，KEY1设计为减小数据，KEY0设计为增大数据。一共确定三个数据类型（字符，uint，八位的二进制）放在屏幕中央实时显示。</p>
<h3 id="软件设计-7"><a href="#软件设计-7" class="headerlink" title="软件设计"></a>软件设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ALIENTEK Mini STM32开发板范例代码20</span></span><br><span class="line"><span class="comment">//SPI实验  </span></span><br><span class="line"><span class="comment">//技术支持：www.openedv.com</span></span><br><span class="line"><span class="comment">//广州市星翼电子科技有限公司</span></span><br><span class="line">   	</span><br><span class="line"><span class="comment">//要写入到W25Q64的字符串数组</span></span><br><span class="line"><span class="type">const</span> u8 TEXT_Buffer[]=&#123;<span class="string">&quot;lalalala&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowBinary</span><span class="params">(u16 x, u16 y, u8 num, u8 size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> binaryChar = (num &amp; (<span class="number">1</span> &lt;&lt; (<span class="number">7</span> - i))) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        LCD_ShowChar(x + i * (size / <span class="number">2</span>), y, binaryChar, size, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE sizeof(TEXT_Buffer)	 </span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">		</span><br><span class="line">u8 key;</span><br><span class="line"><span class="type">int</span> keynum=<span class="number">0</span>;</span><br><span class="line">u16 i=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> charData = <span class="string">&#x27;A&#x27;</span>; </span><br><span class="line">u32 uintData = <span class="number">123</span>;</span><br><span class="line">u8 binaryData = <span class="number">0x00</span>; </span><br><span class="line">u32 FLASH_SIZE;</span><br><span class="line">u16 id = <span class="number">0</span>;</span><br><span class="line">delay_init();	    	 <span class="comment">//延时函数初始化	  </span></span><br><span class="line">uart_init(<span class="number">9600</span>);	 	<span class="comment">//串口初始化为9600</span></span><br><span class="line">LED_Init();		  		<span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">LCD_Init();</span><br><span class="line">KEY_Init();				<span class="comment">//按键初始化		 	</span></span><br><span class="line">SPI_Flash_Init();  		<span class="comment">//SPI FLASH 初始化 	 </span></span><br><span class="line">POINT_COLOR=BLACK;<span class="comment">//设置字体为黑色 </span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	id = SPI_Flash_ReadID();</span><br><span class="line">	<span class="keyword">if</span> (id == W25Q64 || id == NM25Q64)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;W25Q64 Check Failed!&quot;</span>);</span><br><span class="line">	delay_ms(<span class="number">500</span>);</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Please Check!        &quot;</span>);</span><br><span class="line">	delay_ms(<span class="number">500</span>);</span><br><span class="line">	LED0=!LED0;<span class="comment">//DS0闪烁</span></span><br><span class="line">&#125;</span><br><span class="line">FLASH_SIZE=<span class="number">8</span>*<span class="number">1024</span>*<span class="number">1024</span>;	<span class="comment">//FLASH 大小为8M字节  </span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">70</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;WK_UP to change the data type &quot;</span>);</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">90</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY 1 to add&quot;</span>);</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">110</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY 0 to decline&quot;</span>);</span><br><span class="line">	LCD_ShowChar(<span class="number">60</span>,<span class="number">150</span>,charData,<span class="number">16</span>,<span class="number">0</span>);</span><br><span class="line">	LCD_ShowNum(<span class="number">20</span>,<span class="number">170</span>,uintData,<span class="number">8</span>,<span class="number">16</span>);</span><br><span class="line">	LCD_ShowBinary(<span class="number">60</span>, <span class="number">190</span>, binaryData, <span class="number">16</span>);</span><br><span class="line">	LCD_ShowNum(<span class="number">20</span>,<span class="number">210</span>,keynum,<span class="number">8</span>,<span class="number">16</span>);</span><br><span class="line">	key=KEY_Scan(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(key==WKUP_PRES)	<span class="comment">//WK_UP 按下,切换数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		keynum++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(key==KEY0_PRES)	<span class="comment">//KEY0 按下,增大数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">			charData++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">			uintData++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">			binaryData++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(key==KEY1_PRES)	<span class="comment">//KEY1 按下,减小数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">			charData--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">			uintData--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">			binaryData--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	i++;</span><br><span class="line">	delay_ms(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED0=!LED0;<span class="comment">//提示系统正在运行	</span></span><br><span class="line">		i=<span class="number">0</span>;</span><br><span class="line">	&#125;		   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们定义一下数据类型以及设定初始值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> charData = <span class="string">&#x27;A&#x27;</span>; </span><br><span class="line">u32 uintData = <span class="number">123</span>;</span><br><span class="line">u8 binaryData = <span class="number">0x00</span>; </span><br></pre></td></tr></table></figure>

<p>然后观察在lcd.h中设定的显示函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChar</span><span class="params">(u16 x, u16 y, u8 num, u8 size, u8 mode)</span>;               </span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowNum</span><span class="params">(u16 x, u16 y, u32 num, u8 len, u8 size)</span>;                  </span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowxNum</span><span class="params">(u16 x, u16 y, u32 num, u8 len, u8 size, u8 mode)</span>;       </span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(u16 x, u16 y, u16 width, u16 height, u8 size, u8 *p)</span>;   </span><br></pre></td></tr></table></figure>

<p>如果不明白的话也就在.c文件中有具体解释参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">LCD_ShowString(<span class="number">30</span>,<span class="number">70</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;WK_UP to change the data type &quot;</span>);</span><br><span class="line">		LCD_ShowString(<span class="number">30</span>,<span class="number">90</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY 1 to add&quot;</span>);</span><br><span class="line">		LCD_ShowString(<span class="number">30</span>,<span class="number">110</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY 0 to decline&quot;</span>);</span><br><span class="line">		LCD_ShowChar(<span class="number">60</span>,<span class="number">150</span>,charData,<span class="number">16</span>,<span class="number">0</span>);</span><br><span class="line">		LCD_ShowNum(<span class="number">20</span>,<span class="number">170</span>,uintData,<span class="number">8</span>,<span class="number">16</span>);</span><br><span class="line">		LCD_ShowBinary(<span class="number">60</span>, <span class="number">190</span>, binaryData, <span class="number">16</span>);</span><br><span class="line">		LCD_ShowNum(<span class="number">20</span>,<span class="number">210</span>,keynum,<span class="number">8</span>,<span class="number">16</span>);</span><br><span class="line">		key=KEY_Scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==WKUP_PRES)	<span class="comment">//WK_UP °´ÏÂ,ÇÐ»»Êý¾Ý</span></span><br><span class="line">		&#123;</span><br><span class="line">			keynum++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(key==KEY0_PRES)	<span class="comment">//KEY0 °´ÏÂ,Ôö´óÊý¾Ý</span></span><br><span class="line">		&#123;</span><br><span class="line"> 			<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">				charData++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">				uintData++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">				binaryData++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(key==KEY1_PRES)	<span class="comment">//KEY1 °´ÏÂ,¼õÐ¡Êý¾Ý</span></span><br><span class="line">		&#123;</span><br><span class="line"> 			<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">				charData--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">				uintData--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">				binaryData--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>最后在<code>while(1)</code>实现逻辑，是不是很简单呢</p>
<blockquote>
<p>其实可以更加完善一点的，但是选中的数据要框起来，但是没什么时间了，之后再搞这个</p>
</blockquote>
<h1 id="PID闭环控制（以平面上不掉落的小球为例子）"><a href="#PID闭环控制（以平面上不掉落的小球为例子）" class="headerlink" title="PID闭环控制（以平面上不掉落的小球为例子）"></a>PID闭环控制（以平面上不掉落的小球为例子）</h1><blockquote>
<p>需要参照物才能走直线</p>
</blockquote>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415125111521.png" alt="image-20240415125111521"></p>
<p>PID：<strong>偏差量</strong>通过怎样的计算才能得到<strong>执行量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">偏差量=目标量-小球位置</span><br><span class="line">比例P=偏差量*比例P系数（由于的单位不同）</span><br><span class="line">执行量=比例P</span><br></pre></td></tr></table></figure>

<h4 id="增幅器"><a href="#增幅器" class="headerlink" title="增幅器"></a>增幅器</h4><blockquote>
<p>如果小球持续向某一个方向移动呢？</p>
</blockquote>
<p>比例P通过增幅器增大</p>
<p>它通过过去累加经验，来判断比例P是否需要增加</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415130625126.png" alt="image-20240415130625126"></p>
<blockquote>
<p>增幅器需要限制，如果出现错误有可能会被累加到无限大。</p>
</blockquote>
<ol>
<li>在任何时候都限制大小</li>
<li>目标丢失情况下主动将积分I清零</li>
</ol>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415130817915.png" alt="image-20240415130817915"></p>
<h4 id="抑制器"><a href="#抑制器" class="headerlink" title="抑制器"></a>抑制器</h4><blockquote>
<p>如果小球持续向某个方向移动突然后退呢？</p>
<p>平台可以突然像反方向倾斜</p>
</blockquote>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415130644058.png" alt="image-20240415130644058"></p>
<p>提前预知可能会反方向</p>
<p>总体代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#计时</span><br><span class="line">运行时间=(系统运行时间()-计时)/<span class="number">1000</span></span><br><span class="line">计时=系统运行时间()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> n in range(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">    偏差量[n]=日标量[n]-小球位置[n]</span><br><span class="line">        </span><br><span class="line">    比例P[n]=偏差量[n]*比例P系数[n]</span><br><span class="line">        </span><br><span class="line">    积分I[n]=积分I[n]+偏差量[n]*积分I系数[n]*运行时间</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> 积分I[n]&gt;积分I最大值[n]:</span><br><span class="line">		积分I[n]=积分I最大值[n]</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>:积分I[n]&lt;-积分I最大值[n]:</span><br><span class="line">		积分I[n]=-积分I最大值[n]</span><br><span class="line">            </span><br><span class="line">    微分D[n]=(偏差量[n]-上一次偏差量[n])*微分D系数[n]/运行时间</span><br><span class="line">    上一次偏差量[n]=偏差量[n]</span><br><span class="line">            </span><br><span class="line">    执行量[n]=比例P[n]+积分I[n]+微分D[n]</span><br></pre></td></tr></table></figure>

<p>由于x和y轴需要分别控制，这里使用了for循环来表示xy轴</p>
<h4 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h4><blockquote>
<p>要如何确定比例P系数，积分I系数，微分D系数</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">大了</th>
<th align="center">小了</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P</td>
<td align="center">超出目标</td>
<td align="center">达不到目标</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">超出目标，系统迟钝</td>
<td align="center">小幅度偏差不能回正</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">高频抖动</td>
<td align="center">超出目标</td>
</tr>
</tbody></table>
<p>一般都是先P</p>
<h1 id="使用L298N电机驱动模块来对电机调速，实现PID速度环"><a href="#使用L298N电机驱动模块来对电机调速，实现PID速度环" class="headerlink" title="使用L298N电机驱动模块来对电机调速，实现PID速度环"></a>使用L298N电机驱动模块来对电机调速，实现PID速度环</h1><p>首先我是从大鱼电子那里要来的资料的，源码也包括了，之后我会更新一下这个PID速度闭环的具体的实现原理，stm32学了这么久，只会用但里面的深层原理还不是很明白</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://yourwebsite.com">Jaketmoon</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://yourwebsite.com/2024/03/04/STM32/">http://yourwebsite.com/2024/03/04/STM32/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yourwebsite.com" target="_blank">Jaketmoon の 博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/21/html%E4%BB%8B%E7%BB%8D/" title="html介绍"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">html介绍</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/04/java%E5%9F%BA%E7%A1%80/" title="java基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/02/29/51%E5%8D%95%E7%89%87%E6%9C%BA/" title="51单片机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-29</div><div class="title">51单片机</div></div></a></div><div><a href="/2024/07/15/mm32%E5%AD%A6%E4%B9%A0/" title="mm32学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-15</div><div class="title">mm32学习</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jaketmoon</div><div class="author-info__description">YOU WANT TO PLAY? LET'S PLAY!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">新建工程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.</span> <span class="toc-text">通讯协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-UART%EF%BC%88Universal-Asynchronous-Receiver-Transmitter%EF%BC%8C%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E4%BC%A0%E8%BE%93%E5%99%A8%EF%BC%89"><span class="toc-number">3.0.1.</span> <span class="toc-text">1. UART（Universal Asynchronous Receiver&#x2F;Transmitter，通用异步收发传输器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-I2C%EF%BC%88Inter-Integrated-Circuit%EF%BC%8C%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E6%80%BB%E7%BA%BF%EF%BC%89"><span class="toc-number">3.0.2.</span> <span class="toc-text">2. I2C（Inter-Integrated Circuit，集成电路总线）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SPI%EF%BC%88Serial-Peripheral-Interface%EF%BC%8C%E4%B8%B2%E8%A1%8C%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="toc-number">3.0.3.</span> <span class="toc-text">3. SPI（Serial Peripheral Interface，串行外围设备接口）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="toc-number">3.0.4.</span> <span class="toc-text">其他协议：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F"><span class="toc-number">4.</span> <span class="toc-text">系统时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E4%B8%AA%E6%97%B6%E9%92%9F%E6%BA%90"><span class="toc-number">4.1.</span> <span class="toc-text">五个时钟源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">作用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A"><span class="toc-number">4.2.0.0.1.</span> <span class="toc-text">A.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B"><span class="toc-number">4.2.0.0.2.</span> <span class="toc-text">B.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C"><span class="toc-number">4.2.0.0.3.</span> <span class="toc-text">C.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#D"><span class="toc-number">4.2.0.0.4.</span> <span class="toc-text">D.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#E"><span class="toc-number">4.2.0.0.5.</span> <span class="toc-text">E.</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96GPIO"><span class="toc-number">5.</span> <span class="toc-text">初始化GPIO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E4%B8%AAIO%E5%8F%A3%EF%BC%9A"><span class="toc-number">5.0.0.0.1.</span> <span class="toc-text">如何初始化多个IO口：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#system%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.</span> <span class="toc-text">system文件夹介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Delay"><span class="toc-number">6.1.</span> <span class="toc-text">Delay</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sys"><span class="toc-number">6.2.</span> <span class="toc-text">sys</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usart"><span class="toc-number">6.3.</span> <span class="toc-text">usart</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%91%E9%A9%AC%E7%81%AF%E5%AE%9E%E9%AA%8C"><span class="toc-number">7.</span> <span class="toc-text">跑马灯实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MODE"><span class="toc-number">7.1.</span> <span class="toc-text">MODE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LED-c"><span class="toc-number">7.2.</span> <span class="toc-text">LED.c</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E5%AE%9E%E9%AA%8C"><span class="toc-number">8.</span> <span class="toc-text">按键输入实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">8.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.2.</span> <span class="toc-text">软件设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%AE%9E%E9%AA%8C"><span class="toc-number">9.</span> <span class="toc-text">串口实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">9.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">9.2.</span> <span class="toc-text">软件设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">10.</span> <span class="toc-text">定时器中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STM32%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">10.1.</span> <span class="toc-text">STM32通用定时器简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-TIM3%E6%97%B6%E9%92%9F%E4%BD%BF%E8%83%BD"><span class="toc-number">10.1.1.</span> <span class="toc-text">1.TIM3时钟使能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8F%82%E6%95%B0-%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%8A%A8%E9%87%8D%E8%A3%85%E5%80%BC%EF%BC%8C%E5%88%86%E9%A2%91%E7%B3%BB%E6%95%B0%EF%BC%8C%E8%AE%A1%E6%95%B0%E6%96%B9%E5%BC%8F%E7%AD%89%E3%80%82"><span class="toc-number">10.1.2.</span> <span class="toc-text">2.初始化定时器参数,设置自动重装值，分频系数，计数方式等。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%BE%E7%BD%AE-TIM3-DIER-%E5%85%81%E8%AE%B8%E6%9B%B4%E6%96%B0%E4%B8%AD%E6%96%AD"><span class="toc-number">10.1.3.</span> <span class="toc-text">3.设置 TIM3_DIER 允许更新中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-TIM3-%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%BE%E7%BD%AE%E3%80%82"><span class="toc-number">10.1.4.</span> <span class="toc-text">4.TIM3 中断优先级设置。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%81%E8%AE%B8-TIM3-%E5%B7%A5%E4%BD%9C%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%BD%BF%E8%83%BD-TIM3%E3%80%82"><span class="toc-number">10.1.5.</span> <span class="toc-text">5.允许 TIM3 工作，也就是使能 TIM3。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BC%96%E5%86%99%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0%E3%80%82"><span class="toc-number">10.1.6.</span> <span class="toc-text">6.编写中断服务函数。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">10.2.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-2"><span class="toc-number">10.3.</span> <span class="toc-text">软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#timer-c"><span class="toc-number">10.3.1.</span> <span class="toc-text">timer.c</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PWM%E8%BE%93%E5%87%BA%E5%AE%9E%E9%AA%8C"><span class="toc-number">11.</span> <span class="toc-text">PWM输出实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-number">11.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%80%E5%90%AF-TIM1-%E6%97%B6%E9%92%9F%EF%BC%8C%E9%85%8D%E7%BD%AE-PA8-%E4%B8%BA%E5%A4%8D%E7%94%A8%E8%BE%93%E5%87%BA%E3%80%82"><span class="toc-number">11.1.1.</span> <span class="toc-text">1.开启 TIM1 时钟，配置 PA8 为复用输出。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE-TIM1-%E7%9A%84-ARR-%E5%92%8C-PSC%E3%80%82"><span class="toc-number">11.1.2.</span> <span class="toc-text">2.设置 TIM1 的 ARR 和 PSC。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%BE%E7%BD%AE-TIM1-CH1-%E7%9A%84-PWM-%E6%A8%A1%E5%BC%8F%E5%8F%8A%E9%80%9A%E9%81%93%E6%96%B9%E5%90%91-%E4%BD%BF%E8%83%BDTIM1-%E7%9A%84-CH1-%E8%BE%93%E5%87%BA%E3%80%82"><span class="toc-number">11.1.3.</span> <span class="toc-text">3.设置 TIM1_CH1 的 PWM **模式及通道方向, **使能TIM1 的 CH1 输出。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E8%83%BD-TIM1%E3%80%82"><span class="toc-number">11.1.4.</span> <span class="toc-text">4.使能 TIM1。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AE%BE%E7%BD%AE-MOE-%E8%BE%93%E5%87%BA%EF%BC%8C%E4%BD%BF%E8%83%BD-PWM-%E8%BE%93%E5%87%BA"><span class="toc-number">11.1.5.</span> <span class="toc-text">5.设置 MOE 输出，使能 PWM 输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BF%AE%E6%94%B9-TIM1-CCR1-%E6%9D%A5%E6%8E%A7%E5%88%B6%E5%8D%A0%E7%A9%BA%E6%AF%94%E3%80%82"><span class="toc-number">11.1.6.</span> <span class="toc-text">6.修改 TIM1_CCR1 来控制占空比。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">11.2.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-3"><span class="toc-number">11.3.</span> <span class="toc-text">软件设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.</span> <span class="toc-text">编码器接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-number">12.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-4"><span class="toc-number">12.2.</span> <span class="toc-text">软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#encoder-c"><span class="toc-number">12.2.0.1.</span> <span class="toc-text">encoder.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-c"><span class="toc-number">12.2.0.2.</span> <span class="toc-text">main.c</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SPI%E5%AE%9E%E9%AA%8C%EF%BC%88flash%E5%A4%96%E9%83%A8%E5%82%A8%E5%AD%98%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">SPI实验（flash外部储存）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="toc-number">13.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E5%BC%95%E8%84%9A%E7%9A%84%E5%A4%8D%E7%94%A8%E5%8A%9F%E8%83%BD%EF%BC%8C%E4%BD%BF%E8%83%BD-SPI1-%E6%97%B6%E9%92%9F%E3%80%82"><span class="toc-number">13.1.1.</span> <span class="toc-text">配置相关引脚的复用功能，使能 SPI1 时钟。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-SPI1-%E8%AE%BE%E7%BD%AE-SPI1-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.1.2.</span> <span class="toc-text">初始化 **SPI1,**设置 SPI1 工作模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E8%83%BD-SPI1"><span class="toc-number">13.1.3.</span> <span class="toc-text">使能 SPI1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%92%8C%E6%8E%A5%E5%8F%97%E6%95%B0%E6%8D%AE"><span class="toc-number">13.1.4.</span> <span class="toc-text">传输和接受数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-5"><span class="toc-number">13.2.</span> <span class="toc-text">软件设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TFLCD%E6%98%BE%E7%A4%BA%E5%AE%9E%E9%AA%8C-%E5%88%B6%E4%BD%9C%E8%8F%9C%E5%8D%95%E4%BB%BB%E5%8A%A1"><span class="toc-number">14.</span> <span class="toc-text">TFLCD显示实验(制作菜单任务)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-6"><span class="toc-number">14.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AE-STM32-%E4%B8%8E-TFTLCD-%E6%A8%A1%E5%9D%97%E7%9B%B8%E8%BF%9E%E6%8E%A5%E7%9A%84-IO"><span class="toc-number">14.1.1.</span> <span class="toc-text">1.设置 STM32 与 TFTLCD 模块相连接的 IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96-TFTLCD-%E6%A8%A1%E5%9D%97"><span class="toc-number">14.1.2.</span> <span class="toc-text">2.初始化 TFTLCD 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%B0%86%E5%AD%97%E7%AC%A6%E5%92%8C%E6%95%B0%E5%AD%97%E6%98%BE%E7%A4%BA%E5%88%B0-TFTLCD-%E6%A8%A1%E5%9D%97%E4%B8%8A"><span class="toc-number">14.1.3.</span> <span class="toc-text">3.通过函数将字符和数字显示到 TFTLCD 模块上</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-6"><span class="toc-number">14.2.</span> <span class="toc-text">软件设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.3.</span> <span class="toc-text">菜单实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">14.3.1.</span> <span class="toc-text">设计思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-7"><span class="toc-number">14.3.2.</span> <span class="toc-text">软件设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PID%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BB%A5%E5%B9%B3%E9%9D%A2%E4%B8%8A%E4%B8%8D%E6%8E%89%E8%90%BD%E7%9A%84%E5%B0%8F%E7%90%83%E4%B8%BA%E4%BE%8B%E5%AD%90%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">PID闭环控制（以平面上不掉落的小球为例子）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%B9%85%E5%99%A8"><span class="toc-number">15.0.0.1.</span> <span class="toc-text">增幅器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%91%E5%88%B6%E5%99%A8"><span class="toc-number">15.0.0.2.</span> <span class="toc-text">抑制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%8F%82"><span class="toc-number">15.0.0.3.</span> <span class="toc-text">调参</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8L298N%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E6%9D%A5%E5%AF%B9%E7%94%B5%E6%9C%BA%E8%B0%83%E9%80%9F%EF%BC%8C%E5%AE%9E%E7%8E%B0PID%E9%80%9F%E5%BA%A6%E7%8E%AF"><span class="toc-number">16.</span> <span class="toc-text">使用L298N电机驱动模块来对电机调速，实现PID速度环</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/14/grpc-gateway/" title="grpc-gateway">grpc-gateway</a><time datetime="2024-09-14T05:53:09.000Z" title="发表于 2024-09-14 13:53:09">2024-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/09/docker%E9%83%A8%E7%BD%B2go-web%E5%BA%94%E7%94%A8/" title="docker部署go web应用">docker部署go web应用</a><time datetime="2024-09-09T08:45:54.000Z" title="发表于 2024-09-09 16:45:54">2024-09-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/14/mongodb/" title="mongodb">mongodb</a><time datetime="2024-08-14T14:31:09.000Z" title="发表于 2024-08-14 22:31:09">2024-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/08/simple-Chat-Application/" title="simple-Chat-Application">simple-Chat-Application</a><time datetime="2024-08-08T12:37:01.000Z" title="发表于 2024-08-08 20:37:01">2024-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/15/mm32%E5%AD%A6%E4%B9%A0/" title="mm32学习">mm32学习</a><time datetime="2024-07-15T07:28:12.000Z" title="发表于 2024-07-15 15:28:12">2024-07-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Jaketmoon</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.11.0"></script><script src="/js/main.js?v=4.11.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>