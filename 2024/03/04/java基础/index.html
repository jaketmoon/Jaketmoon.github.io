<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java基础 | Jaketmoon の 博客</title><meta name="author" content="Jaketmoon"><meta name="copyright" content="Jaketmoon"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="特点半解释半编译的 源代码：java ——&gt;编译：javac.exe——&gt;字节码:class——&gt;解释：java.exe——&gt;机器。 文件目录bin:该路径下存放了各种工具命令。其中比较重要的有:javac和java conf:该路径下存放了相关配置文件。include:该路径下存放了一些平台特定的头文件，jmods:该路径下存放了各种模块。legal:该路径下存放了各模块">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础">
<meta property="og:url" content="http://yourwebsite.com/2024/03/04/java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Jaketmoon の 博客">
<meta property="og:description" content="特点半解释半编译的 源代码：java ——&gt;编译：javac.exe——&gt;字节码:class——&gt;解释：java.exe——&gt;机器。 文件目录bin:该路径下存放了各种工具命令。其中比较重要的有:javac和java conf:该路径下存放了相关配置文件。include:该路径下存放了一些平台特定的头文件，jmods:该路径下存放了各种模块。legal:该路径下存放了各模块">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-03-04T05:35:08.000Z">
<meta property="article:modified_time" content="2024-06-18T06:42:58.000Z">
<meta property="article:author" content="Jaketmoon">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yourwebsite.com/2024/03/04/java%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.11.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-18 14:42:58'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Jaketmoon の 博客"><span class="site-name">Jaketmoon の 博客</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-04T05:35:08.000Z" title="发表于 2024-03-04 13:35:08">2024-03-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-18T06:42:58.000Z" title="更新于 2024-06-18 14:42:58">2024-06-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>半解释半编译的</p>
<p>源代码：java ——&gt;编译：javac.exe——&gt;字节码:class——&gt;解释：java.exe——&gt;机器。</p>
<h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><p>bin:该路径下存放了各种工具命令。其中比较重要的有:javac和java</p>
<p>conf:该路径下存放了相关配置文件。<br>include:该路径下存放了一些平台特定的头文件，<br>jmods:该路径下存放了各种模块。<br>legal:该路径下存放了各模块的授权文档，<br>lib:该路径下存放了工具的一些补充JAR包。</p>
<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><p>文件名为Hello.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span>&#123;<span class="comment">//类和类名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：javac Hello.java</p>
<p>生成Hello.class（这个Hello类名，不是文件名，如果文件名修改的话也不变）</p>
<p>解释：java hello</p>
<p>出现hello world</p>
<h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p>这段Java代码定义了一个简单的程序，下面是对程序各部分的解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java复制class Hello &#123; // 类和类名</span><br></pre></td></tr></table></figure>

<ul>
<li><code>class Hello &#123;</code>：这是一个类的声明。在Java中，所有的函数和变量必须存在于类中。这里定义了一个名为<code>Hello</code>的类。Java文件名通常与public类的名称相同（如果有public类的话），并且每个<code>.java</code>文件可以包含一个public类。在这个情况下，<code>Hello</code>类不是public的，所以文件名不一定要与类名相同。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java复制    public static void main(String[] args) &#123;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public</code>：这是一个访问修饰符，表示<code>main</code>方法可以被任何对象或者类访问。</li>
<li><code>static</code>：表示<code>main</code>方法不需要创建类的实例就可以执行。这是必须的，因为<code>main</code>方法是程序的入口点，必须在程序启动时就能够被调用。</li>
<li><code>void</code>：表示<code>main</code>方法不返回任何值。</li>
<li><code>main</code>：这是程序的起始点。当Java程序被启动时，JVM寻找并调用<code>main</code>方法。</li>
<li><code>String[] args</code>：<code>main</code>方法接受一个参数，即<code>args</code>，它是一个<code>String</code>数组。这允许用户传递命令行参数给程序。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java复制        System.out.println(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>System.out.println</code>：这是一个命令，用来在控制台输出信息。<code>System</code>是一个预先定义的类，它提供了访问系统相关的属性和方法。<code>out</code>是<code>System</code>类的一个静态变量，指向<code>PrintStream</code>类型的实例，它连接到标准输出，通常是控制台。<code>println</code>是一个方法，用来输出一行信息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java复制    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这些括号标记了类定义和<code>main</code>方法的结束。</li>
</ul>
<p>总的来说，这段代码定义了一个名为<code>Hello</code>的类，它包含一个执行时会被JVM调用的<code>main</code>方法。<code>main</code>方法向控制台输出字符串”hello world”。这是最基础的Java程序结构，通常用于演示和教学目的。</p>
<h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><p>文件里面有公共类（public）的定义，类名要和文件名相同，类名开头要大写</p>
<p>如果一个源文件有多个类，如果编译之后会有对应的多个class文件，可以分个解释</p>
<p>常量要全大写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AGE=<span class="number">18</span>;</span><br></pre></td></tr></table></figure>



<h1 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h1><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240311143007971.png" alt="image-20240311143007971"></p>
<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><p>以下是基本数据类型之间的转换规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 从低容量到高容量（隐式）：</span><br><span class="line">  - byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</span><br><span class="line">  - char -&gt; int</span><br><span class="line">- 从高容量到低容量（显式）：</span><br><span class="line">  - double -&gt; float -&gt; long -&gt; int -&gt; short -&gt; byte</span><br><span class="line">  - 任何类型 -&gt; char (需要显式转换，且必须是兼容的值)</span><br></pre></td></tr></table></figure>

<p>xxxxxxxxxx %d:十进制整数。%i:整数，基本等同于%d。%f:小数（包含 float 类型和 double类型) 。%Lf: long double类型浮点。%p:指针。%s:字符串。%%:输出一个百分号。%c:字符。%ld:十进制 long int类型。%lld:十进制 long long类型。c</p>
<h1 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h1><h2 id="Sanner"><a href="#Sanner" class="headerlink" title="Sanner"></a>Sanner</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//这行代码创建了一个Scanner对象sc，使用System.in作为输入流，这通常指的是键盘输入。</span></span><br><span class="line">        <span class="type">boolean</span> a=sc.nextBoolean();</span><br><span class="line">        <span class="type">int</span> b=sc.nextInt();</span><br><span class="line">        <span class="type">double</span> c=sc.nextDouble();</span><br><span class="line">        String d=sc.next();<span class="comment">//字符</span></span><br><span class="line">        System.out.println(a+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nextline"><a href="#nextline" class="headerlink" title="nextline"></a>nextline</h3><p>如果经常出现超时的情况，可以试一下用nextline而非nextint之类的，一次性读取所有数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.*; <span class="comment">//导入包</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *@param args</span></span><br><span class="line"><span class="comment"> @return void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        String[] str=sc.nextLine().split(<span class="string">&quot; &quot;</span>);<span class="comment">//将输入的字符串以空格分割</span></span><br><span class="line">        System.out.println(Float.valueOf(str[<span class="number">0</span>]));<span class="comment">//将字符串转换为浮点数</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.*; <span class="comment">//导入包</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *@param args</span></span><br><span class="line"><span class="comment"> @return void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            a =System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="面向对象编程概述-object-oriented"><a href="#面向对象编程概述-object-oriented" class="headerlink" title="面向对象编程概述(object oriented)"></a>面向对象编程概述(object oriented)</h2><p>要开一辆车</p>
<p><strong>面向过程：</strong>写一个drivecar()函数</p>
<p><strong>面向对象：</strong>先构建一个对象Car，然后在对象中声明成员的属性以及成员函数，然后就可以在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;<span class="comment">//类名,抽象,不分配内存</span></span><br><span class="line">    <span class="comment">//成员变量,数据,属性.</span></span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="comment">//成员函数,方法,行为.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">perimeter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*(width+height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">area</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width*height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRectangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Rectangle r=<span class="keyword">new</span> <span class="title class_">Rectangle</span>();<span class="comment">//创建对象r,分配内存,就是实例化,将width和height赋值为0</span></span><br><span class="line">        <span class="comment">//r里面储存了width,height,perimeter(),area()的地址</span></span><br><span class="line">        r.width=<span class="number">10</span>;</span><br><span class="line">        r.height=<span class="number">20</span>;</span><br><span class="line">        System.out.println(r.perimeter());</span><br><span class="line">        System.out.println(r.area());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>面向对象编程主要基于以下四大基本概念：</p>
<ol>
<li><strong>封装</strong>：封装是指将数据（属性）和代码（方法）包装到单一的单位——对象中，并对对象的实际实现细节进行隐藏。在Java中，通过使用类来实现封装。类的成员变量通常被声明为私有（private），这意味着它们只能被类的方法访问。对外部世界隐藏对象的内部复杂性，同时提供可以被外界public访问的接口。</li>
<li><strong>继承</strong>：继承是一种创建新类的方式，新创建的类包含了另一个类的所有属性和方法。这使得代码的重用成为可能，并且可以在现有的基础上增加新的功能。在Java中，继承是通过<code>extends</code>关键字实现的。动物extends猫，狗，猫extends老虎，豹子</li>
<li><strong>多态</strong>：多态性意味着可以将子类的对象视为其父类的实例。这主要是通过重写（Overriding）实现的，即子类有一个与父类相同名称和参数的方法。Java还支持通过接口实现多态。多态允许同一接口使用不同的实现，提高了程序的扩展性和灵活性。不同对象调用相同方法时候会不一样，比如让老鼠和猫叫，方法是一样的，但是声音是不一样的。</li>
<li><strong>抽象</strong>：抽象是一种将复杂的现实转换成简单模型的方法，这通常涉及到创建抽象类和接口。抽象类是不能被实例化的类，用于声明类的某些部分为抽象的，即没有提供实现的方法。子类负责提供这些方法的实现。接口则是完全抽象的，只包含方法声明，而没有任何实现。</li>
</ol>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>定义类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    Person(<span class="type">int</span> a)&#123;</span><br><span class="line">        age=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">()</span>&#123;</span><br><span class="line">        age++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        age+=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建对象p1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">10</span>);</span><br><span class="line">p.show();</span><br><span class="line">p.grow();</span><br><span class="line">p.show();</span><br><span class="line">p.grow(<span class="number">10</span>);</span><br><span class="line">p.show();</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>在一个类里面，方法名相同，功能类似但是参数不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">POINT_test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Point P1=<span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">        P1.printPoint();</span><br><span class="line">        P1.distance();</span><br><span class="line">        Point P2=<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        P2.printPoint();</span><br><span class="line">        P2.distance();</span><br><span class="line">        System.out.println(P1.distance(P2));</span><br><span class="line">        System.out.println(P2.distance(P1,P2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    Point(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">        x=a;</span><br><span class="line">        y=b;</span><br><span class="line">    &#125;</span><br><span class="line">    Point()&#123;</span><br><span class="line">        x=sc.nextInt();</span><br><span class="line">        y=sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printPoint</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(&quot;</span>+x+<span class="string">&quot;,&quot;</span>+y+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">distance</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(x*x+y*y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">distance</span><span class="params">(Point q)</span>&#123;<span class="comment">//这里传入不同的参数，this代表着当前的对象</span></span><br><span class="line">        <span class="keyword">return</span> Math.sqrt((<span class="built_in">this</span>.x-q.x)*(<span class="built_in">this</span>.x-q.x)+(<span class="built_in">this</span>.y-q.y)*(<span class="built_in">this</span>.y-q.y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">(Point p,Point q)</span>&#123;<span class="comment">//像这个与传入的参数没什么关系的函数可使用static，可以不产生对象直接使用Point当对象。</span></span><br><span class="line">        <span class="keyword">return</span> Math.sqrt((p.x-q.x)*(p.x-q.x)+(p.y-q.y)*(p.y-q.y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：java可以同名不同参</p>
</blockquote>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>有时候一个对象只用一次的时候，我们就直接只用new Point(1,1)来操作，从而减少内存浪费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">1</span>).distance();</span><br></pre></td></tr></table></figure>

<h2 id="实现类的封装性"><a href="#实现类的封装性" class="headerlink" title="实现类的封装性"></a>实现类的封装性</h2><p>为了实现良好的封装性，通常将成员变量设置为<strong>private</strong></p>
<p>通过<strong>public的方法</strong>来访问这个变量</p>
<p>这些public的方法一般都是读取和赋值的操作。</p>
<h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x=x;<span class="comment">//我们要使用this.才能改变对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="直接用this构造函数"><a href="#直接用this构造函数" class="headerlink" title="直接用this构造函数"></a>直接用this构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point(<span class="type">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Point</span>(a,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point P3=<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>这样调用是无法传入P3值的</p>
<p>可以用this构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point(<span class="type">int</span> a)&#123;</span><br><span class="line">    <span class="built_in">this</span>(a,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意！！！！！：使用这个方法的前提是要先定义<code>Point(int a,int b)</code>这个构造函数，而且不能再它函数里面自己调用自己。</p>
<h3 id="缺省构造函数"><a href="#缺省构造函数" class="headerlink" title="缺省构造函数"></a>缺省构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 这里没有显式定义构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 调用了MyClass的缺省构造方法来创建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果一个类中没有显式地定义任何构造方法，Java编译器会自动为这个类提供一个无参的构造方法，这就是缺省构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式定义了一个有参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还需要无参数的构造方法，必须显式定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 缺省构造方法体，可以初始化默认值</span></span><br><span class="line">        <span class="built_in">this</span>.value = <span class="number">0</span>; <span class="comment">// 例如，为value成员变量赋一个默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果有显式的构造方法，那就必须定义无参数的方法。</p>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>将功能相近的类放在同一个包中，可以方便查找与使用</li>
<li>由于在不同包中可以存在同名类，所以使用包在一定程度上可以避免命名冲突</li>
<li>在Java中，某些访问权限是以包为单位的</li>
</ol>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h3><blockquote>
<p>final:使用此修饰符的类的不能被继承</p>
</blockquote>
<blockquote>
<p>abstract:该类是不允许被实例化的类，也就是说该类需要被扩展继承。被这样声明的类也称为抽象类。类中只要有一abstract方法，类就只能被定义为abstract</p>
</blockquote>
<h3 id="属性的修饰符"><a href="#属性的修饰符" class="headerlink" title="属性的修饰符"></a>属性的修饰符</h3><blockquote>
<p>final:常量，值只能分配一次，不能更改.可以同static一起使用，避免对类的每</p>
<p>个实例维护一个拷贝。</p>
</blockquote>
<blockquote>
<p>static:不用创建对象就可以直接调用.包括可以使用在成员上面，之后就可以任意使用此成员，无需另外准备,它指向同一个地址</p>
</blockquote>
<p><strong>例子：(共有的成员z，也就是所有对象的z都是一个z)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ABCD</span>&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> z=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Main&#123;</span><br><span class="line">    ABCD data1=<span class="keyword">new</span> <span class="title class_">ABCD</span>();</span><br><span class="line">&#125;<span class="comment">//无论是data1.z or ABCD.z，都是一个z=3；</span></span><br></pre></td></tr></table></figure>

<p>在静态的方法中不能调用非静态的对象，反之可以。静态的变量在类的声明的时候就已经</p>
<h3 id="方法的修饰符"><a href="#方法的修饰符" class="headerlink" title="方法的修饰符"></a>方法的修饰符</h3><blockquote>
<p>static:提供不依赖于类实例的服务并不需要创建类的实例就可以访问静态方法。静态方法只能访问静态变量，非静态的方法都可以访问。</p>
</blockquote>
<blockquote>
<p>final:防止任何子类覆盖该方法 .可以同static一起使用，避免对类的每个实例维护一个拷贝</p>
</blockquote>
<blockquote>
<p>abstract :抽象方法，类中有声明而没有实现的方法 不能将static方法、final方法或者类的构造器方法声明为abstract</p>
</blockquote>
<h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><blockquote>
<p>public:可以被所有类访问，public类必须定义在和类名相同的同名文件中</p>
</blockquote>
<blockquote>
<p>缺省:可以被同一个包中的类访问 。默认的访问权限，可以定义在和public类的同一个文件中</p>
</blockquote>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240408141935841.png" alt="image-20240408141935841"></p>
<h1 id="数组和java常用类"><a href="#数组和java常用类" class="headerlink" title="数组和java常用类"></a>数组和java常用类</h1><blockquote>
<p>数组的类型可以为基本数据类型(如int、char)，也可以为引用数据类型(如Point类、Circle类、int[])。</p>
</blockquote>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>每个初始化都必须要new 类型</p>
<h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] x=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//或者int[] x=new int[]&#123;1,2,3,4&#125;;，这里是省略了</span></span><br></pre></td></tr></table></figure>

<p>下面是错误做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] x;</span><br><span class="line">x = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><p>一般来说在初始化数组的时候无需指定它的长度，只有在你想要创建一个具有指定大小但不立即初始化元素的数组时，你才明确指定数组的长度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] months= <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">12</span>];<span class="comment">//每个数组元素默认为0</span></span><br></pre></td></tr></table></figure>

<p>说人话：初始化要么说明长度，要么说明具体元素</p>
<p>默认值的规定如下：</p>
<p><code>a) boolean类型的默认值是false。</code></p>
<p><code>b) 其它7种基本数据类型的默认值是0。其中char的默认值是编码为0的字符，而不是字符‘0’。</code></p>
<p><code>c) 引用数据类型的初始值是null。</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] x;<span class="comment">//声明但未初始化</span></span><br><span class="line">x = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>这样是可以的</p>
<h3 id="for-each-语句遍历"><a href="#for-each-语句遍历" class="headerlink" title="for each 语句遍历"></a>for each 语句遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(数据类型 变量名：数组名)</span><br><span class="line">	语句；</span><br><span class="line"><span class="comment">//数据类型必须与数组元素的数据类型相同</span></span><br></pre></td></tr></table></figure>

<p><strong>ex:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:arr)</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] xx;</span><br><span class="line">xx=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][]; </span><br><span class="line">xx[<span class="number">0</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">xx[<span class="number">1</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">xx[<span class="number">2</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240408153304214.png" alt="image-20240408153304214"></p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><strong>数据类型【】【】数组标识符 ;</strong></p>
<p>数据类型 数组标识符【】【】； </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] days;</span><br><span class="line"><span class="type">boolean</span> holidays[][];</span><br></pre></td></tr></table></figure>

<p>两种都可以</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><strong>（1）通过new关键字创建</strong></p>
<p><strong>（2）通过“{ }”创建</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] days = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">2</span>];<span class="comment">//其中的2可加可不加</span></span><br><span class="line">days[<span class="number">0</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;...&#125;</span><br><span class="line">.....</span><br><span class="line"><span class="type">boolean</span> holidays[][] = &#123; &#123; <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span> &#125;, &#123; <span class="literal">false</span>, <span class="literal">true</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><blockquote>
<p>java.util.Arrays类包含用来操作数组(如排序和搜索)的各种函数。</p>
</blockquote>
<p><code>Arrays.fill</code>函数将某个值赋值给数组全部或部分元素</p>
<p><code>Arrays.toString</code>、<code>Arrays.deepToString</code>函数打印数组元素</p>
<p><code>Arrays.copyOf</code>、<code>Arrays.copyOfRange</code>函数复制数组</p>
<p><code>Arrays.equals</code>、<code>Arrays.deepEquals</code>函数比较数组</p>
<p><code>Arrays.sort</code> 函数对数组元素从小到大排序</p>
<p><code>Arrays.binarySearch</code>函数在数组中检索目标元素是否存在</p>
<h2 id="包装类-Integer-Double-…"><a href="#包装类-Integer-Double-…" class="headerlink" title="包装类(Integer,Double …..)"></a>包装类(Integer,Double …..)</h2><blockquote>
<p>如何把一个十进制整数转化为二进制，八进制。。。。</p>
<p>如何进行基本类型的转换</p>
</blockquote>
<p>java中有一个默认的包java.lang包</p>
<p>包装类的常量<code>MAX VALUE</code>和<code>MIN VALUE</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer.MAX VALUEint类型的最大值</span><br><span class="line">Integer.MIN VALUEint类型的最小值</span><br></pre></td></tr></table></figure>

<p>包装类的静态方法：</p>
<p>1.数据类型和字符串之间转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i1=Integer.valueOf(<span class="number">100</span>);<span class="comment">//int转int（对象）</span></span><br><span class="line">Integer i2=Integer.valueOf(“<span class="number">123</span>”);  <span class="comment">//str转int（对象）</span></span><br><span class="line">String str=Integer.toString(<span class="number">123</span>);<span class="comment">//int转str（对象）</span></span><br><span class="line"><span class="type">double</span> i=Double.parseDouble( “<span class="number">123</span>”);<span class="comment">//字符串直接转double类型</span></span><br></pre></td></tr></table></figure>

<p>2.进制之间转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer.toBinaryString(<span class="number">100</span>)<span class="comment">//2</span></span><br><span class="line">Integer.toOctalString(<span class="number">100</span>)<span class="comment">//8</span></span><br><span class="line">Integer.toHexString(<span class="number">100</span>)<span class="comment">//16</span></span><br></pre></td></tr></table></figure>

<p>3.自动拆箱装箱</p>
<p>在转化为int（对象）之后需要调用</p>
<p><code>int value = i1.intValue();</code>才可以获取值，但是在后面的版本中可以直接赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i1=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">Integer i2=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">Integer i3=<span class="number">789</span>;<span class="comment">//自动装箱 (直接给对象赋值)</span></span><br><span class="line"><span class="type">int</span> i4=i3;<span class="comment">//自动拆箱（直接获得i3对应的值到i4）</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><p>Java中的字符串作为对象处理，用字符串类封装一个字符串的字符序列及与之有关的其他操作，如求长度等。</p>
<p>字符串类位于java.lang包</p>
<p>常用有字符串类有:String、StringBuffer、!StringBuilder</p>
<h3 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h3><h4 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>.</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>首先要说明一点，与c不同，<code>char a[]=&quot;abc&quot;</code>是错误的,<code>String str=&quot;abc&quot;</code>是可以的</p>
<p><code>String s2 = new String(&quot;hello&quot;);</code>可以将<code>“hello”</code>位置的的数据转化为string类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">问题<span class="number">4</span>:以下能构造“java”字符串的语句是( )?</span><br><span class="line">    A、<span class="type">int</span> b[]= &#123;<span class="number">106</span>,<span class="number">97</span>,<span class="number">118</span>,<span class="number">97</span>&#125;;</span><br><span class="line">	   String s4=<span class="keyword">new</span> <span class="title class_">String</span>(b)</span><br><span class="line">    B、<span class="type">byte</span> c[]=&#123;<span class="number">106</span>,<span class="number">97</span>,<span class="number">118</span>,<span class="number">97</span>&#125;;</span><br><span class="line">	   String s5=<span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">	C、<span class="type">char</span> a[]=&#123; <span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;<span class="comment">//字符数组转化为String</span></span><br><span class="line">	   String s3=<span class="keyword">new</span> <span class="title class_">String</span>(a);</span><br></pre></td></tr></table></figure>

<p>A是错的，因为一个char占两个字节，int4个字节，byte一个字节，只能少不能多</p>
<h4 id="字符数组和字符串的转化"><a href="#字符数组和字符串的转化" class="headerlink" title="字符数组和字符串的转化"></a>字符数组和字符串的转化</h4><p>字符数组转化为字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] ch=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span><span class="string">&#x27;&#x27;</span>c<span class="string">&#x27;&#125;;</span></span><br><span class="line"><span class="string">String ascStr=ch.toString();//返回的是数组地址</span></span><br><span class="line"><span class="string">String str= newString(ch);//返回的是对应的字符串</span></span><br></pre></td></tr></table></figure>

<p>字符串转化为字符数组;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str= <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] ch = str.toCharArray();</span><br></pre></td></tr></table></figure>

<h4 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h4><p>1.求字符串长度<code>int length()</code></p>
<p>2.字符串的大小写转换：</p>
<p>​	<code>String toLowerCase()</code></p>
<p>​	<code>String toUppercase()</code></p>
<p>3.字符串连接：<code>String concat(String)</code></p>
<p>​	ex：<code>String str=&quot;This&quot;.concat(&quot;a demo&quot;);</code></p>
<p>4.前缀后缀判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String)</span>判断前缀是否匹配</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String)</span>判断后缀是否匹配</span><br></pre></td></tr></table></figure>

<p>5.是否相同：</p>
<p>“&#x3D;&#x3D;”是字符串储存地址比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object)</span>区分大小写</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String)</span>不区分大小写</span><br></pre></td></tr></table></figure>

<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415144917881.png" alt="image-20240415144917881"></p>
<p>6.比较大小(前减去后)，返回负数或者true，相同？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String)</span>区分大小写 </span><br><span class="line"><span class="type">int</span> <span class="title function_">compareToIgnoreCase</span><span class="params">(String)</span>不区分大小写</span><br></pre></td></tr></table></figure>

<p>7.检索字符</p>
<p> <img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415151429887.png" alt="image-20240415151429887"></p>
<p>8.截取子串</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415163402973.png" alt="image-20240415163402973"></p>
<h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p><strong>String类</strong></p>
<blockquote>
<p>定义不可变对象，一旦被创建，就不能修改它的值，对于已经存在的String对象的修改都是重新创建一个新的对象，然后把新的值保存进去。</p>
</blockquote>
<p><strong>StringBuffer类、StringBuilder类</strong></p>
<blockquote>
<p>定义可变对象，当对它进行修改的时候不会像String那样重新建立只能通过构造函数来建立StringBuffer可安全用于多线程编程StringBuilder用于多线程编程不安全，但速度更快</p>
</blockquote>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是一种创建新类的方式，新创建的类包含了另一个类的所有属性和方法。这使得代码的重用成为可能，并且可以在现有的基础上增加新的功能。在Java中，继承是通过<code>extends</code>关键字实现的。动物extends猫，狗，猫extends老虎，豹子</p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415145518728.png" alt="image-20240415145518728"></p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415145813680.png" alt="image-20240415145813680"></p>
<h2 id="方法的重写（override）"><a href="#方法的重写（override）" class="headerlink" title="方法的重写（override）"></a>方法的重写（override）</h2><p>重载是方法的参数改变了</p>
<p>在子类中声明与父类相同名字的函数，如果调用的话就遵守子类的声明，前提的参数，返回类型要一致，权限不能缩小，不能抛出新的异常。</p>
<p>final:写在成员变量前面，则此成员变量无法被修改</p>
<p>​	写在方法前面，则此方法无法重写</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415152840881.png" alt="image-20240415152840881"></p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415152617052.png" alt="image-20240415152617052"></p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super变量表示父类对象</p>
<p>在子类中使用已经被这个子类重写过的方法，使用super.xxxx</p>
<h2 id="子类对象实例化"><a href="#子类对象实例化" class="headerlink" title="子类对象实例化"></a>子类对象实例化</h2><p>父类有无参构造函数，子类没有构造函数，在子类对象实例化的时候会直接调用父类的构造函数</p>
<p>父类有有参构造函数，子类用super使用,子类想要方法重载自己的构造函数，则可以直接使用this</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    Animal(String n,<span class="type">int</span> a)&#123;</span><br><span class="line">        name=n;</span><br><span class="line">        age=a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    String color;</span><br><span class="line">    Cat(String n,<span class="type">int</span> a,String c)&#123;</span><br><span class="line">        <span class="built_in">super</span>(n,a);<span class="comment">//必须在第一句</span></span><br><span class="line">        color=c;</span><br><span class="line">    &#125;</span><br><span class="line">    Cat()&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">2</span>,<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用时</span></span><br><span class="line">Cat c=<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;tom&quot;</span>,<span class="number">5</span>,<span class="string">&quot;white&quot;</span>);</span><br><span class="line">Cat b=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>

<p>要注意的是，虽然调用了子类自己的构造方法，但还是会隐式调用父类的无参构造方法</p>
<h1 id="多态-1"><a href="#多态-1" class="headerlink" title="多态"></a>多态</h1><p>多态是面向对象基本特征之一。</p>
<p>通常使用方法的重载（Overload）和重写（Override)实现类的多态性。</p>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>方法的重载是指在一个类中，出现多个<strong>方法名相同，但参数个数或参数类型不同</strong>的方法。</p>
<p>重载的方法之间并不一定必须有联系，但是为了提高程序的可读性，一般只重载功能相似的方法。</p>
<p>通过方法重载实现<strong>静态的多态</strong></p>
<h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>重写方法必须和被重写方法具有<strong>相同的方法名称、参数列表和返回值类型。</strong></p>
<p>通过重写父类的方法来实现，在运行时根据传递的对象引用，来调用相应的方法。</p>
<p>通过方法的重写，实现<strong>动态的多态性</strong></p>
<h2 id="向上（下）转型"><a href="#向上（下）转型" class="headerlink" title="向上（下）转型"></a>向上（下）转型</h2><h5 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h5><p>一个对象可以看做本类类型，也可以看做它的父类类型。取得一个对象的引用并将它看做父类的对象，称为向上转型。</p>
<h5 id="对象的类型转换"><a href="#对象的类型转换" class="headerlink" title="对象的类型转换"></a>对象的类型转换</h5><p>子类对象可以自动转换成父类对象</p>
<p>父类对象不能转换成子类对象</p>
<p>可以用instanceof 操作符来判断一个实例对象是否属于一个类</p>
<p>强制转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shape s=Circle(<span class="string">&quot;cir&quot;</span>,<span class="number">10</span>);<span class="comment">//向上</span></span><br><span class="line">c=(Circle)s;<span class="comment">//向下</span></span><br></pre></td></tr></table></figure>

<h2 id="特殊类"><a href="#特殊类" class="headerlink" title="特殊类"></a>特殊类</h2><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>使用final关键字修饰的类不能被继承</p>
<h5 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h5><p>抽象类不能被实例化，只能被子类继承。</p>
<p>如果一个子类没有实现抽象父类中所有的抽象方法，则子类也成为一个抽象类；如果一个子类实现抽象父类中所有的抽象方法，则子类不是一个抽象类。</p>
<p>我们可以将一个没有任何抽象方法的类声明为abstract，避免由这个类产生任何的对象。</p>
<p>构造方法、static方法、private方法、final方法不能被声明为抽象的方法。</p>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>内部类就是在其他类内部定义的类。</p>
<blockquote>
<p>内部类的作用</p>
</blockquote>
<p> 隐藏你不想让别人知道的操作，也即封装性。</p>
<p> 一个内部类对象可以访问创建它的外部类对象的内容，甚至包括私有变量。</p>
<p>内部类有以下四种形式：成员内部类、局部内部类、静态内部类、匿名内部类。</p>
<h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index=<span class="number">100</span>; <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        Inner i=<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        i.print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123; <span class="comment">// 成员内部类</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> out.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.print()</span><br></pre></td></tr></table></figure>

<p>只有创建了成员内部类的实例，才能使用成员内部类的变量和方法。</p>
<h4 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h4><p>就是没有名名称的内部类，一般格式为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ClassName</span>()&#123;……&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Apple</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">introduction</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是一个匿名类，但是谁也无法使用它。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>object是 所有java类的祖先，所有类中隐含了extends Object</p>
<p>所以说每个类都有这个方法</p>
<p><code>toString（）</code>方法</p>
<p><code>equals（）</code>方法，<code>hashCode()</code>方法</p>
<p><code>clone（）</code> 方法</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Garbage</span> &#123;</span><br><span class="line">    <span class="type">int</span> index; <span class="comment">//当前对象的索引值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> count; <span class="comment">//当前产生了几个对象</span></span><br><span class="line">    Garbage()&#123;</span><br><span class="line">        count++;</span><br><span class="line">        index=count;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span>+index+<span class="string">&quot;个对象构建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Garbage</span>(); <span class="comment">//垃圾内存</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Garbage</span>(); <span class="comment">//垃圾内存</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span>+index+<span class="string">&quot;个对象被回收&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java中的finalize()方法</p>
<p>用于在对象被垃圾回收机制销毁之前执行一些资源回收工作，由垃</p>
<p>圾回收系统调用，可以重写该方法。</p>
<p>System.gc()的作用</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java只支持单继承，不支持多继承，即一个类只能有一个父类。但是在实际应用中，又经常需要使用<strong>多继承</strong>来解决问题。为了解决该问题，Java提供了接口来实现类的多继承功能。</p>
<p>如果一个抽象类中的所有方法都是抽象的，我们就可以将这个类用另外一种方式来定义，也就是接口定义。（也就是把&#x3D;相当于抽象类更加规范化）</p>
<p>接口是抽象方法和常量值的定义的集合，从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。</p>
<h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名 [extends 父接口名列表]&#123;</span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] 常量;</span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">abstract</span>] 方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和public类一样，public接口也必须定义在与接口同名的文件中。</p>
<p>接口中所有的方法都是public abstract。</p>
<p>接口中可以有数据成员，这些成员默认都是public static final。可以用类名或对象名直接访问！</p>
<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class &lt;类名&gt; [extends 父类][implements 接口列表]</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>可以implements 多个接口，用逗号连接。</p>
<p><strong>在类中必须实现接口中的所有方法。方法的名字、返回值类型、参数的个数及类型必须与接口中的完全一致</strong></p>
<p>一个接口路</p>
<p>接口举例子</p>
<h3 id="接口多继承"><a href="#接口多继承" class="headerlink" title="接口多继承"></a>接口多继承</h3><p>一个接口可以继承多个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Sofa</span> <span class="keyword">extends</span> <span class="title class_">Sittable</span>,Lie<span class="comment">//这是两个接口</span></span><br></pre></td></tr></table></figure>





<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>如果使用大量的if语句的话会非常麻烦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">readFile &#123; </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    打开文件；</span><br><span class="line">    判断大小;</span><br><span class="line">    分配内存;</span><br><span class="line">    读入内存; </span><br><span class="line">    关掉文件; </span><br><span class="line">    &#125; <span class="keyword">catch</span> (文件打开失败) &#123; 处理代码；</span><br><span class="line">    &#125; <span class="keyword">catch</span> (大小取不到失败) &#123; 处理代码;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (内存分配失败) &#123; 处理代码;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (读取失败) &#123; 处理代码;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (文件关闭失败) &#123; 处理代码; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优雅</strong></p>
<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>异常通常分为三种类型：</p>
<blockquote>
<p>第一类是Java虚拟机由于某些内部错误产生的异常，这类异常不在用户程序的控制之内，用户不需要处理这类异常；</p>
</blockquote>
<blockquote>
<p>第二类是标准异常，这类异常通常是由程序代码中的错误产生的，例如被0除、数组下标越界等。这是需要用户程序处理的异常；</p>
</blockquote>
<blockquote>
<p>第三类是用户根据需要在程序中自定义的异常</p>
</blockquote>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240506145218933.png" alt="image-20240506145218933"></p>
<h3 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h3><p>Error类及其子类通常用来描述Java运行系统中的内部错误以及资源耗尽的错误。Error表示的异常是比较严重，仅靠修改程序本身是不能恢复执行的，被称为致命异常类。</p>
<h3 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h3><p>Exception类可称为非致命异常类，它代表了另一种异常。发生该异常的程序，通过捕获处理后可正常运行，保持程序的可读性及可靠性</p>
<h2 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="Java中的异常处理机制"><a href="#Java中的异常处理机制" class="headerlink" title="Java中的异常处理机制"></a>Java中的异常处理机制</h3><blockquote>
<p>声明异常、抛出异常、捕获异常、处理异常</p>
</blockquote>
<h3 id="5个关键字"><a href="#5个关键字" class="headerlink" title="5个关键字"></a>5个关键字</h3><blockquote>
<p>try、catch、finally、throw、throws</p>
</blockquote>
<p>处理过程：</p>
<p>Java程序在执行过程中如出现异常，会自动生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为**抛出(throw)**异常。</p>
<p>当Java运行时系统接收到异常对象时，会寻找能处理这一异常的代码并把当前异常对象交给其处理，这一过程称为**捕获(catch)**异常。</p>
<p>如果Java运行时系统找不到可以捕获异常的方法，则运行时系统将终止，相应的Java程序也将退出。</p>
<p>使用<strong>try-catch-finally</strong>语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">	可能出现异常的程序代码</span><br><span class="line">&#125;<span class="keyword">catch</span> ( IOException 异常对象e )&#123; </span><br><span class="line">	进行IOException异常处理的代码<span class="comment">//这里调用异常类的方法</span></span><br><span class="line">&#125; <span class="keyword">catch</span>( NullPointerException 异常对象e ) &#123;</span><br><span class="line">	进行NullPointerException异常处理的代码</span><br><span class="line">&#125; ... ... </span><br><span class="line"><span class="keyword">catch</span> (Exception 异常对象e )&#123; </span><br><span class="line">		进行Exception异常处理的代码</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	最终清理的程序代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、每个try语句块后至少必须紧跟一个catch语句块或finally语句块。</p>
<p>2、在try语句与catch语句之间、相邻catch语句之间，不允许出现其他程序代码。</p>
<p>3、finally语句也可以没有。如有，无论有无异常，最后必须执行finally语句中的语句体。</p>
<p>4、catch语句仅需要一个参数，必须是Throwable类及其子类的对象。</p>
<p>常见以 <code>Exception</code> 为父类的异常对象包括：</p>
<ol>
<li><code>NullPointerException</code>（空指针异常）：当应用程序试图访问空对象或者对 <code>null</code> 值的对象进行操作时抛出。</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组下标越界异常）：当应用程序试图访问数组的索引超出有效范围时抛出。</li>
<li><code>NumberFormatException</code>（数字格式异常）：当应用程序试图将一个字符串转换为数字，但字符串无法被正确解析为数字时抛出。</li>
<li><code>ClassCastException</code>（类转换异常）：当尝试将一个对象强制转换为与其实际类型不兼容的类型时抛出。</li>
<li><code>ArithmeticException</code>（算术异常）：当在进行算术运算时发生错误，例如除数为零时抛出。</li>
<li><code>IllegalArgumentException</code>（非法参数异常）：当传递给方法的参数不符合预期时抛出。</li>
<li><code>IOException</code>（输入&#x2F;输出异常）：当发生与输入&#x2F;输出相关的错误时抛出，例如文件无法打开、读取或写入。</li>
<li><code>InterruptedException</code>（中断异常）：当线程在等待、休眠或被中断时抛出。</li>
</ol>
<p>如果不知道是什么类型错误，那就在最后使用expection</p>
<h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p>throws对方法可能出现的异常进行声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">devide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x/y; </span><br><span class="line">        <span class="keyword">return</span> result; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123; </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            	<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>().devide(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123; </span><br><span class="line">            	System.out.println(e.getMessage()); </span><br><span class="line">    		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>devide</code>函数要求调用它的函数必须要有异常处理，这就落在了<code>TestException</code>,如果<code>TestException</code>也使用了<code>throws</code>，那就调用<code>TestException</code>的函数来进行异常处理</p>
<h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>throw抛出具体异常对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">check</span><span class="params">(String strage)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(strage);</span><br><span class="line">    <span class="keyword">if</span>(age&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(“年龄不能为负数！”);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">myage</span> <span class="operator">=</span> check(“-<span class="number">101</span>”);</span><br><span class="line">            System.out.println(myage);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">       		System.out.println(“出错原因：” + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛出throw异常之后,使用try-catch语句捕获throw抛出的异常并进行处理</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>由用户自己定义的异常称为自定义异常。自定义异常一般通过继承Exception类来实现。其一般语法格式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 自定义异常类名 <span class="keyword">extends</span> <span class="title class_">Exception</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于自定义异常，Java系统不会自动为用户抛出属于该类的对象，</p>
<p>用户须在程序中使用throw关键字来自行抛出异常对象。throw语</p>
<p>句的通常形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常类对象；</span><br></pre></td></tr></table></figure>

<p>ex:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、定义一个检查邮件字符串的方法checkEmail(String)，对参数中的邮件地址进行检查。</span></span><br><span class="line"><span class="comment">//2、定义一个邮件地址异常类，处理如下几种情况：</span></span><br><span class="line"><span class="comment">//（1）邮件地址中没有”@”符号；  （提示： indexOf函数）</span></span><br><span class="line"><span class="comment">//（2）邮件地址中的“@“符号之前的字符个数至少为6位。</span></span><br><span class="line"><span class="comment">//3、从键盘输入邮件地址，进行测试。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">EmailException</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testException</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkEmail</span><span class="params">(String mail)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(mail.indexOf(<span class="string">&quot;@&quot;</span>)&lt;<span class="number">0</span>) </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmailException</span>(<span class="string">&quot;邮件地址中没有”@”符号&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(mail.indexOf(<span class="string">&quot;@&quot;</span>)&lt;<span class="number">6</span>) </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmailException</span>(<span class="string">&quot;邮件地址中的“@“符号之前的字符个数至少为6位。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			checkEmail(<span class="string">&quot;1245@54&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (EmailException e) &#123;</span><br><span class="line">			System.out.println(e);</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h1><h2 id="AWT"><a href="#AWT" class="headerlink" title="AWT"></a>AWT</h2><h1 id="文件和流"><a href="#文件和流" class="headerlink" title="文件和流"></a>文件和流</h1><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul>
<li><p>流（stream）是一组有序的数据序列。</p>
</li>
<li><p>数据流就是一串连续不断的数据的集合，就像水管里的水流。</p>
</li>
<li><p>文件是数据的静态存储形式，而流是指数据传输时的形态</p>
</li>
</ul>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;123.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(f.exists())</span><br><span class="line">                f.delete();</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f.createNewFile();</span><br><span class="line">                System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在Java中，所有的文件都是字节组成的。因此，使用字节流来读写文件是很常见的。</p>
</li>
<li><p>为了创建一个与文件相链接的字节流 ， 需要使用 FileInputStream 或FileOutputStream。要打开文件，只需要创建这两个类的一个对象，将文件名指定为构造函数的一个参数。一旦文件被打开，就可以对其进行读取和写入操作了。</p>
</li>
</ul>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>字节流是以字节（8位）为单位来处理数据的，由于字节流不会</p>
<p>对数据做任何转换，因此在读写二进制数据时就会使用字节流。</p>
<p> 字节流顶端是两个抽象类：</p>
<p> InputStream：字节输入流，是所有输入流的父类</p>
<p> OutputStream：字节输出流，是所有输出流的父类</p>
<h3 id="inputstream类"><a href="#inputstream类" class="headerlink" title="inputstream类"></a>inputstream类</h3><p><code>read(byte[] bytes) </code></p>
<p>从输入数据流中读取字节并存入数组b中</p>
<p><code>read(byte[] bytes,int off,int len) </code></p>
<p>从输入数据流读取len个字节，并存入数组bytes中</p>
<p><code>close() </code></p>
<p>关闭当前输入流，并释放任何与之关联的系统资源</p>
<p><code>abstract read() </code></p>
<p>从当前数据流中读取一个字节。若已到达流结尾，则返回-1</p>
<h3 id="outputstream类"><a href="#outputstream类" class="headerlink" title="outputstream类"></a>outputstream类</h3><p><code>write(byte[] bytes) </code></p>
<p>将byte[]数组中的数据写入到当前输出流</p>
<p><code>write(byte[] bytes,int off,int len) </code></p>
<p>将byte[]数组下标off开始的len长度的数据写入到当前输出流</p>
<p><code>flush() </code></p>
<p>刷新当前输出流，并强制写入所有缓冲的字节数据</p>
<p><code>close() </code></p>
<p>关闭当前输出流，并释放所有与当前输出流有关的系统资源</p>
<p><code>abstract write(int b) </code></p>
<p>写入一个byte数据到当前输出流</p>
<h3 id="使用字节流读文件"><a href="#使用字节流读文件" class="headerlink" title="使用字节流读文件"></a>使用字节流读文件</h3><p>在Java中，所有的文件都是字节组成的。因此，使用字节流来读写文件是很常见的。</p>
<p>为了创建一个与文件相链接的字节流 ， 需要使用 FileInputStream 或FileOutputStream。要打开文件，只需要创建这两个类的一个对象，文件名指定为构造函数的一个参数。一旦文件被打开，就可以对其进行读取和写入操作了。</p>
<h4 id="从文件输入FileInputStream"><a href="#从文件输入FileInputStream" class="headerlink" title="从文件输入FileInputStream"></a>从文件输入FileInputStream</h4><p>一种写法:<code>FileInputStream（String filePath）</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>另一种写法：<code>FileInputStream(File file)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(“test.txt”);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br></pre></td></tr></table></figure>

<p>ex：读取文件数据显示在控制台</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Test.txt&quot;</span>); </span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">    <span class="type">int</span> rs;</span><br><span class="line">    <span class="keyword">if</span>((rs=fis.read(bytes)) != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           System.out.write(bytes,<span class="number">0</span>,rs);</span><br><span class="line">        &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    	e.printStackTrace(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写入文件FileOutputStream"><a href="#写入文件FileOutputStream" class="headerlink" title="写入文件FileOutputStream"></a>写入文件FileOutputStream</h4><p><code>FileOutputStream(String filePath)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(“test.txt”);</span><br></pre></td></tr></table></figure>

<p><code>FileOutputStream(File file,boolean append) </code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(“test.txt”);</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>ex:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Test2.txt&quot;</span>); </span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">System.out.println(<span class="string">&quot;请输入你想存入文本的内容：&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!f.exists())</span><br><span class="line">    	f.createNewFile();</span><br><span class="line">    <span class="type">int</span> rs=System.in.read(bytes,<span class="number">0</span>,<span class="number">1024</span>); <span class="comment">//从控制台读取一串信息</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f, <span class="literal">true</span>);</span><br><span class="line">    fos.write(bytes,<span class="number">0</span>,rs); <span class="comment">//将读取的信息写入到文件中</span></span><br><span class="line">    fos.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">   		 e.printStackTrace(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>在处理字符文本的时候更加方便</p>
<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><p>字符流有两个父类一个是Reader类，用于字符输入，一个是Writer类，用于字符输出</p>
<p><code>read() </code></p>
<p>读入一个字符。若已读到流结尾，则返回值为−1</p>
<p><code>read(char[]) </code></p>
<p>读取一些字符到char[]数组内，并返回所读入的字符的数量。若已到达流结尾，则返回-1</p>
<p><code>reset()</code> </p>
<p>将当前输入流重新定位到最后一次调用mark() 方法时的位置</p>
<p><code>skip(long n) </code></p>
<p>跳过参数n指定的字符数量，并返回所跳过字符的数量</p>
<p><code>close() </code></p>
<p>关闭该流并释放与之关联的所有资源。在关闭该流后，再调用 read()、ready()、mark()、reset() 或 skip() 将抛出异常</p>
<h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><p><code>write(int c) </code></p>
<p>将字符c写入输出流</p>
<p><code>write(String str) </code></p>
<p>将字符串str写入输出流</p>
<p><code>write(char[] cbuf) </code></p>
<p>将字符数组的数据写入到字符输出流</p>
<p><code>flush() </code></p>
<p>刷新当前输出流，并强制写入所有缓冲的字节数据</p>
<p><code>close() </code></p>
<p>向输出流写入缓冲区的数据，然后关闭当前输出流，并释放所有与当前输出流有关的系统资源</p>
<h3 id="字符流读文件FileReader"><a href="#字符流读文件FileReader" class="headerlink" title="字符流读文件FileReader"></a>字符流读文件FileReader</h3><p>和字节流一样，有</p>
<p>FileReader(String filePath)</p>
<p>FileReader(File file)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Java\\A.txt&quot;</span>);</span><br><span class="line">    FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(f); <span class="comment">// 创建文件字符输入流</span></span><br><span class="line">    <span class="type">char</span>[] data=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">512</span>]; <span class="comment">//读取到的是char</span></span><br><span class="line">    <span class="type">int</span> rs=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((rs=fr.read(data))!= -<span class="number">1</span>)&#123;</span><br><span class="line">   		String str=<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,rs);</span><br><span class="line">    	System.out.println(str);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   		 e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字符流写文件FileWriter"><a href="#字符流写文件FileWriter" class="headerlink" title="字符流写文件FileWriter"></a>字符流写文件FileWriter</h3><p>FileWriter(String filePath)</p>
<p>FileWriter(File file)</p>
<p>A文件复制到B文件中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Java\A.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!f.exists()) <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    	f.createNewFile();</span><br><span class="line">    FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;C:\\Java\\B.txt&quot;</span>);<span class="comment">// 创建文件字符输入流</span></span><br><span class="line">    FileWriter fWriter=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(f); <span class="comment">// 创建文件字符输出流</span></span><br><span class="line">    <span class="type">int</span> is;</span><br><span class="line">    <span class="keyword">while</span>((is=fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    	fWriter.write(is); <span class="comment">// 将数据写入输出流</span></span><br><span class="line">    &#125;</span><br><span class="line">    fr.close();</span><br><span class="line">    fWriter.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字节流和字符流之间的转换"><a href="#字节流和字符流之间的转换" class="headerlink" title="字节流和字符流之间的转换"></a>字节流和字符流之间的转换</h2><p>字节流与字符流之间的桥梁</p>
<p><code>InputStreamReader</code>可以使用特定字符集将字节转换成Unicode字符</p>
<p><code>OutputStreamWriter</code>从程序中接收Unicode字符，将这些字符使用特定字符集转换为字节并将这些字节写入到一个输出流中。</p>
<h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240618142734474.png" alt="image-20240618142734474"></p>
<h3 id="OutStreamWriter"><a href="#OutStreamWriter" class="headerlink" title="OutStreamWriter"></a>OutStreamWriter</h3><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240618142829216.png" alt="image-20240618142829216"></p>
<h2 id="I-O流"><a href="#I-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h2><ul>
<li><p>Java的I&#x2F;O库提供了一个称做链接的机制，可以将一个流与另一个流首尾相接，形成一个流管道的链接。这种机制实际上是一种被称为Decorator(装饰)设计模式的应用。</p>
</li>
<li><p> 通过流的链接，可以动态地增加流的功能，而这种功能的增加是通过组合一些流的基本功能而动态获取的。</p>
</li>
<li><p> <strong>过滤流（FilterStream）</strong>是对字节或字符数据流提供扩展功能的包装。例如基本输入流提供的读取方法，只能用来读取字节或字符；而过滤流能够读取整数值、双精度值或字符串，但需要一个过滤流类来包装输入流。</p>
</li>
</ul>
<img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240618143205080.png" alt="image-20240618143205080" style="zoom: 33%;" />



<img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240618143240291.png" alt="image-20240618143240291" style="zoom: 33%;" />

<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240618143352421.png" alt="image-20240618143352421"></p>
<p>写入文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.txt&quot;</span>);<span class="comment">//文件输出流</span></span><br><span class="line">            <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);<span class="comment">//缓冲流,提高效率</span></span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(bos);<span class="comment">//数据流,写入基本数据类型</span></span><br><span class="line">            dos.writeDouble(<span class="number">9.8</span>);</span><br><span class="line">            dos.writeInt(<span class="number">100</span>);</span><br><span class="line">            dos.writeUTF(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            dos.close();</span><br><span class="line">            bos.close();</span><br><span class="line">            fos.close();</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">            System.out.println(dis.readDouble());<span class="comment">//写入数据的时候可以把read改成writer</span></span><br><span class="line">            System.out.println(dis.readInt());</span><br><span class="line">            System.out.println(dis.readUTF());</span><br><span class="line">            dis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">copyfile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc= <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;Enter the file name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">        FileInputStream fis=<span class="literal">null</span>;</span><br><span class="line">        InputStreamReader isr=<span class="literal">null</span>;</span><br><span class="line">        BufferedReader reader=<span class="literal">null</span>;</span><br><span class="line">        BufferedWriter writer=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            isr = <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis);</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//把file内容通过BufferedWriter写入file_copy</span></span><br><span class="line">                writer = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(file + <span class="string">&quot;_copy&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">                writer.write(line);</span><br><span class="line">                writer.newLine();</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;File not found&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(reader!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(isr!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    isr.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(fis!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240618143954044.png" alt="image-20240618143954044"></p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240618144010538.png" alt="image-20240618144010538"></p>
<h2 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h2><p>懒得写</p>
<h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h1><p>用来储存对象，长度可变</p>
<h2 id="集合中主要接口"><a href="#集合中主要接口" class="headerlink" title="集合中主要接口"></a><strong>集合中主要接口</strong></h2><h4 id="-Collection与Map的区别"><a href="#-Collection与Map的区别" class="headerlink" title=" Collection与Map的区别"></a> Collection与Map的区别</h4><p>Collection类型：集合中每个元素是一个独立的对象。</p>
<p>Map类型：集合中每个元素都是一对Key&#x2F;Value（键&#x2F;值）对象；同一集合中，每个元素的键都不能与其他元素的键相同。</p>
<h4 id="-List与Set的区别"><a href="#-List与Set的区别" class="headerlink" title=" List与Set的区别"></a> List与Set的区别</h4><p>List： 按照对象的插入顺序排列。 元素可重复，实质是可变长度的数组。</p>
<p>Set：数学意义上的集合，在Set中的对象元素不能重复。</p>
<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a><strong>List</strong>集合</h2><ul>
<li><p>List集合为<strong>列表</strong>类型，以<strong>线性方式</strong>存储对象，可以通过对象的<strong>索引</strong>操作对象。</p>
</li>
<li><p>List是<strong>有序</strong>的collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。</p>
</li>
<li><p>List接口的常用实现类有ArrayList和LinkedList。</p>
<ul>
<li><strong>ArrayList</strong>: 是一种类似数组的形式进行存储，因此它的随机访问速度极快。在插入之后后面的对象索引向后移位，删除向前</li>
<li><strong>LinkedList</strong>:内部实现是链表，它适合于在链表中间需要频繁进行插入和删除操作</li>
</ul>
</li>
</ul>
<h3 id="从arrayList集合中取数据"><a href="#从arrayList集合中取数据" class="headerlink" title="从arrayList集合中取数据"></a>从arrayList集合中取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">String</span>(“a”));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">String</span>(“b”));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size(); i++)</span><br><span class="line">System.out.println(list.get(i));</span><br></pre></td></tr></table></figure>

<h3 id="list实例化"><a href="#list实例化" class="headerlink" title="list实例化"></a>list实例化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">// 利用ArrayList类实例化List集合</span></span><br><span class="line">List&lt;String&gt; l2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;(); <span class="comment">// 利用LinkedList类实例化List集合</span></span><br></pre></td></tr></table></figure>

<h3 id="list常用方法"><a href="#list常用方法" class="headerlink" title="list常用方法"></a>list常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="type">int</span> index, Object obj) <span class="comment">//指定索引位置添加对象</span></span><br><span class="line">set(<span class="type">int</span> index, Object obj)<span class="comment">// 替换指定索引位置的对象</span></span><br><span class="line">indexOf(Object obj) <span class="comment">//获得指定对象的最小的索引位置</span></span><br><span class="line">lastIndexOf(Object obj) <span class="comment">//获得指定对象的最大的索引位置</span></span><br></pre></td></tr></table></figure>

<h3 id="linkedlist常用方法"><a href="#linkedlist常用方法" class="headerlink" title="linkedlist常用方法"></a>linkedlist常用方法</h3><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240604170549220.png" alt="image-20240604170549220"></p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240604171133204.png" alt="image-20240604171133204"></p>
<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a><strong>Set</strong>集合</h2><ul>
<li><p>存放于Set集中的对象不按特定方式排序，只是简单地把对象加入集合中，类似于向口袋里放东西。</p>
</li>
<li><p>在Set集中不能存放重复对象。</p>
</li>
</ul>
<h3 id="HashSet类（散列集）"><a href="#HashSet类（散列集）" class="headerlink" title="HashSet类（散列集）"></a>HashSet类（散列集）</h3><ul>
<li><p>HashSet 实现了Set接口，它的元素不能有重复值出现。在HashSet中没有get()方法，但可以通过iterator()来遍历数据。</p>
</li>
<li><p>散列集为每个放入的对象计算一个整数hashCode(散列码),散列码的计算非常迅速，默认情况下根据对象的内存地址来派生散列码。由HashSet类实现的Set集合按照散列码排序，根据对象的散列码确定对象的存储位置。</p>
</li>
</ul>
<p>如果要在HashSet集合类中存放一些自定义的对象，需要在对象所属的类中重写hashCode()与equals()方法，从而保证插入集合中的对象是惟一的，而且能够合理地分布在集合中，以便于快速定位集合中的对象。</p>
<p>定义的值有什么用吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//自定义一个散列码（必须是整数）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//判断两个对象的成员是否相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a><strong>Map</strong>集合</h2><ul>
<li>Map集合为映射类型，映射中的每个对象都是成对存在的。</li>
<li>映射中存储的每个对象都有一个相应的<strong>键（key）</strong>对象，在检索对象时必须通过相应的键对象来获取<strong>值（value）对象</strong>，类似于在字典中查找单词一样，所以要求<strong>键对象必须是唯一的</strong>。</li>
<li>键对象还决定了存储对象在映射中的存储位置，但并不是键对象本身决定的，需要通过<strong>散列码</strong>进行处理，由此来确定存储对象在映射中的存储位置</li>
<li>Map集合允许以null作为键对象，但是因为键对象不可以重复，所以这样的键对象只能有一个。允许值对象为null，并且没有个数限制。</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240604171508397.png" alt="image-20240604171508397"></p>
<h3 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h3><p>HashMap通过哈希码对其内部的映射关系进行快速查找、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从控制台输入一句英语，统计各单词出现的次数，使用HashMap完成。</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testMap</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		 Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		 <span class="comment">//使用 nextLine()可以读一行</span></span><br><span class="line">		 String read=sc.nextLine();</span><br><span class="line">		 <span class="comment">//把一句单词用“ ”分割为一个字符串数组 </span></span><br><span class="line">		 String str[]=read.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		 <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)</span><br><span class="line">			 System.out.println(str[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		 <span class="comment">//&lt;单词，出现的次数&gt; 键为单词，值为该单词出现次数 </span></span><br><span class="line">         HashMap&lt;String,Integer&gt; hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">        	 <span class="comment">//如果该单词不存在 ，则新增 </span></span><br><span class="line">        	<span class="keyword">if</span>(!hm.containsKey(str[i]))&#123;</span><br><span class="line">        		hm.put(str[i], <span class="number">1</span>);<span class="comment">//自动装箱</span></span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123; <span class="comment">//如果单词存在则使其次数  +1</span></span><br><span class="line">        		<span class="type">int</span> n=hm.get(str[i]);</span><br><span class="line">        		hm.put(str[i], ++n);</span><br><span class="line">        	&#125;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(<span class="string">&quot;统计单词出现的个数，结果如下：&quot;</span>);</span><br><span class="line"> 		<span class="comment">//hello java hdu hel java haha java </span></span><br><span class="line">       <span class="comment">//hello  1</span></span><br><span class="line">       <span class="comment">//java  3</span></span><br><span class="line">       <span class="comment">//hdu  1</span></span><br><span class="line">       <span class="comment">//hel   1</span></span><br><span class="line">       <span class="comment">//haha  1</span></span><br><span class="line">         <span class="comment">//将集合中的所有键对象保存到Set集合中</span></span><br><span class="line">         Set&lt;String&gt; s=hm.keySet();</span><br><span class="line">         <span class="comment">//遍历Set集合的键值</span></span><br><span class="line">         Iterator&lt;String&gt; it=s.iterator();</span><br><span class="line">         <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        	 String a=it.next();</span><br><span class="line">        	 <span class="comment">//使用get函数，根据HashMap的键求值</span></span><br><span class="line">        	 System.out.println(a+<span class="string">&quot;=&quot;</span>+hm.get(a));</span><br><span class="line">         &#125;  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Treemap"><a href="#Treemap" class="headerlink" title="Treemap"></a>Treemap</h3><p>TreeMap中的映射关系存在一定的顺序</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>程序一次执行就是一个进程，一个进程可以有很多线程（程序中可以独立运行的片段）共享内存资源。</p>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p> java.lang.Thread类</p>
<ul>
<li>创建一个Tread类的实例对象，形成一个新的线程</li>
</ul>
<h3 id="方法（static）"><a href="#方法（static）" class="headerlink" title="方法（static）"></a>方法（static）</h3><ul>
<li><p><code>currentThread()</code> 返回正在运行的Thread对象。</p>
</li>
<li><p><code>yield()</code> 停止运行当前线程，将CPU控制权主动移交到下一个可运行线程。</p>
</li>
<li><p><code>sleep(int n)</code> 让当前线程睡眠n毫秒,n毫秒后,线程可以再次运行</p>
</li>
</ul>
<h3 id="Thread类的实例方法（非static方法"><a href="#Thread类的实例方法（非static方法" class="headerlink" title="Thread类的实例方法（非static方法)"></a>Thread类的实例方法（非static方法)</h3><ul>
<li><p><code>start()</code>为本线程建立一个执行环境，然后调用本线程的run()方法。</p>
</li>
<li><p><code>run()</code> 在该方法中编写运行本线程将要执行的代码，也是Runnable接口的唯一方法。当一个线程初始化后，由start() 方法来调用它，一旦run()方法返回，本线程也就终止了。</p>
</li>
<li><p><code>setPriority(int p)</code> 给线程设置优先级1&lt;&#x3D;p&lt;&#x3D;10 </p>
</li>
<li><p><code>getPriority()</code> 返回线程的优先级</p>
</li>
<li><p><code>setName(String name)</code> 赋予线程一个名字name </p>
</li>
<li><p><code>getName()</code> 取得由setName()方法设置的线程名字的字符串</p>
</li>
<li><p><code>wait(long timeout)</code> 停止当前线程，直到另外的线程对这个对象使用</p>
</li>
<li><p><code>notify()</code>或<code>notifyAll()</code> 唤醒指定对象的一个或所有线程</p>
</li>
</ul>
<h2 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">testThread</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">	t.setName(<span class="string">&quot;单线程&quot;</span>); <span class="comment">//对线程取名为“单线程 &quot;</span></span><br><span class="line">	t.setPriority(<span class="number">8</span>); <span class="comment">//设置线程优先级为8，最高为10，最低为1，默认为5</span></span><br><span class="line">	System.out.println(<span class="string">&quot;The running thread: &quot;</span> + t);</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Sleep time &quot;</span> + i);</span><br><span class="line">			Thread.sleep(<span class="number">100</span>); &#125; <span class="comment">// 睡眠100毫秒</span></span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;<span class="comment">// 捕获异常</span></span><br><span class="line">			System.out.println(<span class="string">&quot;thread has wrong&quot;</span>); &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The running thread: Thread[单线程,8,main]</span><br><span class="line">Sleep time 0</span><br><span class="line">Sleep time 1</span><br><span class="line">Sleep time 2</span><br></pre></td></tr></table></figure>

<h2 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>可通过继承Thread类并重写其中的run()方法来定义线程体以实现线程的具体行为，然后创建该子类的对象以创建线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSubclassName</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadSubclassName</span><span class="params">()</span>&#123; ..... 此处编写子类的构造方法，可缺省 &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123; ..... 此处编写自己的线程代码 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadSubclassName</span> <span class="variable">ThreadObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSubclassName</span>();</span><br><span class="line">ThreadObject.start(); <span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>编写多线程程序的另一种的方法是实现Runnable接口。在一个类中实现Runnable接口，并在该类中定义run()方法，然后用带有Runnable参数的Thread类构造方法创建线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123; ..... <span class="comment">// 编写自己的线程代码 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mythread mt=<span class="keyword">new</span> <span class="title class_">Mythread</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Thread</span>(mt); <span class="comment">// 新建线程对象，指向Runnable类的实例，// 使用Runnable类实例为线程提供run()方法</span></span><br><span class="line">t.start(); <span class="comment">// 启动线程</span></span><br></pre></td></tr></table></figure>

<p>不同之处在于实现接口之后，还要创建thread对象</p>
<p>线程执行的时候，输出可能回不一致，下面这个例子结果可能是全是yes也有可能全是no</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123; </span><br><span class="line">    <span class="type">String</span> <span class="variable">myString</span> <span class="operator">=</span> <span class="string">&quot;Yes &quot;</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="built_in">this</span>.myString = <span class="string">&quot;No &quot;</span>; &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123; </span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(); </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(t).start(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">            System.out.print(t.myString); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li>同步代码块作用：多个线程间共享资源操作容易引起冲突，这些容易引起冲突的代码块称之为<strong>临界区</strong>，在临界区通过引入监视器，并用<strong>synchronized</strong>使多个线程在临界区同步起来，从而避免可能引起的冲突。</li>
<li>synchronized可修饰一个代码块或一个方法，使修饰对象在任一时刻只能有一个线程访问。从而提供了程序的异步执行功能。</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>（<span class="built_in">this</span>）&#123;......&#125; <span class="comment">// 修饰一个代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> methodName（parameters）&#123; <span class="comment">// 修饰一个方法</span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://yourwebsite.com">Jaketmoon</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://yourwebsite.com/2024/03/04/java%E5%9F%BA%E7%A1%80/">http://yourwebsite.com/2024/03/04/java%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yourwebsite.com" target="_blank">Jaketmoon の 博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/04/STM32/" title="STM32库函数学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">STM32库函数学习</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/29/51%E5%8D%95%E7%89%87%E6%9C%BA/" title="51单片机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">51单片机</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jaketmoon</div><div class="author-info__description">YOU WANT TO PLAY? LET'S PLAY!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">2.</span> <span class="toc-text">文件目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hello-world"><span class="toc-number">3.</span> <span class="toc-text">hello world</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-number">3.1.</span> <span class="toc-text">代码解释</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">4.</span> <span class="toc-text">命名规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.</span> <span class="toc-text">标识符和关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.</span> <span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">7.</span> <span class="toc-text">输入数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sanner"><span class="toc-number">7.1.</span> <span class="toc-text">Sanner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nextline"><span class="toc-number">7.1.1.</span> <span class="toc-text">nextline</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Read"><span class="toc-number">7.2.</span> <span class="toc-text">Read</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0-object-oriented"><span class="toc-number">8.1.</span> <span class="toc-text">面向对象编程概述(object oriented)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">8.2.</span> <span class="toc-text">特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">8.3.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">8.4.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">8.4.1.</span> <span class="toc-text">重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.5.</span> <span class="toc-text">匿名对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-number">8.6.</span> <span class="toc-text">实现类的封装性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-number">8.7.</span> <span class="toc-text">形参和实参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.8.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%94%A8this%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.8.1.</span> <span class="toc-text">直接用this构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%9C%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.8.2.</span> <span class="toc-text">缺省构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#package"><span class="toc-number">8.9.</span> <span class="toc-text">package</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">8.9.1.</span> <span class="toc-text">作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">8.10.</span> <span class="toc-text">修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">8.10.1.</span> <span class="toc-text">类的修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">8.10.2.</span> <span class="toc-text">属性的修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">8.10.3.</span> <span class="toc-text">方法的修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">8.10.4.</span> <span class="toc-text">访问控制修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">8.10.4.1.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">8.10.4.2.</span> <span class="toc-text">方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8Cjava%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">数组和java常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">9.1.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">9.1.0.1.</span> <span class="toc-text">静态初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">9.1.0.2.</span> <span class="toc-text">动态初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-each-%E8%AF%AD%E5%8F%A5%E9%81%8D%E5%8E%86"><span class="toc-number">9.1.1.</span> <span class="toc-text">for each 语句遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">9.2.</span> <span class="toc-text">多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">9.2.1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">9.2.2.</span> <span class="toc-text">创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">9.3.</span> <span class="toc-text">Arrays类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB-Integer-Double-%E2%80%A6"><span class="toc-number">9.4.</span> <span class="toc-text">包装类(Integer,Double …..)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB"><span class="toc-number">9.5.</span> <span class="toc-text">字符串类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E7%B1%BB"><span class="toc-number">9.5.1.</span> <span class="toc-text">string类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.5.1.1.</span> <span class="toc-text">定义字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E5%8C%96"><span class="toc-number">9.5.1.2.</span> <span class="toc-text">字符数组和字符串的转化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">9.5.1.3.</span> <span class="toc-text">String类常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer%E7%B1%BB"><span class="toc-number">9.6.</span> <span class="toc-text">StringBuffer类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">10.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">10.1.</span> <span class="toc-text">类的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%EF%BC%88override%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">方法的重写（override）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super"><span class="toc-number">10.3.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">10.4.</span> <span class="toc-text">子类对象实例化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81-1"><span class="toc-number">11.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">11.1.</span> <span class="toc-text">方法的重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">11.2.</span> <span class="toc-text">方法的重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%EF%BC%88%E4%B8%8B%EF%BC%89%E8%BD%AC%E5%9E%8B"><span class="toc-number">11.3.</span> <span class="toc-text">向上（下）转型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">11.3.0.0.1.</span> <span class="toc-text">向上转型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.3.0.0.2.</span> <span class="toc-text">对象的类型转换</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%B1%BB"><span class="toc-number">11.4.</span> <span class="toc-text">特殊类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#final"><span class="toc-number">11.4.0.1.</span> <span class="toc-text">final</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">11.4.0.1.1.</span> <span class="toc-text">抽象类和抽象方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">11.4.0.2.</span> <span class="toc-text">成员内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">11.4.0.2.0.1.</span> <span class="toc-text">例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="toc-number">11.4.0.3.</span> <span class="toc-text">匿名类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">11.4.0.4.</span> <span class="toc-text">Object类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">11.5.</span> <span class="toc-text">垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.6.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="toc-number">11.6.1.</span> <span class="toc-text">接口定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.6.2.</span> <span class="toc-text">实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">11.6.3.</span> <span class="toc-text">接口多继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB"><span class="toc-number">12.1.</span> <span class="toc-text">异常分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Error%E7%B1%BB"><span class="toc-number">12.1.1.</span> <span class="toc-text">Error类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exception%E7%B1%BB"><span class="toc-number">12.1.2.</span> <span class="toc-text">Exception类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-1"><span class="toc-number">12.2.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">12.2.1.</span> <span class="toc-text">Java中的异常处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">12.2.2.</span> <span class="toc-text">5个关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throws"><span class="toc-number">12.2.3.</span> <span class="toc-text">throws</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw"><span class="toc-number">12.2.4.</span> <span class="toc-text">throw</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">12.3.</span> <span class="toc-text">自定义异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2"><span class="toc-number">13.</span> <span class="toc-text">图形化界面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AWT"><span class="toc-number">13.1.</span> <span class="toc-text">AWT</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81"><span class="toc-number">14.</span> <span class="toc-text">文件和流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81"><span class="toc-number">14.1.</span> <span class="toc-text">流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-number">14.2.</span> <span class="toc-text">创建文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">14.3.</span> <span class="toc-text">字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inputstream%E7%B1%BB"><span class="toc-number">14.3.1.</span> <span class="toc-text">inputstream类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#outputstream%E7%B1%BB"><span class="toc-number">14.3.2.</span> <span class="toc-text">outputstream类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">14.3.3.</span> <span class="toc-text">使用字节流读文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5FileInputStream"><span class="toc-number">14.3.3.1.</span> <span class="toc-text">从文件输入FileInputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6FileOutputStream"><span class="toc-number">14.3.3.2.</span> <span class="toc-text">写入文件FileOutputStream</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">14.4.</span> <span class="toc-text">字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reader"><span class="toc-number">14.4.1.</span> <span class="toc-text">Reader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Writer"><span class="toc-number">14.4.2.</span> <span class="toc-text">Writer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%BB%E6%96%87%E4%BB%B6FileReader"><span class="toc-number">14.4.3.</span> <span class="toc-text">字符流读文件FileReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E5%86%99%E6%96%87%E4%BB%B6FileWriter"><span class="toc-number">14.4.4.</span> <span class="toc-text">字符流写文件FileWriter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">14.5.</span> <span class="toc-text">字节流和字符流之间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStreamReader"><span class="toc-number">14.5.1.</span> <span class="toc-text">InputStreamReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutStreamWriter"><span class="toc-number">14.5.2.</span> <span class="toc-text">OutStreamWriter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E6%B5%81"><span class="toc-number">14.6.</span> <span class="toc-text">I&#x2F;O流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RandomAccessFile%E7%B1%BB"><span class="toc-number">14.7.</span> <span class="toc-text">RandomAccessFile类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">15.</span> <span class="toc-text">集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%B8%AD%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.1.</span> <span class="toc-text">集合中主要接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%83%98-Collection%E4%B8%8EMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.1.0.1.</span> <span class="toc-text"> Collection与Map的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%83%98-List%E4%B8%8ESet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.1.0.2.</span> <span class="toc-text"> List与Set的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E9%9B%86%E5%90%88"><span class="toc-number">15.2.</span> <span class="toc-text">List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8EarrayList%E9%9B%86%E5%90%88%E4%B8%AD%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">15.2.1.</span> <span class="toc-text">从arrayList集合中取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">15.2.2.</span> <span class="toc-text">list实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">15.2.3.</span> <span class="toc-text">list常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedlist%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">15.2.4.</span> <span class="toc-text">linkedlist常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88"><span class="toc-number">15.3.</span> <span class="toc-text">Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E7%B1%BB%EF%BC%88%E6%95%A3%E5%88%97%E9%9B%86%EF%BC%89"><span class="toc-number">15.3.1.</span> <span class="toc-text">HashSet类（散列集）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-number">15.4.</span> <span class="toc-text">Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">15.4.1.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashmap"><span class="toc-number">15.4.2.</span> <span class="toc-text">Hashmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Treemap"><span class="toc-number">15.4.3.</span> <span class="toc-text">Treemap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">16.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">17.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%E7%B1%BB"><span class="toc-number">17.1.</span> <span class="toc-text">Thread类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%88static%EF%BC%89"><span class="toc-number">17.1.1.</span> <span class="toc-text">方法（static）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%88%E9%9D%9Estatic%E6%96%B9%E6%B3%95"><span class="toc-number">17.1.2.</span> <span class="toc-text">Thread类的实例方法（非static方法)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-number">17.2.</span> <span class="toc-text">使用举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">17.3.</span> <span class="toc-text">多线程的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">17.3.1.</span> <span class="toc-text">继承Thread类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">17.3.2.</span> <span class="toc-text">实现Runnable接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">17.4.</span> <span class="toc-text">线程同步</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/14/grpc-gateway/" title="grpc-gateway">grpc-gateway</a><time datetime="2024-09-14T05:53:09.000Z" title="发表于 2024-09-14 13:53:09">2024-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/09/docker%E9%83%A8%E7%BD%B2go-web%E5%BA%94%E7%94%A8/" title="docker部署go web应用">docker部署go web应用</a><time datetime="2024-09-09T08:45:54.000Z" title="发表于 2024-09-09 16:45:54">2024-09-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/14/mongodb/" title="mongodb">mongodb</a><time datetime="2024-08-14T14:31:09.000Z" title="发表于 2024-08-14 22:31:09">2024-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/08/simple-Chat-Application/" title="simple-Chat-Application">simple-Chat-Application</a><time datetime="2024-08-08T12:37:01.000Z" title="发表于 2024-08-08 20:37:01">2024-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/15/mm32%E5%AD%A6%E4%B9%A0/" title="mm32学习">mm32学习</a><time datetime="2024-07-15T07:28:12.000Z" title="发表于 2024-07-15 15:28:12">2024-07-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Jaketmoon</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.11.0"></script><script src="/js/main.js?v=4.11.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>