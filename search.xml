<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/12/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>CSS介绍</title>
    <url>/2024/04/22/CSS%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>CSS（Cascading Style Sheets）是一种样式表语言，用于描述HTML或XML文档的呈现。它使得开发者能够控制网页的布局、颜色、字体和动画等方面的外观。CSS 提高了内容与表现的分离程度，能够使样式在多个页面中重用，从而减少了代码量并提高了网站的维护性。开发者可以通过类、ID 和其他选择器来应用样式，而且可以利用层叠和继承规则来精细控制规则的应用。随着CSS3和其后续更新的推出，CSS也引入了响应式设计和动画等先进特性，使得创建现代、交互式的网页变得更加容易。</p>
<h1 id="改变颜色以及与html文件连接"><a href="#改变颜色以及与html文件连接" class="headerlink" title="改变颜色以及与html文件连接"></a>改变颜色以及与html文件连接</h1><h2 id="颜色的优先级"><a href="#颜色的优先级" class="headerlink" title="颜色的优先级"></a>颜色的优先级</h2><p>在selector中</p>
<p>inline的写法&gt;id&gt;class&gt;elements的优先级来显示</p>
<h4 id="inline（内联样式）"><a href="#inline（内联样式）" class="headerlink" title="inline（内联样式）"></a>inline（内联样式）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;color: black&quot;</span>&gt;</span>Some great food I tasted<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="id（id选择器）"><a href="#id（id选择器）" class="headerlink" title="id（id选择器）"></a>id（id选择器）</h4><p>HTML:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;heading&quot;</span>&gt;</span>Some great food I tasted<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#heading</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="class（类选择器）"><a href="#class（类选择器）" class="headerlink" title="class（类选择器）"></a>class（类选择器）</h4><p>html:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>Some great food I tasted<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.blue</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="element（元素选择器）"><a href="#element（元素选择器）" class="headerlink" title="element（元素选择器）"></a>element（元素选择器）</h4><p>如果我们想直接在html中改变h1颜色</p>
<p>在head中写这个</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果要分文件使用element来改变颜色</p>
<p>新建一个styles.css文件在同一文件夹下面，我们可以通过这个文件更改html中h1的颜色字体</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: chartreuse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在html的head中加入</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;styles<span class="selector-class">.css</span>&quot;&gt;	</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，如果在两个优先级相同的渲染下，颜色渲染是从上到下的，所以最head下面的颜色的定义是页面颜色的最终定义</strong></p>
<h2 id="调色方式"><a href="#调色方式" class="headerlink" title="调色方式"></a>调色方式</h2><p>在网页设计中，颜色是用来增强用户体验的重要元素之一。选择正确的颜色和调色方式对于设计师来说至关重要。以下是几种常用的调色方式：</p>
<h3 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><p>RGB是一种颜色模式，它基于光的三原色：红色（Red）、绿色（Green）、蓝色（Blue）。每种颜色均通过一个介于0到255的值来表示，其中0代表最低亮度（无光），255代表最高亮度（全亮）。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">/* 红色 */</span></span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>); <span class="comment">/* 绿色 */</span></span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>); <span class="comment">/* 蓝色 */</span></span><br></pre></td></tr></table></figure>

<p>同时需要注意的是，可以在最后加上最后一个元素a表示透明度，取值范围：0~1，0表示完全透明。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>,<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>





<h3 id="十六进制颜色码"><a href="#十六进制颜色码" class="headerlink" title="十六进制颜色码"></a>十六进制颜色码</h3><p>十六进制颜色码是另一种在网页中设置颜色的方法。这种格式以<code>#</code>符号开始，后面跟着六个字符，由0-9的数字和A-F的字母组成。与RGB类似，十六进制颜色码也包含红、绿、蓝三种颜色的值，每种颜色由两个字符表示。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>: <span class="number">#FF0000</span>; <span class="comment">/* 红色 */</span></span><br><span class="line"><span class="attribute">color</span>: <span class="number">#00FF00</span>; <span class="comment">/* 绿色 */</span></span><br><span class="line"><span class="attribute">color</span>: <span class="number">#0000FF</span>; <span class="comment">/* 蓝色 */</span></span><br></pre></td></tr></table></figure>

<p>也可以在加上最后两位来表示透明度，范围为00~FF</p>
<h3 id="颜色关键字"><a href="#颜色关键字" class="headerlink" title="颜色关键字"></a>颜色关键字</h3><p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>: red; <span class="comment">/* 红色 */</span></span><br><span class="line"><span class="attribute">color</span>: green; <span class="comment">/* 绿色 */</span></span><br><span class="line"><span class="attribute">color</span>: blue; <span class="comment">/* 蓝色 */</span></span><br></pre></td></tr></table></figure>

<p>使用颜色关键字是编写CSS时最简单直接的方法，但它提供的颜色选择也是最有限的。</p>
<h3 id="HSLA"><a href="#HSLA" class="headerlink" title="HSLA"></a>HSLA</h3><p>HSLA是HSL颜色模式的扩展，它增加了Alpha透明度通道。Alpha值定义了颜色的透明度，范围从0.0（完全透明）到1.0（完全不透明）。这使得设计师能够设置颜色的不透明度，为元素创建更丰富和更有层次的视觉效果。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>: <span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">100%</span>, <span class="number">50%</span>, <span class="number">1</span>); <span class="comment">/* 不透明的红色 */</span></span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">hsla</span>(<span class="number">120</span>, <span class="number">100%</span>, <span class="number">50%</span>, <span class="number">0.5</span>); <span class="comment">/* 50%透明度的绿色 */</span></span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">hsla</span>(<span class="number">240</span>, <span class="number">100%</span>, <span class="number">50%</span>, <span class="number">0.3</span>); <span class="comment">/* 30%透明度的蓝色 */</span></span><br></pre></td></tr></table></figure>

<p>HSLA颜色定义中的四个参数含义如下：</p>
<ul>
<li><strong>色相（Hue）</strong>: 色相（Hue）代表色轮上的一个点，其中0度是红色，120度是绿色，240度是蓝色.</li>
<li><strong>饱和度（Saturation）</strong>:饱和度（Saturation）表示颜色的强度或纯度，0% 是灰色，100% 是最鲜亮的颜色。</li>
<li><strong>亮度（Lightness）</strong>:亮度（Lightness）表示颜色的明亮程度，0% 是黑色，100% 是白色，而50% 将会是纯色。</li>
<li><strong>Alpha透明度</strong>: 一个介于0.0（完全透明）到1.0（完全不透明）之间的数值。</li>
</ul>
<p>使用HSLA颜色模式，你可以轻松地对颜色的透明度进行精细的控制，它非常适合创建叠加效果、渐变或者当你需要颜色与背景有部分融合时使用。</p>
<p>在实际应用中，这种颜色的表示方法特别有用，例如在CSS中为背景颜色设置透明度，而不影响元素内的文本或其他内容。通过使用HSLA，你可以在设计中创造出更多层次和深度，同时还能保持颜色的一致性。</p>
<h1 id="box"><a href="#box" class="headerlink" title="box"></a>box</h1><p>一个简单但实用的CSS类样式<code>.box</code>，这个样式可用于创建具有特定尺寸、边框和背景颜色的盒子。这种类型的盒子在web开发中极为常见，用于各种目的，比如<strong>突出显示内容、作为布局组件或是创建图像和文字的卡片</strong>。使用的四时候创建在div中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>,<span class="number">0.3</span>);</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们一一解析这些属性及其对页面布局的影响：</p>
<h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p><code>background-color: rgb(0, 0, 255, 0.3);</code> 这一行为<code>.box</code>类指定了背景颜色。我们使用RGBA颜色模式，其中A代表透明度。颜色设置为蓝色（红0，绿0，蓝255），并且透明度设置为0.3，即透明度为30%，这会使得盒子背景部分透明，让页面上的背景部分能够透过来。</p>
<h3 id="内边距和外边距"><a href="#内边距和外边距" class="headerlink" title="内边距和外边距"></a>内边距和外边距</h3><p><code>padding: 10px;</code> 设置了盒子内容与其边框之间的内边距为10像素，为内容提供一定的”呼吸空间”。而<code>margin: 10px;</code> 则定义了盒子与其他页面元素之间的外边距，也是10像素，确保了元素之间有足够的空间，避免了紧挨着。</p>
<h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><p>我们通过<code>height: 100px;</code> 和 <code>width: 100px;</code> 分别设置了盒子的高度和宽度为100像素。这为盒子提供了一个均衡的正方形形状，但同时也是硬编码的，意味着无论内容大小如何，盒子都将保持这个尺寸。</p>
<h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>最后，<code>border: 1px solid black;</code> 为盒子提供了一个1像素宽的黑色实线边框，既定义了元素的外形，也增加了视觉对比度，使其更加突出。</p>
<p>将上述样式应用到任何HTML元素中，您就会获得一个漂亮且功能完备的盒子，可以用来展示内容或作为设计的一部分。盒子的透明背景意味着它可以很好地融合到任何背景上，而内外边距则确保了文本或其他元素不会紧贴到盒子边缘。</p>
<p>在实际应用中，这种盒子可以用作消息提醒、小部件、卡片或任何需要突出显示的区域。通过调整上述属性，您可以轻松定制这些盒子以适应您网页的特定需求和视觉风格。</p>
<p>这就是<code>.box</code>类的魅力所在——简单、直观且极其灵活。无论您是初学者还是有经验的开发人员，这样的基础CSS类都是创建引人入胜、具有响应性设计的重要工具。</p>
<h3 id="使用percent"><a href="#使用percent" class="headerlink" title="使用percent"></a>使用percent</h3><p>百分比通常是相对于包含块（即父元素）的尺寸来计算的。这种方法使得元素在不同屏幕尺寸或设备上具有更好的响应性。下面是一个更新后的<code>.box</code>类，它使用百分比而非像素值：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0.3</span>);</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5%</span>; <span class="comment">/* 假设是相对于盒子自身的宽度 */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2%</span>; <span class="comment">/* 假设是相对于包含块（父元素）的宽度 */</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20%</span>; <span class="comment">/* 假设是相对于包含块（父元素）的高度 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>; <span class="comment">/* 假设是相对于包含块（父元素）的宽度 */</span></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT</title>
    <url>/2024/05/06/JWT/</url>
    <content><![CDATA[<p>如何在gin框架中使用JWT[<a href="https://www.liwenzhou.com/posts/Go/json-web-token/#c-0-0-0">在gin框架中使用JWT | 李文周的博客 (liwenzhou.com)</a>]</p>
<p>JWT全称JSON Web Token是一种跨域认证解决方案，属于一个开放的标准，它规定了一种Token实现方式，目前多用于前后端分离项目和OAuth2.0业务场景下。</p>
<h1 id="为什么需要JWT？"><a href="#为什么需要JWT？" class="headerlink" title="为什么需要JWT？"></a>为什么需要JWT？</h1><p>在之前的一些web项目中，我们通常使用的是<code>Cookie-Session</code>模式实现用户认证。相关流程大致如下：</p>
<ol>
<li>用户在浏览器端填写用户名和密码，并发送给服务端</li>
<li>服务端对用户名和密码校验通过后会生成一份保存当前用户相关信息的session数据和一个与之对应的标识（通常称为session_id）</li>
<li>服务端返回响应时将上一步的session_id写入用户浏览器的Cookie</li>
<li>后续用户来自该浏览器的每次请求都会自动携带包含session_id的Cookie</li>
<li>服务端通过请求中的session_id就能找到之前保存的该用户那份session数据，从而获取该用户的相关信息。</li>
</ol>
<p>这种方案依赖于客户端（浏览器）保存 Cookie，并且需要在服务端存储用户的session数据。</p>
<p>在移动互联网时代，我们的用户可能使用浏览器也可能使用APP来访问我们的服务，我们的web应用可能是前后端分开部署在不同的端口，有时候我们还需要支持第三方登录，这下<code>Cookie-Session</code>的模式就有些力不从心了。</p>
<p>JWT就是一种基于Token的轻量级认证模式，服务端认证通过后，会生成一个JSON对象，经过签名后得到一个Token（令牌）再发回给用户，用户后续请求只需要带上这个Token，服务端解密之后就能获取该用户的相关信息了。</p>
<p>想要了解JWT的原理，推荐大家阅读：<a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">阮一峰的JWT入门教程</a></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;姓名&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;角色&quot;</span>: <span class="string">&quot;管理员&quot;</span>,</span><br><span class="line">  <span class="string">&quot;到期时间&quot;</span>: <span class="string">&quot;2018年7月1日0点0分&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p>
<p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>
<h1 id="JWT-的数据结构"><a href="#JWT-的数据结构" class="headerlink" title="JWT 的数据结构"></a>JWT 的数据结构</h1><p>实际的 JWT 大概就像下面这样。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072304.jpg" alt="img"></p>
<p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p>
<p>JWT 的三个部分依次如下。</p>
<blockquote>
<ul>
<li>Header（头部）</li>
<li>Payload（负载）</li>
<li>Signature（签名）</li>
</ul>
</blockquote>
<p>写成一行，就是下面的样子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Header</span>.<span class="property">Payload</span>.<span class="property">Signature</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg" alt="img"></p>
<p>下面依次介绍这三个部分。</p>
<h3 id="3-1-Header"><a href="#3-1-Header" class="headerlink" title="3.1 Header"></a>3.1 Header</h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p>
<p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p>
<h3 id="3-2-Payload"><a href="#3-2-Payload" class="headerlink" title="3.2 Payload"></a>3.2 Payload</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p>
<blockquote>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
</blockquote>
<p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;admin&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p>
<p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p>
<h3 id="3-3-Signature"><a href="#3-3-Signature" class="headerlink" title="3.3 Signature"></a>3.3 Signature</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p>
<p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">HMACSHA256</span>(</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p>
<h3 id="3-4-Base64URL"><a href="#3-4-Base64URL" class="headerlink" title="3.4 Base64URL"></a>3.4 Base64URL</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p>
<p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com&#x2F;?token&#x3D;xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>​	创建：我们要定义用于签名的字符串，这个字符串应该要被保护好，不能被用户知道，然后编写函数用于创建jwt，里面要定义claims，里面包括payload和RegisteredClaims，最后再和header一起赋值给token，再加上签名输出token。</p>
<p>解析：判断是否携带token，如果没有的话就返回错误。</p>
<h3 id="默认Claim"><a href="#默认Claim" class="headerlink" title="默认Claim"></a>默认Claim</h3><p>如果我们直接使用JWT中默认的字段，没有其他定制化的需求则可以直接使用这个包中的和方法快速生成和解析token。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于签名的字符串</span></span><br><span class="line"><span class="keyword">var</span> mySigningKey = []<span class="type">byte</span>(<span class="string">&quot;liwenzhou.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenRegisteredClaims 使用默认声明创建jwt</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenRegisteredClaims</span><span class="params">()</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 创建 Claims</span></span><br><span class="line">	claims := &amp;jwt.RegisteredClaims&#123;</span><br><span class="line">		ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour * <span class="number">24</span>)), <span class="comment">// 过期时间</span></span><br><span class="line">		Issuer:    <span class="string">&quot;qimi&quot;</span>,                                             <span class="comment">// 签发人</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 生成token对象</span></span><br><span class="line">	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)</span><br><span class="line">	<span class="comment">// 生成签名字符串</span></span><br><span class="line">	<span class="keyword">return</span> token.SignedString(mySigningKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParseRegisteredClaims 解析jwt</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateRegisteredClaims</span><span class="params">(tokenString <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 解析token</span></span><br><span class="line">	token, err := jwt.Parse(tokenString, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> mySigningKey, <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// 解析token失败</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> token.Valid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何在gin框架中使用"><a href="#如何在gin框架中使用" class="headerlink" title="如何在gin框架中使用?"></a>如何在gin框架中使用?</h2><p><a href="https://jaketmoon.github.io/2024/04/24/go-gin%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BAtodolist%E7%BD%91%E9%A1%B5/">go-gin框架搭建todolist网页 | Jaketmoon の 博客</a></p>
<p>可以在这个文章中的JWT部分查看</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>Katana Zero</title>
    <url>/2023/12/30/Katana%20Zero/</url>
    <content><![CDATA[<h1 id="是我最近玩的最爽快的游戏了"><a href="#是我最近玩的最爽快的游戏了" class="headerlink" title="是我最近玩的最爽快的游戏了"></a>是我最近玩的最爽快的游戏了</h1><h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><p>​	虽然里面的剧情，角色能力，背景，曾经的自己有过一点想法，但是这款游戏把他们都具象化了，这种感觉就像是有人突然理解了你，并为融合了你想法为你做了一件艺术品。</p>
<h2 id="游戏性"><a href="#游戏性" class="headerlink" title="游戏性"></a>游戏性</h2><p>​	我觉得无可挑剔，打击感非常好，每次挥刀卡肉感很强，但也不会让你觉得拖沓，配合上Switch的振动简直不要太爽。里面的战斗模式虽然融合了其他很多游戏，但是这种融合起来的感觉让人耳目一新。最爽的莫过于看自己成功过关后看自己的录像，颇有过五关斩六将的感觉。</p>
<h2 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h2><p>​	总体来说是有难度的，除非是天天玩类似于《空洞骑士》《死亡细胞》之类的游戏，否则后面的一关死个十几遍是常有的事。但这也带来了很大的成就感，看着自己的技术一点点长进，甚至之后劈子弹都不用开子弹时间。</p>
<h2 id="画面"><a href="#画面" class="headerlink" title="画面"></a>画面</h2><p>​	非常喜欢，就是那种精致的像素，光影非常有赛博味儿，大红大紫的。杀人飙血，爆炸，会看特效，真的是视听盛宴。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​	突然觉得Switch的掌机老大位置为啥无可替代，之前想入个掌机，第一时间想到的是steamdeck，但是这个元旦放假回家借我妹的switch玩了一会儿，就体现掌机的续航长和重量小的重要性，steamdeck和rog之类的掌机顶多算一个的便携式win电脑。当然，switch的弱点也很明显，比如性能极差无比，而且游戏很贵。但是不会有人还想在掌机上玩3a大作吧？电脑的大屏才适合，更何况我家还有台PS4 pro呢？^_^h。。。。</p>
<p>​	</p>
]]></content>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32库函数学习</title>
    <url>/2024/03/04/STM32/</url>
    <content><![CDATA[<p> 自己学习stm32的一些整理，本人并不是专业的的，写的并不是很规范，可能有点小错误，如果要看的话一定要搭配正点原子的库函数源码来看，最好是直接看不完全手册，本文也是基于这些手册的来整理的，每个人也有每个人的情况</p>
<p>tips：使用stlink的话要打开reset and run<img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240525143425721.png" alt="image-20240525143425721" style="zoom: 50%;" />位于这里</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>STM32是ST公司基于ARMCortex-M内核开发的32位微控制器STM32</strong></p>
<p><strong>常应用在嵌入式领域如智能车、无人机、机器人、无线通信、物联网、工业控制、娱乐电子产品等</strong></p>
<p><strong>STM32功能强大、性能优异片上资源丰富、功耗低，是一款经典的嵌入式微控制器</strong></p>
<h1 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h1><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240319134339167.png" alt="image-20240319134339167"></p>
<p>1.建立工程文件夹，Kei中新建工程，选择型号工程文件夹里建立Start、Library、User等文件夹，复制固件库里面的文件到工程文件夹</p>
<p>2.工程里对应建立Start、Library、User等同名称的分组，然后将文件夹内的文件添加到工程分组里</p>
<p>3.工程选项，C&#x2F;C++，Include Paths内声明所有包含头文件的文件夹</p>
<p>4.工程选项，C&#x2F;C++，Define内定义USE STDPERIPH DRIVER</p>
<p>5.工程选项，Debug，下拉列表选择对应调试器，Settings，FlashDownload里勾选Reset and Run</p>
<h1 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h1><h3 id="1-UART（Universal-Asynchronous-Receiver-Transmitter，通用异步收发传输器）"><a href="#1-UART（Universal-Asynchronous-Receiver-Transmitter，通用异步收发传输器）" class="headerlink" title="1. UART（Universal Asynchronous Receiver&#x2F;Transmitter，通用异步收发传输器）"></a>1. UART（Universal Asynchronous Receiver&#x2F;Transmitter，通用异步收发传输器）</h3><ul>
<li><strong>类型</strong>：异步串行通信</li>
<li><strong>特点</strong>：UART 通信只需要两根线（发送TX和接收RX），用于两个设备之间的双向串行通信。它不要求发送方和接收方的时钟同步，因为它在每个字节的开始发送一个起始位，结束时发送一个或多个停止位来标示数据的开始和结束。</li>
<li><strong>应用</strong>：广泛用于串口通信，如与PC通信、串口调试等。</li>
</ul>
<h3 id="2-I2C（Inter-Integrated-Circuit，集成电路总线）"><a href="#2-I2C（Inter-Integrated-Circuit，集成电路总线）" class="headerlink" title="2. I2C（Inter-Integrated Circuit，集成电路总线）"></a>2. I2C（Inter-Integrated Circuit，集成电路总线）</h3><ul>
<li><strong>类型</strong>：同步串行通信</li>
<li><strong>特点</strong>：I2C 使用两根线（串行数据线SDA和串行时钟线SCL）进行通信，支持多主机和多从机。一个主机可以与多个从机通信，每个从机有唯一的地址。I2C速度一般，但连接设备多时非常高效。</li>
<li><strong>应用</strong>：常用于连接低速外围设备，如传感器、EEPROM等。</li>
</ul>
<h3 id="3-SPI（Serial-Peripheral-Interface，串行外围设备接口）"><a href="#3-SPI（Serial-Peripheral-Interface，串行外围设备接口）" class="headerlink" title="3. SPI（Serial Peripheral Interface，串行外围设备接口）"></a>3. SPI（Serial Peripheral Interface，串行外围设备接口）</h3><ul>
<li><strong>类型</strong>：同步串行通信</li>
<li><strong>特点</strong>：SPI 至少需要四根线（串行时钟SCLK、主出从入MOSI、主入从出MISO、从设备选择SS）。它支持一个主设备与一个或多个从设备的全双工通信，传输速度比I2C快。</li>
<li><strong>应用</strong>：常用于需要高速通信的设备，如SD卡、LCD显示屏等。</li>
</ul>
<h3 id="其他协议："><a href="#其他协议：" class="headerlink" title="其他协议："></a>其他协议：</h3><ul>
<li><strong>CAN（Controller Area Network）</strong>：一种用于汽车和工业控制中的多主机串行总线标准，特别适用于复杂的电子系统中的通信。</li>
<li><strong>USB（Universal Serial Bus）</strong>：广泛用于计算机和其他设备之间的连接和通信，支持热插拔和即插即用。</li>
<li><strong>Ethernet</strong>：用于局域网（LAN）的通信标准，提供高速的网络连接。</li>
<li><strong>1-Wire</strong>：一种仅使用一根数据线（加上地线）进行通信的协议，适用于低速数据通信，特别是在连接空间受限制时。</li>
</ul>
<h1 id="系统时钟"><a href="#系统时钟" class="headerlink" title="系统时钟"></a>系统时钟</h1><h2 id="五个时钟源"><a href="#五个时钟源" class="headerlink" title="五个时钟源"></a>五个时钟源</h2><p>①、HSI 是高速内部时钟，RC 振荡器，频率为 8MHz。</p>
<p>②、HSE 是高速外部时钟，可接石英&#x2F;陶瓷谐振器，或者接外部时钟源，频率范围为 4MHz~16MHz。</p>
<p>我们的开发板接的是 8M 的晶振。</p>
<p>③、LSI 是低速内部时钟，RC 振荡器，频率为 40kHz。独立看门狗的时钟源只能是 LSI，同</p>
<p>时 LSI 还可以作为 RTC 的时钟源。</p>
<p>④、LSE 是低速外部时钟，接频率为 32.768kHz 的石英晶体。这个主要是 RTC 的时钟源。</p>
<p>⑤、PLL 为锁相环倍频输出，其时钟输入源可选择为 HSI&#x2F;2、HSE 或者 HSE&#x2F;2。倍频可选择为2~16 倍，但是其输出频率最大不得超过 72MHz。</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240320232853894.png" alt="image-20240320232853894"></p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h5 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h5><blockquote>
<p>MCO 是 STM32 的一个时钟输出 IO(PA8)，它可以选择一个时钟信号输出，可以选择为 PLL 输出的 2 分频、HSI、HSE、或者系统时钟。这个时钟可以用来给外部其他系统提供时钟源。</p>
</blockquote>
<h5 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h5><blockquote>
<p>这里是 RTC 时钟源，从图上可以看出，RTC 的时钟源可以选择 LSI，LSE，以及HSE 的 128 分频。</p>
</blockquote>
<h5 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h5><blockquote>
<p>从图中可以看出 C 处 USB 的时钟是来自 PLL 时钟源。STM32 中有一个全速功能的 USB 模块，其串行接口引擎需要一个频率为 48MHz 的时钟源。该时钟源只能从 PLL 输出端获取，可以选择为 1.5 分频或者 1 分频，也就是，当需要使用 USB模块时，PLL 必须使能，并且时钟频率配置为 48MHz 或 72MHz。</p>
</blockquote>
<h5 id="D"><a href="#D" class="headerlink" title="D."></a>D.</h5><blockquote>
<p>D 处就是 STM32 的系统时钟 SYSCLK，它是供 STM32 中绝大部分部件工作的时钟源。系统时钟可选择为 PLL 输出、HSI 或者 HSE。系统时钟最大频率为 72MHz，当然你也可以超频，不过一般情况为了系统稳定性是没有必要冒风险去超频的。</p>
</blockquote>
<h5 id="E"><a href="#E" class="headerlink" title="E."></a>E.</h5><blockquote>
<p>这里的 E 处是指其他所有外设了。从时钟图上可以看出，其他所有外设的时钟最终来源都是 SYSCLK。SYSCLK 通过 AHB 分频器分频后送给各模块使用。这些模块包括：</p>
</blockquote>
<p><strong>①、AHB 总线、内核、内存和 DMA 使用的 HCLK 时钟。</strong></p>
<p><strong>②、通过 8 分频后送给 Cortex 的系统定时器时钟，也就是 systick 了。</strong></p>
<p><strong>③、直接送给 Cortex 的空闲运行时钟 FCLK。</strong></p>
<p><strong>④、送给 APB1 分频器。APB1 分频器输出一路供 APB1 外设使用(PCLK1，最大</strong></p>
<p><strong>频率 36MHz)，另一路送给定时器(Timer)2、3、4 倍频器使用。</strong></p>
<p><strong>⑤、送给 APB2 分频器。APB2 分频器分频输出一路供 APB2 外设使用(PCLK2，</strong></p>
<p><strong>最大频率 72MHz)，另一路送给定时器(Timer)1 倍频器使用。</strong></p>
<h1 id="初始化GPIO"><a href="#初始化GPIO" class="headerlink" title="初始化GPIO"></a>初始化GPIO</h1><p>我们可以通过MDK的固件库来开发，首先在头文件 stm32f10x_gpio.h</p>
<p>定义 GPIO 初始化函数为：</p>
<p><code>void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);</code></p>
<p>我们先处理 GPIO_InitTypeDef，右键选择“Go to definition…”，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> GPIO_Pin;             <span class="comment">/*!&lt; Specifies the GPIO pins to be configured.</span></span><br><span class="line"><span class="comment">                                      This parameter can be any value of @ref GPIO_pins_define */</span></span><br><span class="line"></span><br><span class="line">  GPIOSpeed_TypeDef GPIO_Speed;  <span class="comment">/*!&lt; Specifies the speed for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */</span></span><br><span class="line"></span><br><span class="line">  GPIOMode_TypeDef GPIO_Mode;    <span class="comment">/*!&lt; Specifies the operating mode for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOMode_TypeDef */</span></span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们要先定义结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br></pre></td></tr></table></figure>

<p>然后要初始化各个成员变量，但是不知道要具体怎么设置值。</p>
<p>我们直接再c文件里面定位GPIO_Init.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span><br><span class="line">&#123;</span><br><span class="line">……</span><br><span class="line"> <span class="comment">/* Check the parameters */</span></span><br><span class="line"> assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line"> assert_param(IS_GPIO_MODE(GPIO_InitStruct-&gt;GPIO_Mode));</span><br><span class="line"> assert_param(IS_GPIO_PIN(GPIO_InitStruct-&gt;GPIO_Pin)); </span><br><span class="line">……</span><br><span class="line"> assert_param(IS_GPIO_SPEED(GPIO_InitStruct-&gt;GPIO_Speed));</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顾名思义，assert_param 函数式对入口参数的有效性进行判断，所以我们可以从这个函数入手，确定我们的入口参数的范围。第一行是对第一个参数 GPIOx 进行有效性判断，双击“IS_GPIO_ALL_PERIPH”右键点击“go to defition of…” 定位到了下面的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \</span></span><br><span class="line"><span class="meta"> ((PERIPH) == GPIOB) || \</span></span><br><span class="line"><span class="meta"> ((PERIPH) == GPIOC) || \</span></span><br><span class="line"><span class="meta"> ((PERIPH) == GPIOD) || \</span></span><br><span class="line"><span class="meta"> ((PERIPH) == GPIOE) || \</span></span><br><span class="line"><span class="meta"> ((PERIPH) == GPIOF) || \</span></span><br><span class="line"><span class="meta"> ((PERIPH) == GPIOG))</span></span><br></pre></td></tr></table></figure>

<p>很明显可以看出，GPIOx 的取值规定只允许是 GPIOA~GPIOG。</p>
<p>同样的办法，我们双击“IS_GPIO_MODE” </p>
<p>右键点击“go to defition of…”,定位到下面的定义:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> GPIO_Mode_AIN = <span class="number">0x0</span>,</span><br><span class="line">  GPIO_Mode_IN_FLOATING = <span class="number">0x04</span>,</span><br><span class="line">  GPIO_Mode_IPD = <span class="number">0x28</span>,</span><br><span class="line">  GPIO_Mode_IPU = <span class="number">0x48</span>,</span><br><span class="line">  GPIO_Mode_Out_OD = <span class="number">0x14</span>,</span><br><span class="line">  GPIO_Mode_Out_PP = <span class="number">0x10</span>,</span><br><span class="line">  GPIO_Mode_AF_OD = <span class="number">0x1C</span>,</span><br><span class="line">  GPIO_Mode_AF_PP = <span class="number">0x18</span></span><br><span class="line">&#125;GPIOMode_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_AIN) || ((MODE) == GPIO_Mode_IN_FLOATING) || \</span></span><br><span class="line"><span class="meta">                            ((MODE) == GPIO_Mode_IPD) || ((MODE) == GPIO_Mode_IPU) || \</span></span><br><span class="line"><span class="meta">                            ((MODE) == GPIO_Mode_Out_OD) || ((MODE) == GPIO_Mode_Out_PP) || \</span></span><br><span class="line"><span class="meta">                            ((MODE) == GPIO_Mode_AF_OD) || ((MODE) == GPIO_Mode_AF_PP))</span></span><br></pre></td></tr></table></figure>

<p>取值范围就是下面的define，其他的参数也是同样的道理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; <span class="comment">//</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure>

<h5 id="如何初始化多个IO口："><a href="#如何初始化多个IO口：" class="headerlink" title="如何初始化多个IO口："></a>如何初始化多个IO口：</h5><p>这里又有一个小技巧了。从上面的 GPIO_Pin_x 的宏定义我们可以看出，这些值是 0,1,2,4这样的数字，所以每个 IO 口选定都是对着一个位，16 位的数据一共对应 16 个 IO 口。这个位为 0 那么这个对应的 IO 口不选定，这个位为 1 对应的 IO 口选定。如果多个 IO 口，他们都是对应同一个 GPIOx，那么我们可以通过|（或）的方式同时初始化多个 IO 口。这样操作的前提是，他们的 Mode 和 Speed 参数相同，因为 Mode 和 Speed 参数并不能一次定义多种。所以初始化多个 IO 口的方式可以是如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5| GPIO_Pin_6| GPIO_Pin_7; <span class="comment">//指定端口</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//端口模式：推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; <span class="comment">//速度</span></span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure); <span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>

<h1 id="system文件夹介绍"><a href="#system文件夹介绍" class="headerlink" title="system文件夹介绍"></a>system文件夹介绍</h1><blockquote>
<p>SYSTEM 文件夹下包含了 delay、sys、usart 等三个文件夹。分别包含了 delay.c、sys.c、usart.c 及其头文件 delay.h,sys.h,usart.h。</p>
</blockquote>
<h2 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_osschedlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_osschedunlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ostimedly</span><span class="params">(u32 ticks)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 nms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(u32 nus)</span>;</span><br></pre></td></tr></table></figure>

<p>前面 4 个函数，仅在支持操作系统（OS）的时候，需要用到，而后面三个函数，则不论是否支持 OS 都需要用到。</p>
<h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><p>sys 文件夹内包含了 sys.c 和 sys.h 两个文件。在 sys.h 里面定义了 STM32 的 IO 口输入读取宏定义和输出宏定义。sys.c 里面只定义了一个中断分组函数。</p>
<h2 id="usart"><a href="#usart" class="headerlink" title="usart"></a>usart</h2><p>usart 文件夹内包含了 usart.c 和 usart.h 两个文件。这两个文件用于串口的初始化和中断接收。</p>
<h1 id="跑马灯实验"><a href="#跑马灯实验" class="headerlink" title="跑马灯实验"></a>跑马灯实验</h1><p>首先，找到之前 的 Template 工程，在该文件夹下面新建一个HARDWARE 的文件夹，用来存储以后与硬件相关的代码，然后在HARDWARE 文件夹下新建一个 LED 文件夹，用来存放与 LED 相关的代码。</p>
<p>然后我们打开 USER 文件夹下的 LED.uvprojx 工程(如果是使用的上面新建的工程模板，那么就是 Template. uvprojx，大家可以将其重命名为LED. uvprojx)，右键target1目录下新建一个group HANDWARE,添加新文件led.c，然后保存在 HARDWARE-&gt;LED 文件夹下面。</p>
<img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240509193416858.png" alt="image-20240509193416858"  />

<p><strong>要注意的是，添加新文件到里面的时候，要添加路径</strong></p>
<p>然后在这里要检查自己添加的files有没有出现在右边。</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240509193630866.png" alt="image-20240509193630866"></p>
<blockquote>
<p>目的：理解IO口的输出</p>
</blockquote>
<p>组 HARDWARE 下面存放的是每个实验的外设驱动代码，他的实现是通过调用 FWLib组 HARDWARE 下面存放的是每个实验的外设驱动代码，他的实现是通过调用 FWLib下面的固件库文件实现的，比如 led.c 里面调用 stm32f10x_gpio.c 里面的函数对 led 进行初始化，这里面的函数是讲解的重点。后面的实验中可以看到会引入多个源文件。</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240321144018150.png" alt="image-20240321144018150"></p>
<p>从层次图中可以看出，我们的用户代码和 HARDWARE 下面的外设驱动代码再不需要直接操作寄存器，而是直接或间接操作官方提供的固件库函数。</p>
<h2 id="MODE"><a href="#MODE" class="headerlink" title="MODE"></a>MODE</h2><p><strong>STM32 的 IO 口相比 51 而言要复杂得多，所以使用起来也困难很多。首先 STM32 的 IO 口可以由软件配置成如下 8 种模式：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span> </span><br><span class="line">GPIO_Mode_AIN = <span class="number">0x0</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟输入</span></span><br><span class="line"></span><br><span class="line"> GPIO_Mode_IN_FLOATING = <span class="number">0x04</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//浮空输入</span></span><br><span class="line"></span><br><span class="line"> GPIO_Mode_IPD = <span class="number">0x28</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//下拉输入</span></span><br><span class="line"></span><br><span class="line"> GPIO_Mode_IPU = <span class="number">0x48</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//上拉输入</span></span><br><span class="line"></span><br><span class="line"> GPIO_Mode_Out_OD = <span class="number">0x14</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//开漏输出</span></span><br><span class="line"></span><br><span class="line"> GPIO_Mode_Out_PP = <span class="number">0x10</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//通用推挽输出</span></span><br><span class="line"></span><br><span class="line"> GPIO_Mode_AF_OD = <span class="number">0x1C</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//复用开漏输出</span></span><br><span class="line"></span><br><span class="line"> GPIO_Mode_AF_PP = <span class="number">0x18</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//复用推挽</span></span><br><span class="line"></span><br><span class="line">&#125;GPIOMode_TypeDef;</span><br></pre></td></tr></table></figure>





<h2 id="LED-c"><a href="#LED-c" class="headerlink" title="LED.c"></a>LED.c</h2><p>在这个文件中，我们先进行GPIO的初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"> 	</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOD, ENABLE);	 <span class="comment">//使能了GPIOA和GPIOD两个GPIO端口的时钟。</span></span><br><span class="line">	</span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;				 <span class="comment">//	初始化哪个IO口/LED0--&gt;PB.5 端口配置</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 <span class="comment">//对应IO口的输入模式为推免输出</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		 <span class="comment">//速度50MM</span></span><br><span class="line"> GPIO_Init(GPIOA, &amp;GPIO_InitStructure);					 <span class="comment">//根据设定参数配置 GPIO</span></span><br></pre></td></tr></table></figure>

<p>然后就可以对PIN8进行操作</p>
<p><code>GPIO_SetBits(GPIOA,GPIO_Pin_8)</code>将pin8电平设置为高</p>
<p>现在Pin8电平设置为1，初始化成功</p>
<p>然后再初始化PIN2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;	    	</span><br><span class="line">GPIO_Init(GPIOD, &amp;GPIO_InitStructure);	  		</span><br><span class="line">GPIO_SetBits(GPIOD,GPIO_Pin_2); 				</span><br></pre></td></tr></table></figure>

<p><strong>因为之前的InitStructure里面初始化过了其他内容，因此不必多设置</strong></p>
<p>至此，LED.c的文件已经设置完成</p>
<p>LED.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="comment">//LED 端口定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0 PAout(8) <span class="comment">// PA8</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1 PDout(2) <span class="comment">// PD2</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//初始化 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>这段代码里面最关键就是 2 个宏定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED0 PAout(8) <span class="comment">// PA8</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1 PDout(2) <span class="comment">// PD2</span></span></span><br></pre></td></tr></table></figure>

<p>LED0&#x3D;1; &#x2F;&#x2F;通过位带操作控制 LED0 的引脚 PA8 输出高电平</p>
<p>LED0&#x3D;0; &#x2F;&#x2F;通过位带操作控制 LED0 的引脚 PA8 输出低电平</p>
<p>但是我们主函数中还是使用库函数来操作灯的亮灭</p>
<p>接下来我们将 led.h 也保存一下。接着，我们在 Manage Project Items 管理里面新建一个HARDWARE 的组，并把 led.c 加入到这个组里面</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240322131904714.png" alt="image-20240322131904714"></p>
<p>然后在c&#x2F;c++里面再把h文件路径添加到工程中</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240322132014736.png" alt="image-20240322132014736"></p>
<p>最后在main函数中实现跑马灯效果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;	</span><br><span class="line">	delay_init();	     </span><br><span class="line">	LED_Init();		  	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_ResetBits(GPIOA,GPIO_Pin_8); </span><br><span class="line">		GPIO_SetBits(GPIOD,GPIO_Pin_2);</span><br><span class="line">		delay_ms(<span class="number">1000</span>);</span><br><span class="line">		GPIO_SetBits(GPIOA,GPIO_Pin_8);</span><br><span class="line">		GPIO_ResetBits(GPIOD,GPIO_Pin_2);</span><br><span class="line">		delay_ms(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="按键输入实验"><a href="#按键输入实验" class="headerlink" title="按键输入实验"></a>按键输入实验</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><strong>这一节，我们将通过 MiniSTM32 开发板上载有的 3 个按钮（KEY0&#x2F;KEY1&#x2F;WK_UP），来控制板上的 2 个 LED，其中 KEY0 控制 DS0，按一次亮，再按一次，就灭。KEY1 控制 DS1，效果同 KEY0。WK_UP 按键则同时控制 DS0 和 DS1，按一次，他们的状态就翻转一次。</strong></p>
<h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><p>其实就只有两个函数：KEY_Init()和KEY_Scan(u8 mode)，使用的时候只需使用先Init之后再通过Scan来读取键值。</p>
<p>可以再main.c来看：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;	</span><br><span class="line">	u8 t=<span class="number">0</span>;	  </span><br><span class="line">	delay_init();	    	  </span><br><span class="line">	LED_Init();		  	 	</span><br><span class="line">	KEY_Init();          	</span><br><span class="line">	LED0=<span class="number">0</span>;					</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		t=KEY_Scan(<span class="number">0</span>);		<span class="comment">//得到键值</span></span><br><span class="line">		<span class="keyword">switch</span>(t)</span><br><span class="line">		&#123;				 </span><br><span class="line">			<span class="keyword">case</span> KEY0_PRES:</span><br><span class="line">				LED0=!LED0;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY1_PRES:</span><br><span class="line">				LED1=!LED1;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> WKUP_PRES:				</span><br><span class="line">				LED0=!LED0;</span><br><span class="line">				LED1=!LED1;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				delay_ms(<span class="number">10</span>);	</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;		 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以通过按键来控制LED的亮灭了。</p>
<h1 id="串口实验"><a href="#串口实验" class="headerlink" title="串口实验"></a>串口实验</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p><strong>本章，我们将实现利用串口 1 不停的打印信息到电脑上，同时接收从串口发过来的数据，把发送过来的数据直接送回给电脑。miniSTM32 开发板板载了 1 个 USB 串口和 1 个 RS232 串口，我们本章介绍的是通过 USB 串口和电脑通信。</strong></p>
<h2 id="软件设计-1"><a href="#软件设计-1" class="headerlink" title="软件设计"></a>软件设计</h2><p>因为有关串口的函数已经再System的usart.c的文件下面了，所以我们直接看如何再main.c上使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 t;</span><br><span class="line">    u8 len;</span><br><span class="line">    u16 times=<span class="number">0</span>; </span><br><span class="line">    delay_init(); <span class="comment">//延时函数初始化</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); <span class="comment">//设置中断分组 </span></span><br><span class="line">    uart_init(<span class="number">9600</span>); <span class="comment">//串口初始化为 9600</span></span><br><span class="line">    LED_Init(); <span class="comment">//初始化与 LED 连接的硬件接口</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x8000</span>)</span><br><span class="line">    &#123; </span><br><span class="line">    len=USART_RX_STA&amp;<span class="number">0x3fff</span>;<span class="comment">//得到此次接收到的数据长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n 您发送的消息为:\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)&#123;</span><br><span class="line">    	USART1-&gt;DR=USART_RX_BUF[t];<span class="comment">//想串口1发送数据</span></span><br><span class="line">    	<span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//等待发送结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n\r\n&quot;</span>);<span class="comment">//插入换行</span></span><br><span class="line">    USART_RX_STA=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        times++;</span><br><span class="line">        <span class="keyword">if</span>(times%<span class="number">5000</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r\nALIENTEK MiniSTM32 开发板 串口实验\r\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正点原子@ALIENTEK\r\n\r\n\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times%<span class="number">200</span>==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;请输入数据,以回车键结束\r\n&quot;</span>); </span><br><span class="line">        <span class="keyword">if</span>(times%<span class="number">30</span>==<span class="number">0</span>)LED0=!LED0;<span class="comment">//闪烁 LED,提示系统正在运行.</span></span><br><span class="line">        delay_ms(<span class="number">10</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动XCOM，选择开放板的串口。</p>
<h1 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h1><p>STM32 的定时器功能十分强大，有 TIME1 和 TIME8 等高级定时器，也有 TIME2~TIME5 等通用定时器，还有 TIME6 和TIME7 等基本定时器。</p>
<p>我们将使用 TIM3 的定时器中断来控制 DS1 的翻转，在主函数用 DS0 的翻转来提示程序正在运行。</p>
<h2 id="STM32通用定时器简介"><a href="#STM32通用定时器简介" class="headerlink" title="STM32通用定时器简介"></a>STM32通用定时器简介</h2><p>其实和51单片机的差不多，都是测量输入信号的脉冲长度，或者产生输出波形，STM32的每个通用定时器都是相互独立的。为了加快速度，我们就不了解寄存器的作用了。直接看如何使用定时器中断。</p>
<h3 id="1-TIM3时钟使能"><a href="#1-TIM3时钟使能" class="headerlink" title="1.TIM3时钟使能"></a>1.TIM3时钟使能</h3><p><strong>TIM3 是挂载在 APB1 之下，所以我们通过 APB1 总线下的时钟使能函数来使能 TIM3。调用的函数是：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); <span class="comment">//时钟使能</span></span><br></pre></td></tr></table></figure>



<h3 id="2-初始化定时器参数-设置自动重装值，分频系数，计数方式等。"><a href="#2-初始化定时器参数-设置自动重装值，分频系数，计数方式等。" class="headerlink" title="2.初始化定时器参数,设置自动重装值，分频系数，计数方式等。"></a>2.初始化定时器参数,设置自动重装值，分频系数，计数方式等。</h3><p><strong>在库函数中，定时器的初始化参数是通过初始化函数TIM_TimeBaseInit 实现的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">voidTIM_TimeBaseInit(TIM_TypeDef*TIMx,TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);</span><br></pre></td></tr></table></figure>

<p>第一个参数是确定是哪个定时器，这个比较容易理解。第二个参数是定时器初始化参数结构体指针，结构体类型TIM_TimeBaseInitTypeDef，下面我们看看这个结构体的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">uint16_t</span> TIM_Prescaler; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_CounterMode; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_Period; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_ClockDivision; </span><br><span class="line"> <span class="type">uint8_t</span> TIM_RepetitionCounter; </span><br><span class="line">&#125; TIM_TimeBaseInitTypeDef;</span><br></pre></td></tr></table></figure>

<p>这个结构体一共有 5 个成员变量，要说明的是，对于通用定时器只有前面四个参数有用，最后一个参数 TIM_RepetitionCounter 是高级定时器才有用的，这里不多解释。</p>
<blockquote>
<p>第一个参数 TIM_Prescaler 是用来设置分频系数的</p>
</blockquote>
<blockquote>
<p>第二个参数 TIM_CounterMode 是用来设置计数方式。比较常用的是向上计数模式 TIM_CounterMode_Up 和向下计数模式 TIM_CounterMode_Down。</p>
</blockquote>
<blockquote>
<p>第三个参数是设置自动重载计数周期值</p>
</blockquote>
<blockquote>
<p>第四个参数是用来设置时钟分频因子</p>
</blockquote>
<p><strong>针对 TIM3 初始化范例代码格式：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;</span><br><span class="line">TIM_TimeBaseStructure.TIM_Period = <span class="number">5000</span>;</span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =<span class="number">7199</span>; </span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; </span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure);</span><br></pre></td></tr></table></figure>

<h3 id="3-设置-TIM3-DIER-允许更新中断"><a href="#3-设置-TIM3-DIER-允许更新中断" class="headerlink" title="3.设置 TIM3_DIER 允许更新中断"></a>3.<strong>设置</strong> <strong>TIM3_DIER</strong> 允许更新中断</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT, FunctionalState NewState)</span>；</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个参数是选择定时器号，这个容易理解，取值为 TIM1~TIM17。</p>
</blockquote>
<blockquote>
<p>第二个参数非常关键，是用来指明我们使能的定时器中断的类型，定时器中断的类型有很多种，包括更新中断 TIM_IT_Update，触发中断 TIM_IT_Trigger，以及输入捕获中断等等。</p>
</blockquote>
<blockquote>
<p>第三个参数就很简单了，就是失能还是使能。</p>
</blockquote>
<h3 id="4-TIM3-中断优先级设置。"><a href="#4-TIM3-中断优先级设置。" class="headerlink" title="4.TIM3 中断优先级设置。"></a>4.<strong>TIM3</strong> <strong>中断优先级设置。</strong></h3><p>在定时器中断使能之后，因为要产生中断，必不可少的要设置 NVIC 相关寄存器，设置中断优先级。这段比较复杂，省略。</p>
<h3 id="5-允许-TIM3-工作，也就是使能-TIM3。"><a href="#5-允许-TIM3-工作，也就是使能-TIM3。" class="headerlink" title="5.允许 TIM3 工作，也就是使能 TIM3。"></a>5.<strong>允许</strong> <strong>TIM3</strong> <strong>工作，也就是使能</strong> <strong>TIM3</strong>。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_Cmd(TIM3, ENABLE); <span class="comment">//使能 TIMx 外设</span></span><br></pre></td></tr></table></figure>

<h3 id="6-编写中断服务函数。"><a href="#6-编写中断服务函数。" class="headerlink" title="6.编写中断服务函数。"></a>6.<strong>编写中断服务函数。</strong></h3><p>在最后，还是要编写定时器中断服务函数，通过该函数来处理定时器产生的相关中断。在中断产生后，通过状态寄存器的值来判断此次产生的中断属于什么类型。然后执行相关的操作，我们这里使用的是更新（溢出）中断，所以在状态寄存器 SR 的最低位。在处理完中断之后应该向 TIM3_SR 的最低位写 0，来清除该中断标志。</p>
<p><strong>在固件库函数里面，用来读取中断状态寄存器的值判断中断类型的函数是:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ITStatus <span class="title function_">TIM_GetITStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span>)</span></span><br></pre></td></tr></table></figure>

<p><strong>该函数的作用是，判断定时器 TIMx 的中断类型 TIM_IT 是否发生中断。比如，我们要判断定时器 3 是否发生更新（溢出）中断，方法为：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>固件库中清除中断标志位的函数是：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearITPendingBit</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT)</span></span><br></pre></td></tr></table></figure>

<p>该函数的作用是，清除定时器 TIMx 的中断 TIM_IT 标志位。使用起来非常简单，<strong>比如我们在TIM3 的溢出中断发生后，我们要清除中断标志位，方法是：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_ClearITPendingBit(TIM3, TIM_IT_Update );</span><br></pre></td></tr></table></figure>

<h2 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a><strong>硬件设计</strong></h2><p>本实验用到的硬件资源有：</p>
<blockquote>
<p>1） 指示灯 DS0 和 DS1</p>
</blockquote>
<blockquote>
<p>2） 定时器 TIM3</p>
</blockquote>
<p>本章将通过 TIM3 的中断来控制 DS1 的亮灭，DS0 和 DS1 的电路在前面的跑马灯实验上已经使用过了，我们就直接用之前的led文件。而TIM3 属于 STM32 的内部资源，只需要软件设置即可正常工作。</p>
<h2 id="软件设计-2"><a href="#软件设计-2" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="timer-c"><a href="#timer-c" class="headerlink" title="timer.c"></a>timer.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="comment">//通用定时器 3 中断初始化</span></span><br><span class="line"><span class="comment">//这里时钟选择为 APB1 的 2 倍，而 APB1 为 36M</span></span><br><span class="line"><span class="comment">//arr：自动重装值。</span></span><br><span class="line"><span class="comment">//psc：时钟预分频数</span></span><br><span class="line"><span class="comment">//这里使用的是定时器 3!</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM3_Int_Init</span><span class="params">(u16 arr,u16 psc)</span></span><br><span class="line">&#123;</span><br><span class="line">    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//定义结构体</span></span><br><span class="line"></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); <span class="comment">//时钟TIM3使能</span></span><br><span class="line"></span><br><span class="line">	TIM_TimeBaseStructure.TIM_Period = arr; <span class="comment">//设置自动重装载寄存器周期的值</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_Prescaler =psc; <span class="comment">//设置时钟频率除数的预分频值  </span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>; <span class="comment">///设置时钟分割</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  <span class="comment">//TIM 向上计数</span></span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); <span class="comment">//②初始化 TIM3</span></span><br><span class="line"> </span><br><span class="line">	TIM_ITConfig(TIM3, TIM_IT_Update,ENABLE);<span class="comment">//③允许TIM3更新中断</span></span><br><span class="line">    </span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;  <span class="comment">//TIM3中断</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>;  <span class="comment">//先占优先级0级</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">3</span>;  <span class="comment">//从优先级3级</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//IRQ通道被使能</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);  <span class="comment">//初始化NVIC寄存器</span></span><br><span class="line"></span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);  <span class="comment">//使能TIM3</span></span><br><span class="line">							 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>   <span class="comment">//TIM3中断</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) <span class="comment">//检查TIM1更新中断发生与否</span></span><br><span class="line">		&#123;</span><br><span class="line">		TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  <span class="comment">//清除TIM3更新中断标志</span></span><br><span class="line">		LED1=!LED1;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>这个是中断时间 的计算公式：</strong></p>
<p><code>Tout= ((arr+1)*(psc+1))/Tclk；</code>单位为us</p>
<p>初始化的时候在默认的系统初始化函数 SystemInit 函数里面已经初始化 APB1 的时钟为 2 分频，所以 APB1 的时钟为 36M，而从 STM32 的内部时钟树图得知：当 APB1 的时钟分频数为 1 的时候，TIM2<del>7 的时钟为 APB1 的时钟，而如果 APB1 的时钟分频数不为 1，那么 TIM2</del>7 的时钟频率将为 APB1 时钟的两倍。这里时钟选择为APB1的两倍，而APB1为36M</p>
<h1 id="PWM输出实验"><a href="#PWM输出实验" class="headerlink" title="PWM输出实验"></a>PWM输出实验</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>将数字信号处理为模拟信号：</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240324150011530.png" alt="image-20240324150011530"></p>
<h3 id="1-开启-TIM1-时钟，配置-PA8-为复用输出。"><a href="#1-开启-TIM1-时钟，配置-PA8-为复用输出。" class="headerlink" title="1.开启 TIM1 时钟，配置 PA8 为复用输出。"></a>1.开启 <strong>TIM1</strong> <strong>时钟，配置</strong> <strong>PA8</strong> <strong>为复用输出。</strong></h3><p>要使用 TIM1，我们必须先开启 TIM1 的时钟，这点相信大家看了这么多代码，应该明白了。这里我们还要配置 PA8 为复用输出（当然还要时能 PORTA 的时钟），这是因为 TIM1_CH1 通道将使用 PA8 的复用功能作为输出。库函数使能 TIM3 时钟的方法是：</p>
<p><code>RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //使能定时器 3 时钟</code></p>
<p>设置 PA8 为复用功能输出的方法在前面的几个实验都有类似的讲解，相信大家很明白,这里简单列出 GPIO 初始化的一行代码即可：</p>
<p><code>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出</code></p>
<h3 id="2-设置-TIM1-的-ARR-和-PSC。"><a href="#2-设置-TIM1-的-ARR-和-PSC。" class="headerlink" title="2.设置 TIM1 的 ARR 和 PSC。"></a>2.<strong>设置</strong> <strong>TIM1</strong> <strong>的</strong> <strong>ARR</strong> <strong>和</strong> <strong>PSC</strong>。</h3><p>在开启了 TIM1 的时钟之后，我们要设置 ARR 和 PSC 两个寄存器的值来控制输出 PWM 的周期。当 PWM 周期太慢（低于 50Hz）的时候，我们就会明显感觉到闪烁了。因此，PWM 周期在这里不宜设置的太小。这在库函数是通过 TIM_TimeBaseInit 函数实现的，在上一节定时器中断章节我们已经有讲解，这里就不详细讲解，调用的格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_TimeBaseStructure.TIM_Period = arr; <span class="comment">//设置自动重装载值</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =psc; <span class="comment">//设置预分频值</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>; <span class="comment">//设置时钟分割:TDTS = Tck_tim</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">//向上计数模式</span></span><br><span class="line">TIM_TimeBaseInit(TIM1, &amp;TIM_TimeBaseStructure); <span class="comment">//根据指定的参数初始化 TIMx 的</span></span><br></pre></td></tr></table></figure>

<h3 id="3-设置-TIM1-CH1-的-PWM-模式及通道方向-使能TIM1-的-CH1-输出。"><a href="#3-设置-TIM1-CH1-的-PWM-模式及通道方向-使能TIM1-的-CH1-输出。" class="headerlink" title="3.设置 TIM1_CH1 的 PWM **模式及通道方向, **使能TIM1 的 CH1 输出。"></a>3.<strong>设置</strong> <strong>TIM1_CH1</strong> <strong>的</strong> <strong>PWM</strong> **模式及通道方向, **使能TIM1 <strong>的</strong> <strong>CH1</strong> <strong>输出。</strong></h3><p>接下来，我们要设置 TIM1_CH1 为 PWM 模式（默认是冻结的），因为我们的 DS0 是低电平亮，而我们希望当 CCR1 的值小的时候，DS0 就暗，CCR1 值大的时候，DS0 就亮，所以我们要通过配置 TIM1_CCMR1 的相关位来控制 TIM1_CH1 的模式。在库函数中，PWM 通道设置是通过函数 TIM_OC1Init()~TIM_OC4Init()来设置的，不同的通道的设置函数不一样，这里我们使用的是通道 1，所以使用的函数是 TIM_OC1Init()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>；</span><br></pre></td></tr></table></figure>

<p>这种初始化格式大家学到这里应该也熟悉了，所以我们直接来看看结构体 TIM_OCInitTypeDef的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">uint16_t</span> TIM_OCMode; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_OutputState; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_OutputNState; */</span><br><span class="line"> <span class="type">uint16_t</span> TIM_Pulse; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_OCPolarity; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_OCNPolarity; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_OCIdleState; </span><br><span class="line"> <span class="type">uint16_t</span> TIM_OCNIdleState; </span><br><span class="line">&#125; TIM_OCInitTypeDef;</span><br></pre></td></tr></table></figure>

<p>这里我们讲解一下与我们要求相关的几个成员变量：</p>
<blockquote>
<p><strong>参</strong>数 TIM_OCMode 设置模式是 PWM 还是输出比较，这里我们是 PWM 模式</p>
</blockquote>
<blockquote>
<p>参数 TIM_OutputState 用来设置比较输出使能，也就是使能 PWM 输出到端口。</p>
</blockquote>
<blockquote>
<p>参数 TIM_OCPolarity 用来设置极性是高还是低。</p>
</blockquote>
<blockquote>
<p>其他的参数 TIM_OutputNState，TIM_OCNPolarity，TIM_OCIdleState 和 TIM_OCNIdleState 是高级定时器 TIM1 和 TIM8 才用到的</p>
</blockquote>
<p>要实现我们上面提到的场景，方法是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; <span class="comment">//选择 PWM 模式 2</span></span><br><span class="line">TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; <span class="comment">//比较输出使能</span></span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; <span class="comment">//输出极性高</span></span><br><span class="line">TIM_OC1Init(TIM1, &amp;TIM_OCInitStructure); <span class="comment">//初始化 TIM1 OC1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-使能-TIM1。"><a href="#4-使能-TIM1。" class="headerlink" title="4.使能 TIM1。"></a>4.<strong>使能</strong> <strong>TIM1</strong>。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_Cmd(TIM1, ENABLE); <span class="comment">//使能 TIM1</span></span><br></pre></td></tr></table></figure>

<h3 id="5-设置-MOE-输出，使能-PWM-输出"><a href="#5-设置-MOE-输出，使能-PWM-输出" class="headerlink" title="5.设置 MOE 输出，使能 PWM 输出"></a>5.<strong>设置</strong> <strong>MOE</strong> <strong>输出，使能</strong> <strong>PWM</strong> <strong>输出</strong></h3><p>普通定时器在完成以上设置了之后，就可以输出 PWM 了，但是高级定时器，我们还需要使能刹车和死区寄存器（TIM1_BDTR）的 MOE 位，以使能整个 OCx（即 PWM）输出。库函数的设置函数为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_CtrlPWMOutputs(TIM1,ENABLE);<span class="comment">// MOE 主输出使能</span></span><br></pre></td></tr></table></figure>

<h3 id="6-修改-TIM1-CCR1-来控制占空比。"><a href="#6-修改-TIM1-CCR1-来控制占空比。" class="headerlink" title="6.修改 TIM1_CCR1 来控制占空比。"></a>6.<strong>修改</strong> <strong>TIM1_CCR1</strong> <strong>来控制占空比。</strong></h3><p>最后，在经过以上设置之后，PWM 其实已经开始输出了，只是其占空比和频率都是固定的，而我们通过修改 TIM1_CCR1 则可以控制 CH1 的输出占空比。继而控制 DS0 的亮度。在库函数中，修改 TIM1_CCR1 占空比的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare1</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare1)</span>；</span><br></pre></td></tr></table></figure>

<p>理所当然，对于其他通道，分别有一个函数名字，函数格式为 TIM_SetComparex(x&#x3D;1,2,3,4)。</p>
<h2 id="硬件设计-1"><a href="#硬件设计-1" class="headerlink" title="硬件设计"></a>硬件设计</h2><p>本实验用到的硬件资源有：</p>
<blockquote>
<p>1） 指示灯 DS0 </p>
</blockquote>
<blockquote>
<p>2） 定时器 TIM3</p>
</blockquote>
<p>这两个前面都有介绍，但是我们这里用到了 TIM1_CH1 通道的输出，从原理图可以看到，TIM1_CH1 是和 PA8 相连的，所以电路上并没有任何变化。</p>
<h2 id="软件设计-3"><a href="#软件设计-3" class="headerlink" title="软件设计"></a>软件设计</h2><p>打开光盘里面的 PWM 输出实验代码，可以看见我们在工程中添加了 pwm.c 文件，并且引入了头文件 pwm.h。打开 pwm.c 内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pwm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="comment">//PWM 输出初始化</span></span><br><span class="line"><span class="comment">//arr：自动重装值</span></span><br><span class="line"><span class="comment">//psc：时钟预分频数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1_PWM_Init</span><span class="params">(u16 arr,u16 psc)</span></span><br><span class="line">&#123;  </span><br><span class="line">	 GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">	TIM_OCInitTypeDef  TIM_OCInitStructure;</span><br><span class="line"></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);<span class="comment">// 使能tim1时钟</span></span><br><span class="line"> 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA , ENABLE);  <span class="comment">//使能GPIO外设时钟使能</span></span><br><span class="line">	                                                                     	</span><br><span class="line">	<span class="comment">//设置该引脚为复用输出功能，输出TIMI1 CH1的PWM的脉冲波形</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; <span class="comment">//TIM_CH1</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  <span class="comment">//复用推免输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	TIM_TimeBaseStructure.TIM_Period = arr; <span class="comment">//设置在下一个更新事件装入活动的自动重装载寄存器周期的值 80K</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_Prescaler =psc; <span class="comment">//设置用来作为 TIMx 时钟频率除数的预分频值 不分频</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>; <span class="comment">//设置时钟分割:TDTS = Tck_tim</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  <span class="comment">//向上计数</span></span><br><span class="line">	TIM_TimeBaseInit(TIM1, &amp;TIM_TimeBaseStructure); <span class="comment">//②初始化 TIMx</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; <span class="comment">//脉宽调制模式 2</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; <span class="comment">//比较输出使能</span></span><br><span class="line">	TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>; <span class="comment">//设置待装入捕获比较寄存器的脉冲值</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; <span class="comment">//输出极性高</span></span><br><span class="line">	TIM_OC1Init(TIM1, &amp;TIM_OCInitStructure);  <span class="comment">//初始化外设 TIMx</span></span><br><span class="line"></span><br><span class="line">  TIM_CtrlPWMOutputs(TIM1,ENABLE);	<span class="comment">//MOE 主输出使能</span></span><br><span class="line"></span><br><span class="line">	TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);  <span class="comment">//CH1 预装载使能	 </span></span><br><span class="line">	</span><br><span class="line">	TIM_ARRPreloadConfig(TIM1, ENABLE); <span class="comment">//使能 TIMx 在 ARR 上的预装载寄存器</span></span><br><span class="line">	</span><br><span class="line">	TIM_Cmd(TIM1, ENABLE);  <span class="comment">//使能 TIM1</span></span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>接下来是主函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pwm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;	</span><br><span class="line">	u16 led0pwmval=<span class="number">0</span>;    </span><br><span class="line">	u8 dir=<span class="number">1</span>;	</span><br><span class="line">	delay_init();	    		  </span><br><span class="line">	LED_Init();		  </span><br><span class="line">	TIM1_PWM_Init(<span class="number">899</span>,<span class="number">0</span>);<span class="comment">//不分频。PWM 频率=72000/(899+1)=80Khz</span></span><br><span class="line">   	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"> 		delay_ms(<span class="number">10</span>);	 </span><br><span class="line">		<span class="keyword">if</span>(dir)led0pwmval++;</span><br><span class="line">		<span class="keyword">else</span> led0pwmval--;	 </span><br><span class="line"> 		<span class="keyword">if</span>(led0pwmval&gt;<span class="number">300</span>)dir=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(led0pwmval==<span class="number">0</span>)dir=<span class="number">1</span>;	   					 </span><br><span class="line">		TIM_SetCompare1(TIM1,led0pwmval);	   </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h1 id="编码器接口"><a href="#编码器接口" class="headerlink" title="编码器接口"></a>编码器接口</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><p>这章在正点原子里面没有，所以我参考了普中的实验，并且按照自己的配置修改了，为了显示cnt我决定在通过串口显示在电脑上</p>
<p>1.Encoder Interface 编码器接口可接收增量(正交)编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度</p>
<p>2.每个高级定时器和通用定时器都拥有1个编码器接口</p>
<p>3.两个输入引脚借用了输入捕获的通道1和通道2</p>
<h2 id="软件设计-4"><a href="#软件设计-4" class="headerlink" title="软件设计"></a>软件设计</h2><p>1.RCC开启时钟，开启GPIO和定时器的时钟。</p>
<p>2.配置GPIO，把PA6和PA7配置为输入模式</p>
<p>3.配置时基单元，预分频器选择不分频。自动重装，最大给65535，只需一个CNT执行计数就行了。</p>
<p>4.配置输入捕获单元，只有滤波器和极性两个参数可以用。</p>
<p>5.配置编码器接口模式，直接调用库函数</p>
<p>6.调用TIM_Cmd启动定时器就行了。</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240406220108946.png" alt="image-20240406220108946"></p>
<p>初始化完成之后，CNT会随着编码器旋转而自增自减。</p>
<p>想知道编码器位置，直接读CNT</p>
<p>如果想知道速度与方向，那就需要每隔一段固定的闸门时间，取出一次CNT，然后清零，利用测频法来测量速度。</p>
<h4 id="encoder-c"><a href="#encoder-c" class="headerlink" title="encoder.c"></a>encoder.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Encoder.h&quot;</span></span></span><br><span class="line"><span class="comment">//这里PA6和PA7为接口</span></span><br><span class="line">TIM_ICInitTypeDef  TIM3_ICInitStructure;<span class="comment">//该类型是用于配置TIM3定时器输入捕获的结构体。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span>&#123;<span class="comment">//用于初始化编码器</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;<span class="comment">//结构体用于GPIO初始化配置</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;<span class="comment">//结构体用于定时器基本配置</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);	</span><br><span class="line"> 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  <span class="comment">//这两行代码启用TIM3时钟和GPIOA端口时钟。RCC_APB1PeriphClockCmd`和RCC_APB2PeriphClockCmd是STM32标准库函数，用于控制高级外设（APB2）和低级外设（APB1）的时钟。</span></span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_6 | GPIO_Pin_7;  </span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; </span><br><span class="line">    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;	</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOA的6号和7号引脚。将它们设置为上拉输入模式，这对于编码器的信号线是典型的配置。</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//初始化定时器TIM3</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>; <span class="comment">//此行设置了定时器的周期（ARR - Auto-Reload Register），它决定定时器计数器的最大值。定时器计数器会从0开始计数，一直到这个值然后重新开始（或者在编码器模式下，计数器会增加或减少）。这里设置的值是65535（16位最大值），因为STM32的定时器是16位的（某些型号可能有32位定时器）。由于计数是从0开始的，所以最大值要减1才是65535。当计数器值达到65535后，下一个脉冲会使其回到0，形成一个循环。</span></span><br><span class="line">    </span><br><span class="line">	TIM_TimeBaseStructure.TIM_Prescaler =<span class="number">1</span><span class="number">-1</span>; 	<span class="comment">//分频器（PSC - Prescaler）用于降低定时器输入时钟频率。TIM_Prescaler值定义了时钟频率除数。TIM_Prescaler的值是实际分频值减1。所以这里设置为0，意思是定时器计数器的时钟频率不变，即不分频。如果时钟频率是72MHz，这里的设置意味着定时器的计数频率也将是72MHz。</span></span><br><span class="line">    </span><br><span class="line">	TIM_TimeBaseStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//此字段TIM_RepetitionCounter用于高级定时器，它设置了重复计数器的值。这个计数器用于指定更新事件（UEV）产生的次数，每达到该次数，就会重新加载计数器（仅适用于带有重复功能的定时器）。对于通用定时器，比如TIM3，这个字段通常不起作用，设置为0表示没有重复计数功能。</span></span><br><span class="line">    </span><br><span class="line">	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; <span class="comment">//TIM_ClockDivision字段用于设置时钟分频，这个分频是对定时器的内部时钟（用于数字滤波器）的分频。TIM_CKD_DIV1表示没有分频，即内部时钟与输入时钟相同。其他选项如TIM_CKD_DIV2和TIM_CKD_DIV4会对内部时钟进行相应的分频。</span></span><br><span class="line">    </span><br><span class="line">	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  <span class="comment">//TIM_CounterMode字段设置定时器的计数模式。TIM_CounterMode_Up表示定时器以向上计数模式工作，即计数器从0计数到预设的自动重装载值后溢出，然后重新从0开始计数。其他常见模式包括向下计数模式（TIM_CounterMode_Down）和向上向下计数模式（TIM_CounterMode_CenterAligned）。</span></span><br><span class="line">    </span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); </span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//初始化TIM3输入捕获参数</span></span><br><span class="line">	TIM_ICStructInit(&amp;TIM3_ICInitStructure);<span class="comment">//结构体初始化为默认值</span></span><br><span class="line">    </span><br><span class="line">	TIM3_ICInitStructure.TIM_Channel = TIM_Channel_1; <span class="comment">//这里指定了TIM3定时器的第一个通道（Channel 1）用于输入捕获。STM32的定时器通常有多个通道，可以分别用于输入或输出功能。在这种情况下，我们使用Channel 1来获取外部信号的计时。</span></span><br><span class="line">    </span><br><span class="line">  	TIM3_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;	<span class="comment">//此行代码设置输入捕获的极性。TIM_ICPolarity_Rising的意思是定时器仅在检测到上升沿时触发输入捕获事件。也就是说，当检测到从低电平变为高电平的变化时，定时器会捕获此时的计数器值。相反，如果你想在下降沿捕获计数值，你可以使用TIM_ICPolarity_Falling。有时候你会想要在上升沿和下降沿都捕获计数值，那么可以使用TIM_ICPolarity_BothEdge。</span></span><br><span class="line">    </span><br><span class="line">  	TIM3_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;<span class="comment">//这里通过配置输入捕获滤波器来防止噪声引起的错误触发。0xF（在STM32的标准外设库中是一个4位的值，范围从0x0到0xF）指定了滤波器的级别。一个较高的值表示较强的噪声抑制，意味着输入信号在被认为是有效的上升沿或下降沿之前需要保持一定时间的稳定状态。这能有效地减少由于信号抖动引起的误触发。</span></span><br><span class="line">    </span><br><span class="line">  	TIM_ICInit(TIM3, &amp;TIM3_ICInitStructure);<span class="comment">//最后，这行代码使用前面定义和设置的TIM3_ICInitStructure结构体来初始化TIM3定时器的输入捕获功能。TIM_ICInit是一个库函数，它应用了结构体中的配置并准备定时器去捕获外部信号。</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	TIM3_ICInitStructure.TIM_Channel = TIM_Channel_2; <span class="comment">//通过更改通道参数，对TIM3的第二个输入捕获通道进行类似配置。</span></span><br><span class="line">  	TIM3_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;	</span><br><span class="line">  	TIM3_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">  	TIM_ICInit(TIM3, &amp;TIM3_ICInitStructure);</span><br><span class="line">	</span><br><span class="line">				                  												TIM_EncoderInterfaceConfig(TIM3,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising);<span class="comment">//将TIM3配置为编码器接口模式，此模式同时利用上面配置的两个输入通道（TI1和TI2）。</span></span><br><span class="line">   TIM_Cmd(TIM3,ENABLE ); 	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> TIM_GetCounter(TIM3);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么需要两个通道呢?</p>
<ol>
<li><strong>方向检测：</strong> 一个旋转编码器产生两个波形，分别称为A相和B相，它们是互相位移90度（即四分之一周期）的方波信号。这种位移被称为相位编码，允许我们不仅测量编码器的旋转速度，而且还可以确定其旋转方向。通过比较这两个信号的相位关系，我们可以判断编码器是向前旋转还是向后旋转。<ul>
<li>如果A相在B相前，编码器向一个方向旋转。</li>
<li>如果B相在A相前，编码器向相反方向旋转。</li>
</ul>
</li>
<li><strong>位置计数：</strong> 当编码器旋转时，A相和B相信号会产生脉冲。STM32定时器在编码器模式下能够使用这两个通道的信号来增加或减少计数器的值。这意味着，定时器不仅仅是简单地计数A相的脉冲，它还利用这两个通道来确定旋转的方向，并作出相应地增加或减少计数器数值的动作。</li>
<li><strong>分辨率提高：</strong> 由于A相和B相信号相互之间存在90度的相位差，所以在每个信号的每个上升沿和下降沿之间，定时器可以更新四次计数器的值。这意味着编码器模式可以实现比单独使用一个通道更高的分辨率。</li>
</ol>
<p>结合这两个通道，微控制器可以通过检查计数器的递增和递减来精确测量旋转编码器的位置和方向。在STM32微控制器中，这通常是通过配置定时器在编码器模式下工作来实现的，这样定时器自动处理这两个通道的信号，并维护一个表示编码器旋转位置的计数值。</p>
</blockquote>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240407233404369.png" alt="image-20240407233404369"></p>
<h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Encoder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="comment">//ALIENTEK Mini STM32开发板范例代码7</span></span><br><span class="line"><span class="comment">//定时器中断实验   </span></span><br><span class="line"><span class="comment">//技术支持：www.openedv.com</span></span><br><span class="line"><span class="comment">//广州市星翼电子科技有限公司</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;	</span><br><span class="line">	u8 t;</span><br><span class="line">	u8 len;	</span><br><span class="line">	u16 times=<span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">	delay_init();	    	 <span class="comment">//延时函数初始化	</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">// 设置中断优先级分组2</span></span><br><span class="line">	uart_init(<span class="number">9600</span>);	 <span class="comment">//串口初始化为9600</span></span><br><span class="line">	LED_Init();		  	 <span class="comment">//初始化与LED连接的硬件接口 </span></span><br><span class="line">	Encoder_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x8000</span>)</span><br><span class="line">		&#123;					   </span><br><span class="line">			len=USART_RX_STA&amp;<span class="number">0x3fff</span>;<span class="comment">//得到此次接收到的数据长度</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r\n您发送的消息为:\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)</span><br><span class="line">			&#123;</span><br><span class="line">				USART1-&gt;DR=USART_RX_BUF[t];</span><br><span class="line">				<span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//等待发送结束</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r\n\r\n&quot;</span>);<span class="comment">//插入换行</span></span><br><span class="line">			USART_RX_STA=<span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			times++;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">5000</span>==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\r\nALIENTEK MiniSTM32开发板 串口实验\r\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;正点原子@ALIENTEK\r\n\r\n\r\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>,Encoder_Get());</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">200</span>==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入数据,以回车键结束\r\n&quot;</span>);  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%u\r\n&quot;</span>,Encoder_Get());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">30</span>==<span class="number">0</span>)LED0=!LED0;<span class="comment">//闪烁LED,提示系统正在运行.</span></span><br><span class="line">			delay_ms(<span class="number">10</span>);   </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就可以显示在电脑上了</p>
<h1 id="SPI实验（flash外部储存）"><a href="#SPI实验（flash外部储存）" class="headerlink" title="SPI实验（flash外部储存）"></a>SPI实验（flash外部储存）</h1><p>我们将使用 STM32 自带的 SPI 来实现对外部 FLASH（W25Q64）的读写，并将结果显示在 TFTLCD 模块上。本章分为如下几个部分</p>
<h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><p>由于过于复杂，我们直接由上而下，看怎么用。</p>
<h3 id="配置相关引脚的复用功能，使能-SPI1-时钟。"><a href="#配置相关引脚的复用功能，使能-SPI1-时钟。" class="headerlink" title="配置相关引脚的复用功能，使能 SPI1 时钟。"></a><strong>配置相关引脚的复用功能，使能</strong> <strong>SPI1</strong> <strong>时钟。</strong></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE );<span class="comment">//PORTA 时钟使能</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI1, ENABLE );<span class="comment">//SPI1 时钟使能</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class="comment">//PA5,6,7 复用推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化 GPIOB</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化-SPI1-设置-SPI1-工作模式"><a href="#初始化-SPI1-设置-SPI1-工作模式" class="headerlink" title="初始化 **SPI1,**设置 SPI1 工作模式"></a><strong>初始化</strong> **SPI1,**设置 <strong>SPI1</strong> <strong>工作模式</strong></h3><p>接下来我们要初始化 SPI1,设置 SPI1 为主机模式，设置数据格式为 8 位，然后设置 SCK 时钟极性及采样方式。并设置 SPI1 的时钟频率（最大 18Mhz），以及数据的格式（MSB 在前还是LSB 在前）。这在库函数中是通过 SPI_Init 函数来实现的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_Init</span><span class="params">(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)</span>；</span><br></pre></td></tr></table></figure>

<p>跟其他外设初始化一样，第一个参数是 SPI 标号，这里我们是使用的 SPI1。下面我们来看看第二个参数结构体类型SPI_InitTypeDef 的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">uint16_t</span> SPI_Direction;</span><br><span class="line"> <span class="type">uint16_t</span> SPI_Mode; </span><br><span class="line"> <span class="type">uint16_t</span> SPI_DataSize; </span><br><span class="line"> <span class="type">uint16_t</span> SPI_CPOL; </span><br><span class="line"> <span class="type">uint16_t</span> SPI_CPHA; </span><br><span class="line"> <span class="type">uint16_t</span> SPI_NSS; </span><br><span class="line"> <span class="type">uint16_t</span> SPI_BaudRatePrescaler; </span><br><span class="line"> <span class="type">uint16_t</span> SPI_FirstBit; </span><br><span class="line"> <span class="type">uint16_t</span> SPI_CRCPolynomial; </span><br><span class="line">&#125;SPI_InitTypeDef</span><br></pre></td></tr></table></figure>

<p>我们设置成这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SPI_InitTypeDef SPI_InitStructure;</span><br><span class="line">SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; <span class="comment">//双线双向全双工</span></span><br><span class="line">SPI_InitStructure.SPI_Mode = SPI_Mode_Master; <span class="comment">//主 SPI</span></span><br><span class="line">SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; <span class="comment">// SPI 发送接收 8 位帧结构</span></span><br><span class="line">SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;<span class="comment">//串行同步时钟的空闲状态为高电平</span></span><br><span class="line">SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;<span class="comment">//第二个跳变沿数据被采样</span></span><br><span class="line">SPI_InitStructure.SPI_NSS = SPI_NSS_Soft; <span class="comment">//NSS 信号由软件控制</span></span><br><span class="line">SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256; <span class="comment">//预分频 256</span></span><br><span class="line">SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; <span class="comment">//数据传输从 MSB 位开始</span></span><br><span class="line">SPI_InitStructure.SPI_CRCPolynomial = <span class="number">7</span>; <span class="comment">//CRC 值计算的多项式</span></span><br><span class="line">SPI_Init(SPI1, &amp;SPI_InitStructure); <span class="comment">//根据指定的参数初始化外设 SPIx 寄存器</span></span><br></pre></td></tr></table></figure>

<h3 id="使能-SPI1"><a href="#使能-SPI1" class="headerlink" title="使能 SPI1"></a><strong>使能</strong> <strong>SPI1</strong></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SPI_Cmd(SPI1, ENABLE); <span class="comment">//使能 SPI 外设</span></span><br></pre></td></tr></table></figure>

<h3 id="传输和接受数据"><a href="#传输和接受数据" class="headerlink" title="传输和接受数据"></a>传输和接受数据</h3><p>发送数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_SendData</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> Data)</span>；</span><br></pre></td></tr></table></figure>

<p>接收数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI_I2S_ReceiveData</span><span class="params">(SPI_TypeDef* SPIx)</span> ；</span><br></pre></td></tr></table></figure>

<h2 id="软件设计-5"><a href="#软件设计-5" class="headerlink" title="软件设计"></a>软件设计</h2><p>开机的时候先检测 W25Q64 是否存在，然后在主循环里面检测两个按键，其中 1 个按键（WK_UP）用来执行写入 W25Q64 的操作，另外一个按键（KEY0）用来执行读出操作，在 TFTLCD 模块上显示相关信息。同时用 DS0 提示程序正在运行。</p>
<p>由于文件数量过大，我就不在此处展示，可以到正点原子官方那里去要源码，这里直接看main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ALIENTEK Mini STM32开发板范例代码20</span></span><br><span class="line"><span class="comment">//SPI实验  </span></span><br><span class="line"><span class="comment">//技术支持：www.openedv.com</span></span><br><span class="line"><span class="comment">//广州市星翼电子科技有限公司</span></span><br><span class="line">   	</span><br><span class="line"><span class="comment">//要写入到W25Q64的字符串数组</span></span><br><span class="line"><span class="type">const</span> u8 TEXT_Buffer[]=&#123;<span class="string">&quot;MiniSTM32 SPI TEST&quot;</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE sizeof(TEXT_Buffer)	 </span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123; </span><br><span class="line">	u8 key;</span><br><span class="line">	u16 i=<span class="number">0</span>;</span><br><span class="line">	u8 datatemp[SIZE];</span><br><span class="line">	u32 FLASH_SIZE;</span><br><span class="line">    u16 id = <span class="number">0</span>;</span><br><span class="line">	delay_init();	    	 <span class="comment">//延时函数初始化	  </span></span><br><span class="line">	uart_init(<span class="number">9600</span>);	 	<span class="comment">//串口初始化为9600</span></span><br><span class="line">	LED_Init();		  		<span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line"> 	LCD_Init();</span><br><span class="line">	KEY_Init();				<span class="comment">//按键初始化		 	</span></span><br><span class="line">	SPI_Flash_Init();  		<span class="comment">//SPI FLASH 初始化 	 </span></span><br><span class="line"> 	POINT_COLOR=RED;<span class="comment">//设置字体为红色 </span></span><br><span class="line">	LCD_ShowString(<span class="number">60</span>,<span class="number">50</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Mini STM32&quot;</span>);	</span><br><span class="line">	LCD_ShowString(<span class="number">60</span>,<span class="number">70</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;SPI TEST&quot;</span>);	</span><br><span class="line">	LCD_ShowString(<span class="number">60</span>,<span class="number">90</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;ATOM@ALIENTEK&quot;</span>);</span><br><span class="line">	LCD_ShowString(<span class="number">60</span>,<span class="number">110</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;2014/3/9&quot;</span>);	</span><br><span class="line">	LCD_ShowString(<span class="number">60</span>,<span class="number">130</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;WK_UP:Write  KEY0:Read&quot;</span>);	<span class="comment">//显示提示信息		</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		id = SPI_Flash_ReadID();</span><br><span class="line">		<span class="keyword">if</span> (id == W25Q64 || id == NM25Q64)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		LCD_ShowString(<span class="number">30</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;W25Q64 Check Failed!&quot;</span>);</span><br><span class="line">		delay_ms(<span class="number">500</span>);</span><br><span class="line">		LCD_ShowString(<span class="number">30</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Please Check!        &quot;</span>);</span><br><span class="line">		delay_ms(<span class="number">500</span>);</span><br><span class="line">		LED0=!LED0;<span class="comment">//DS0闪烁</span></span><br><span class="line">	&#125;</span><br><span class="line">	LCD_ShowString(<span class="number">60</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;25Q64 Ready!&quot;</span>);</span><br><span class="line"></span><br><span class="line">	FLASH_SIZE=<span class="number">8</span>*<span class="number">1024</span>*<span class="number">1024</span>;	<span class="comment">//FLASH 大小为8M字节</span></span><br><span class="line">  	POINT_COLOR=BLUE;		<span class="comment">//设置字体为蓝色	  </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		key=KEY_Scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==WKUP_PRES)	<span class="comment">//WK_UP 按下,写入W25Q64</span></span><br><span class="line">		&#123;</span><br><span class="line">			LCD_Fill(<span class="number">0</span>,<span class="number">170</span>,<span class="number">239</span>,<span class="number">319</span>,WHITE);<span class="comment">//清除半屏    </span></span><br><span class="line"> 			LCD_ShowString(<span class="number">60</span>,<span class="number">170</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Start Write W25Q64....&quot;</span>);</span><br><span class="line">			SPI_Flash_Write((u8*)TEXT_Buffer,FLASH_SIZE<span class="number">-100</span>,SIZE);		<span class="comment">//从倒数第100个地址处开始,写入SIZE长度的数据</span></span><br><span class="line">			LCD_ShowString(<span class="number">60</span>,<span class="number">170</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;W25Q64 Write Finished!&quot;</span>);	<span class="comment">//提示传送完成</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(key==KEY0_PRES)	<span class="comment">//KEY0 按下,读取字符串并显示</span></span><br><span class="line">		&#123;</span><br><span class="line"> 			LCD_ShowString(<span class="number">60</span>,<span class="number">170</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Start Read W25Q64.... &quot;</span>);</span><br><span class="line">			SPI_Flash_Read(datatemp,FLASH_SIZE<span class="number">-100</span>,SIZE);				<span class="comment">//从倒数第100个地址处开始,读出SIZE个字节</span></span><br><span class="line">			LCD_ShowString(<span class="number">60</span>,<span class="number">170</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;The Data Readed Is:  &quot;</span>);	<span class="comment">//提示传送完成</span></span><br><span class="line">			LCD_ShowString(<span class="number">60</span>,<span class="number">190</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,datatemp);					<span class="comment">//显示读到的字符串</span></span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">		delay_ms(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LED0=!LED0;<span class="comment">//提示系统正在运行	</span></span><br><span class="line">			i=<span class="number">0</span>;</span><br><span class="line">		&#125;		   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们关注如何进行读写操作，我们把需要读取的数据放在<code>const u8 TEXT_Buffer[]=&#123;&quot;MiniSTM32 SPI TEST&quot;&#125;;</code>，在<code>SPI_Flash_Write((u8*)TEXT_Buffer,FLASH_SIZE-100,SIZE);</code>中把数据写到flash中，然后通过<code>SPI_Flash_Read(datatemp,FLASH_SIZE-100,SIZE);</code>把读取数据到<code>datatemp</code>，然后输出就ok了。</p>
<h1 id="TFLCD显示实验-制作菜单任务"><a href="#TFLCD显示实验-制作菜单任务" class="headerlink" title="TFLCD显示实验(制作菜单任务)"></a>TFLCD显示实验(制作菜单任务)</h1><p>在上一个单元中，我们其实忽略了TFLCD的显示，我们最终的数据其实要显示在LED上的，这次我们就把这个学习一下这个实验，并且实现一下智能车的任务：制作一个菜单。</p>
<blockquote>
<p>任务要求：写个菜单，将其显示在屏幕上，同时利用flash存储与读写数据，同时利用按键选择具体改变的 数据类型并改变数据的大小。</p>
</blockquote>
<h2 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h2><p><strong>一般 TFTLCD 模块的使用流程如图</strong></p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240328234820371.png" alt="image-20240328234820371"></p>
<blockquote>
<p>任何 LCD，使用流程都可以简单的用以上流程图表示。其中硬复位和初始化序列，只需要执行一次即可。而画点流程就是：设置坐标→写 GRAM 指令→写入颜色数据，然后在 LCD 上面，我们就可以看到对应的点显示我们写入的颜色了。读点流程为：设置坐标→读 GRAM 指令→读取颜色数据，这样就可以获取到对应点的颜色数据了。</p>
</blockquote>
<blockquote>
<p>以上只是最简单的操作，也是最常用的操作，有了这些操作，一般就可以正常使用 TFTLCD了。接下来我们将该模块用来来显示字和数字，通过以上介绍，我们可以得出 TFTLCD 显示需要的相关设置步骤如下：</p>
</blockquote>
<h3 id="1-设置-STM32-与-TFTLCD-模块相连接的-IO"><a href="#1-设置-STM32-与-TFTLCD-模块相连接的-IO" class="headerlink" title="1.设置 STM32 与 TFTLCD 模块相连接的 IO"></a>1.<strong>设置</strong> <strong>STM32</strong> <strong>与</strong> <strong>TFTLCD</strong> <strong>模块相连接的</strong> <em>IO</em></h3><p>这一步，先将我们与 TFTLCD 模块相连的 IO 口进行初始化，以便驱动 LCD。这里需要根据连接电路以及 TFTLCD 模块的设置来确定。</p>
<h3 id="2-初始化-TFTLCD-模块"><a href="#2-初始化-TFTLCD-模块" class="headerlink" title="2.初始化 TFTLCD 模块"></a>2.<strong>初始化</strong> <strong>TFTLCD</strong> <strong>模块</strong></h3><p>初始化序列，就是向 LCD 控制器写入一系列的设置值（比如伽马校准），这些初始化序列一般 LCD 供应商会提供给客户，我们直接使用这些序列即可，不需要深入研究。在初始化之后，LCD 才可以正常使用.</p>
<h3 id="3-通过函数将字符和数字显示到-TFTLCD-模块上"><a href="#3-通过函数将字符和数字显示到-TFTLCD-模块上" class="headerlink" title="3.通过函数将字符和数字显示到 TFTLCD 模块上"></a>3.<strong>通过函数将字符和数字显示到</strong> <strong>TFTLCD</strong> <strong>模块上</strong></h3><p>前两步基本不用看，这一步比较重要，设置置坐标→写 GRAM 指令→写 GRAM 来实现，但是这个步骤，只是一个点的处理，我们要显示字符&#x2F;数字，就必须要多次使用这个步骤，从而达到显示字符&#x2F;数字的目标，所以需要设计一个函数来实现数字&#x2F;字符的显示，之后调用该函数，就可以实现数字&#x2F;字符的显示了。</p>
<h2 id="软件设计-6"><a href="#软件设计-6" class="headerlink" title="软件设计"></a>软件设计</h2><p>由于.c文件设计太复杂，我们直接在.h中看怎么用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 width;      <span class="comment">//LCD 宽度</span></span><br><span class="line">    u16 height;     <span class="comment">//LCD 高度</span></span><br><span class="line">    u16 id;         <span class="comment">//LCD ID</span></span><br><span class="line">    u8  dir;        <span class="comment">//横屏还是竖屏控制：0，竖屏；1，横屏。</span></span><br><span class="line">    u16 wramcmd;    <span class="comment">//开始写gram指令</span></span><br><span class="line">    u16 setxcmd;    <span class="comment">//设置x坐标指令</span></span><br><span class="line">    u16  setycmd;   <span class="comment">//设置y坐标指令</span></span><br><span class="line">&#125; _lcd_dev;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个结构体定义了我们lcd的参数，每个lcd的屏幕都是不一样的，可以在这里更改设置</p>
<p>然后是写数据函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写数据函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_WR_DATA(data)&#123;\</span></span><br><span class="line"><span class="meta">LCD_RS_SET;\</span></span><br><span class="line"><span class="meta">LCD_CS_CLR;\</span></span><br><span class="line"><span class="meta">DATAOUT(data);\</span></span><br><span class="line"><span class="meta">LCD_WR_CLR;\</span></span><br><span class="line"><span class="meta">LCD_WR_SET;\</span></span><br><span class="line"><span class="meta">LCD_CS_SET;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。不行了，正点原子这个地方讲的太烂了，甚至手册里面的代码都不一样，我果断抛弃，直接在spi的基础上写菜单了，因为spi里面也有lcd的文件，直接用就可以了</p>
<h2 id="菜单实现"><a href="#菜单实现" class="headerlink" title="菜单实现"></a>菜单实现</h2><p>写个菜单，将其显示在屏幕上，同时利用flash存储与读写数据，同时利用按键选择具体改变的 数据类型并改变数据的大小。重新看一下任务的要求 ,其实大部分已经帮我们实现好了，接下来就是关于具体功能的实现。</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>我们一共有三个按键，我打算把<code>WK_UP</code>设为改变数据类型，从小到大改变，用三的余数来控制类型，KEY1设计为减小数据，KEY0设计为增大数据。一共确定三个数据类型（字符，uint，八位的二进制）放在屏幕中央实时显示。</p>
<h3 id="软件设计-7"><a href="#软件设计-7" class="headerlink" title="软件设计"></a>软件设计</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ALIENTEK Mini STM32开发板范例代码20</span></span><br><span class="line"><span class="comment">//SPI实验  </span></span><br><span class="line"><span class="comment">//技术支持：www.openedv.com</span></span><br><span class="line"><span class="comment">//广州市星翼电子科技有限公司</span></span><br><span class="line">   	</span><br><span class="line"><span class="comment">//要写入到W25Q64的字符串数组</span></span><br><span class="line"><span class="type">const</span> u8 TEXT_Buffer[]=&#123;<span class="string">&quot;lalalala&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowBinary</span><span class="params">(u16 x, u16 y, u8 num, u8 size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> binaryChar = (num &amp; (<span class="number">1</span> &lt;&lt; (<span class="number">7</span> - i))) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        LCD_ShowChar(x + i * (size / <span class="number">2</span>), y, binaryChar, size, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE sizeof(TEXT_Buffer)	 </span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">		</span><br><span class="line">u8 key;</span><br><span class="line"><span class="type">int</span> keynum=<span class="number">0</span>;</span><br><span class="line">u16 i=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> charData = <span class="string">&#x27;A&#x27;</span>; </span><br><span class="line">u32 uintData = <span class="number">123</span>;</span><br><span class="line">u8 binaryData = <span class="number">0x00</span>; </span><br><span class="line">u32 FLASH_SIZE;</span><br><span class="line">u16 id = <span class="number">0</span>;</span><br><span class="line">delay_init();	    	 <span class="comment">//延时函数初始化	  </span></span><br><span class="line">uart_init(<span class="number">9600</span>);	 	<span class="comment">//串口初始化为9600</span></span><br><span class="line">LED_Init();		  		<span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">LCD_Init();</span><br><span class="line">KEY_Init();				<span class="comment">//按键初始化		 	</span></span><br><span class="line">SPI_Flash_Init();  		<span class="comment">//SPI FLASH 初始化 	 </span></span><br><span class="line">POINT_COLOR=BLACK;<span class="comment">//设置字体为黑色 </span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	id = SPI_Flash_ReadID();</span><br><span class="line">	<span class="keyword">if</span> (id == W25Q64 || id == NM25Q64)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;W25Q64 Check Failed!&quot;</span>);</span><br><span class="line">	delay_ms(<span class="number">500</span>);</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Please Check!        &quot;</span>);</span><br><span class="line">	delay_ms(<span class="number">500</span>);</span><br><span class="line">	LED0=!LED0;<span class="comment">//DS0闪烁</span></span><br><span class="line">&#125;</span><br><span class="line">FLASH_SIZE=<span class="number">8</span>*<span class="number">1024</span>*<span class="number">1024</span>;	<span class="comment">//FLASH 大小为8M字节  </span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">70</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;WK_UP to change the data type &quot;</span>);</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">90</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY 1 to add&quot;</span>);</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">110</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY 0 to decline&quot;</span>);</span><br><span class="line">	LCD_ShowChar(<span class="number">60</span>,<span class="number">150</span>,charData,<span class="number">16</span>,<span class="number">0</span>);</span><br><span class="line">	LCD_ShowNum(<span class="number">20</span>,<span class="number">170</span>,uintData,<span class="number">8</span>,<span class="number">16</span>);</span><br><span class="line">	LCD_ShowBinary(<span class="number">60</span>, <span class="number">190</span>, binaryData, <span class="number">16</span>);</span><br><span class="line">	LCD_ShowNum(<span class="number">20</span>,<span class="number">210</span>,keynum,<span class="number">8</span>,<span class="number">16</span>);</span><br><span class="line">	key=KEY_Scan(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(key==WKUP_PRES)	<span class="comment">//WK_UP 按下,切换数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		keynum++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(key==KEY0_PRES)	<span class="comment">//KEY0 按下,增大数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">			charData++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">			uintData++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">			binaryData++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(key==KEY1_PRES)	<span class="comment">//KEY1 按下,减小数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">			charData--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">			uintData--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">			binaryData--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	i++;</span><br><span class="line">	delay_ms(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED0=!LED0;<span class="comment">//提示系统正在运行	</span></span><br><span class="line">		i=<span class="number">0</span>;</span><br><span class="line">	&#125;		   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们定义一下数据类型以及设定初始值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> charData = <span class="string">&#x27;A&#x27;</span>; </span><br><span class="line">u32 uintData = <span class="number">123</span>;</span><br><span class="line">u8 binaryData = <span class="number">0x00</span>; </span><br></pre></td></tr></table></figure>

<p>然后观察在lcd.h中设定的显示函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChar</span><span class="params">(u16 x, u16 y, u8 num, u8 size, u8 mode)</span>;               </span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowNum</span><span class="params">(u16 x, u16 y, u32 num, u8 len, u8 size)</span>;                  </span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowxNum</span><span class="params">(u16 x, u16 y, u32 num, u8 len, u8 size, u8 mode)</span>;       </span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(u16 x, u16 y, u16 width, u16 height, u8 size, u8 *p)</span>;   </span><br></pre></td></tr></table></figure>

<p>如果不明白的话也就在.c文件中有具体解释参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LCD_ShowString(<span class="number">30</span>,<span class="number">70</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;WK_UP to change the data type &quot;</span>);</span><br><span class="line">		LCD_ShowString(<span class="number">30</span>,<span class="number">90</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY 1 to add&quot;</span>);</span><br><span class="line">		LCD_ShowString(<span class="number">30</span>,<span class="number">110</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY 0 to decline&quot;</span>);</span><br><span class="line">		LCD_ShowChar(<span class="number">60</span>,<span class="number">150</span>,charData,<span class="number">16</span>,<span class="number">0</span>);</span><br><span class="line">		LCD_ShowNum(<span class="number">20</span>,<span class="number">170</span>,uintData,<span class="number">8</span>,<span class="number">16</span>);</span><br><span class="line">		LCD_ShowBinary(<span class="number">60</span>, <span class="number">190</span>, binaryData, <span class="number">16</span>);</span><br><span class="line">		LCD_ShowNum(<span class="number">20</span>,<span class="number">210</span>,keynum,<span class="number">8</span>,<span class="number">16</span>);</span><br><span class="line">		key=KEY_Scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==WKUP_PRES)	<span class="comment">//WK_UP °´ÏÂ,ÇÐ»»Êý¾Ý</span></span><br><span class="line">		&#123;</span><br><span class="line">			keynum++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(key==KEY0_PRES)	<span class="comment">//KEY0 °´ÏÂ,Ôö´óÊý¾Ý</span></span><br><span class="line">		&#123;</span><br><span class="line"> 			<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">				charData++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">				uintData++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">				binaryData++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(key==KEY1_PRES)	<span class="comment">//KEY1 °´ÏÂ,¼õÐ¡Êý¾Ý</span></span><br><span class="line">		&#123;</span><br><span class="line"> 			<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">				charData--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">				uintData--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(keynum%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">				binaryData--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>最后在<code>while(1)</code>实现逻辑，是不是很简单呢</p>
<blockquote>
<p>其实可以更加完善一点的，但是选中的数据要框起来，但是没什么时间了，之后再搞这个</p>
</blockquote>
<h1 id="PID闭环控制（以平面上不掉落的小球为例子）"><a href="#PID闭环控制（以平面上不掉落的小球为例子）" class="headerlink" title="PID闭环控制（以平面上不掉落的小球为例子）"></a>PID闭环控制（以平面上不掉落的小球为例子）</h1><blockquote>
<p>需要参照物才能走直线</p>
</blockquote>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415125111521.png" alt="image-20240415125111521"></p>
<p>PID：<strong>偏差量</strong>通过怎样的计算才能得到<strong>执行量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">偏差量=目标量-小球位置</span><br><span class="line">比例P=偏差量*比例P系数（由于的单位不同）</span><br><span class="line">执行量=比例P</span><br></pre></td></tr></table></figure>

<h4 id="增幅器"><a href="#增幅器" class="headerlink" title="增幅器"></a>增幅器</h4><blockquote>
<p>如果小球持续向某一个方向移动呢？</p>
</blockquote>
<p>比例P通过增幅器增大</p>
<p>它通过过去累加经验，来判断比例P是否需要增加</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415130625126.png" alt="image-20240415130625126"></p>
<blockquote>
<p>增幅器需要限制，如果出现错误有可能会被累加到无限大。</p>
</blockquote>
<ol>
<li>在任何时候都限制大小</li>
<li>目标丢失情况下主动将积分I清零</li>
</ol>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415130817915.png" alt="image-20240415130817915"></p>
<h4 id="抑制器"><a href="#抑制器" class="headerlink" title="抑制器"></a>抑制器</h4><blockquote>
<p>如果小球持续向某个方向移动突然后退呢？</p>
<p>平台可以突然像反方向倾斜</p>
</blockquote>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415130644058.png" alt="image-20240415130644058"></p>
<p>提前预知可能会反方向</p>
<p>总体代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#计时</span><br><span class="line">运行时间=(系统运行时间()-计时)/<span class="number">1000</span></span><br><span class="line">计时=系统运行时间()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> n in range(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">    偏差量[n]=日标量[n]-小球位置[n]</span><br><span class="line">        </span><br><span class="line">    比例P[n]=偏差量[n]*比例P系数[n]</span><br><span class="line">        </span><br><span class="line">    积分I[n]=积分I[n]+偏差量[n]*积分I系数[n]*运行时间</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> 积分I[n]&gt;积分I最大值[n]:</span><br><span class="line">		积分I[n]=积分I最大值[n]</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>:积分I[n]&lt;-积分I最大值[n]:</span><br><span class="line">		积分I[n]=-积分I最大值[n]</span><br><span class="line">            </span><br><span class="line">    微分D[n]=(偏差量[n]-上一次偏差量[n])*微分D系数[n]/运行时间</span><br><span class="line">    上一次偏差量[n]=偏差量[n]</span><br><span class="line">            </span><br><span class="line">    执行量[n]=比例P[n]+积分I[n]+微分D[n]</span><br></pre></td></tr></table></figure>

<p>由于x和y轴需要分别控制，这里使用了for循环来表示xy轴</p>
<h4 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h4><blockquote>
<p>要如何确定比例P系数，积分I系数，微分D系数</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">大了</th>
<th align="center">小了</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P</td>
<td align="center">超出目标</td>
<td align="center">达不到目标</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">超出目标，系统迟钝</td>
<td align="center">小幅度偏差不能回正</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">高频抖动</td>
<td align="center">超出目标</td>
</tr>
</tbody></table>
<p>一般都是先P</p>
<h1 id="使用L298N电机驱动模块来对电机调速，实现PID速度环"><a href="#使用L298N电机驱动模块来对电机调速，实现PID速度环" class="headerlink" title="使用L298N电机驱动模块来对电机调速，实现PID速度环"></a>使用L298N电机驱动模块来对电机调速，实现PID速度环</h1><p>首先我是从大鱼电子那里要来的资料的，源码也包括了，之后我会更新一下这个PID速度闭环的具体的实现原理，stm32学了这么久，只会用但里面的深层原理还不是很明白</p>
]]></content>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言单向链表</title>
    <url>/2024/01/03/c%E8%AF%AD%E8%A8%80%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>跟python一样又完全不一样，一样的是思路一样，不一样的是一个用结构体加结构体指针，一个用数组。</p>
<h1 id="链表的增删改查"><a href="#链表的增删改查" class="headerlink" title="链表的增删改查"></a>链表的增删改查</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">head</span>=</span><span class="literal">NULL</span>,*pnew,*ptail;</span><br><span class="line">    <span class="comment">/**空链表建立头节点**/</span></span><br><span class="line">    pnew=(<span class="keyword">struct</span> student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> student));<span class="comment">/*开辟内存空间*/</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,pnew-&gt;name,pnew-&gt;score);</span><br><span class="line">    head=pnew;<span class="comment">/*第一个节点要用头指针指着*/</span></span><br><span class="line">    ptail=pnew;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在现有的链表添加新节点，此处可以用for循环*/</span></span><br><span class="line">    pnew=(<span class="keyword">struct</span> student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> student));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,pnew-&gt;name,pnew-&gt;score);</span><br><span class="line">    ptail-&gt;next=pnew;<span class="comment">/*连接两个节点*/</span></span><br><span class="line">    ptail=pnew;<span class="comment">/*末节点滚到新的位置*/</span></span><br><span class="line">    ptail-&gt;next=<span class="literal">NULL</span>;<span class="comment">/*将末节点的下一位赋值*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*遍历链表，可以用for循环*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span>;</span></span><br><span class="line">    p=head;<span class="comment">/*从head开始遍历*/</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s%d&quot;</span>,p-&gt;name,p-&gt;score);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在链表中插入节点，假设链表里的成绩是从高到低排列的，插入后也是如此*/</span></span><br><span class="line">    p=head;<span class="comment">/*便于之后找插入位置辅助节点*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">pold</span>;</span></span><br><span class="line">    pnew=(<span class="keyword">struct</span> student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> student));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,pnew-&gt;name,pnew-&gt;score);</span><br><span class="line">    <span class="keyword">if</span>(pnew-&gt;score&gt;head-&gt;score)&#123;</span><br><span class="line">        pnew-&gt;next=head;</span><br><span class="line">        head=pnew;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;score&gt;pnew-&gt;score)&#123;</span><br><span class="line">            pold=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;<span class="comment">/*遍历完成之后p的前一项pold是要插入的节点*/</span></span><br><span class="line">        <span class="comment">/*连接*/</span></span><br><span class="line">        pnew-&gt;next=p;</span><br><span class="line">        pold-&gt;next=pnew;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*删除节点,删除Liming的数据,要用free函数解放空间*/</span></span><br><span class="line">    <span class="type">char</span> xname=<span class="string">&quot;Liming&quot;</span>;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;name==xname)&#123;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p=head;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;name!=xname)&#123;</span><br><span class="line">            pold=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pold-&gt;next=p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="关于malloc和calloc函数"><a href="#关于malloc和calloc函数" class="headerlink" title="关于malloc和calloc函数"></a>关于malloc和calloc函数</h1><p>头文件是stdlib</p>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p><strong>用法</strong>：指针变量名&#x3D;（类型名*）malloc（要开辟的空间）</p>
<p>例子： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pnew=(<span class="keyword">struct</span> student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> student));</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *pStr[N];</span><br><span class="line">N=<span class="number">5</span>;</span><br><span class="line">pStr[i] = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));<span class="comment">/*为每个pStr开辟空间，从而可以在pStr[i]中get10位的字符*/</span></span><br></pre></td></tr></table></figure>

<h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><p><strong>用法</strong>：结构体指针变量名&#x3D;（结构体类型名*）calloc（要求分配空间个数，每个空间要求分配字节数）</p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>cs61a学习之旅-project 1</title>
    <url>/2024/01/01/cs61a%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-project-1/</url>
    <content><![CDATA[<p>今天是学习cs61a的第一天，也是提交project 1 的最后一天（看我极限操作）。面对全英文的教学还是有点压力的。首先学的是python。</p>
<h1 id="一些计算机英语词汇"><a href="#一些计算机英语词汇" class="headerlink" title="一些计算机英语词汇"></a>一些计算机英语词汇</h1><p>Terminal: 终端</p>
<p>Text Editor：文本编辑器（或称文字编辑器）是用作编写普通文字的<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/216367?fromModule=lemma_inlink">应用软件</a>，它与文档编辑器（或称文字处理器）不同之处在于它并非用作<a href="https://baike.baidu.com/item/%E6%A1%8C%E9%9D%A2%E6%8E%92%E7%89%88/7724402?fromModule=lemma_inlink">桌面排版</a>（例如文档格式处理），它常用来编写程序的<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969?fromModule=lemma_inlink">源代码</a>。</p>
<p> interpreter:解释器</p>
<p>compiler：编译器</p>
<p>docstring: which is a description of what the function is supposed to do</p>
<p>doctest: It answers the question: “If we input this Python code, what should the expected output be?”</p>
<h1 id="一些新知"><a href="#一些新知" class="headerlink" title="一些新知"></a>一些新知</h1><p>编译器和解释器的区别：<a href="https://zhuanlan.zhihu.com/p/107382276">编译器和解释器各有什么特点与区别 - 知乎 (zhihu.com)</a></p>
<h1 id="what-can-python-do"><a href="#what-can-python-do" class="headerlink" title="what can python do?"></a>what can python do?</h1><p>在terminal中输入python</p>
<p>然后就可以直接使用用python语句了。</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240101165812577.png" alt="image-20240101165812577"></p>
<h1 id="Code-writing-questions"><a href="#Code-writing-questions" class="headerlink" title="Code-writing questions"></a>Code-writing questions</h1><p>打开vscode，接下来就是如何正确的写代码（规范格式）</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240101170019253.png" alt="image-20240101170019253"></p>
<p>docstring:解释代码作用（用三个双引号包住）</p>
<p>doctest：写代码输出</p>
<h1 id="开始任务"><a href="#开始任务" class="headerlink" title="开始任务"></a>开始任务</h1><h2 id="vscode连接github远程储存仓库"><a href="#vscode连接github远程储存仓库" class="headerlink" title="vscode连接github远程储存仓库"></a>vscode连接github远程储存仓库</h2><p>先在github上新建一个仓库，选择public，命名仓库</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240102220215550.png" alt="image-20240102220215550"></p>
<p>然后再选择ssh<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240102220551078.png" alt="image-20240102220551078"></p>
<p>新建一个项目的文件夹test，然后打开vscode—打开文件夹—打开test文件夹—源代码管理—初始化仓库，然后再文件夹建个文件。</p>
<p>到源代码管理中—右上角三个点—推送</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240102221836759.png" alt="image-20240102221836759"></p>
<p>添加远程储存库</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240102222045384.png" alt="image-20240102222045384"></p>
<p>把这个url输入到里面</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240102222138885.png" alt="image-20240102222138885"></p>
<p>然后就连接成功了</p>
<h2 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h2><p>点击加号暂存修改，然后再消息中输入关于此次修改的信息</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240102222437395.png" alt="image-20240102222437395"></p>
<p>然后提交与推送就ok了</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240102223514770.png" alt="image-20240102223514770"></p>
<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><p>高中的时候毕竟学过python，首考的时候考了99也放了，到现在已经有一年时间没学了，幸亏python非常容易上手和简洁，现在写hog的任务还算顺畅，hog有很多def，你只要完成每个def就行了。前面几个def还算简单，到后面有几个是高中没学过的：</p>
]]></content>
      <tags>
        <tag>cs61a</tag>
      </tags>
  </entry>
  <entry>
    <title>casbin模型</title>
    <url>/2024/05/18/casbin/</url>
    <content><![CDATA[<p> 在写项目的时候遇到了一些问题，在之前的权限控制中，我只会使用if之类的语句来验证每个人的身份，来确定他们是否有操作权限，这样不是很美观，所以可以学习一下casbin这个强大的开源库来控制访问，接下来以go为例子</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>先了解一些定义：</p>
<p><code>policy</code>是策略或者说是规则的定义。它定义了具体的规则。</p>
<p><code>request</code>是对访问请求的抽象，它与<code>e.Enforce()</code>函数的参数是一一对应的</p>
<p><code>matcher</code>匹配器会将请求与定义的每个<code>policy</code>一一匹配，生成多个匹配结果。</p>
<p><code>effect</code>根据对请求运用匹配器得出的所有结果进行汇总，来决定该请求是<strong>允许</strong>还是<strong>拒绝</strong>。</p>
<p>这个就是casbin的一些控制原理：</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240519112512746.png" alt="image-20240519112512746"></p>
<h1 id="ACL（access-control-list，访问控制列表）"><a href="#ACL（access-control-list，访问控制列表）" class="headerlink" title="ACL（access-control-list，访问控制列表）"></a>ACL（access-control-list，访问控制列表）</h1><h2 id="编写模型文件和策略文件"><a href="#编写模型文件和策略文件" class="headerlink" title="编写模型文件和策略文件"></a>编写模型文件和策略文件</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[request_definition]</span><br><span class="line">r = sub, obj, act</span><br><span class="line"></span><br><span class="line">[policy_definition]</span><br><span class="line">p = sub, obj, act</span><br><span class="line"></span><br><span class="line">[matchers]</span><br><span class="line">m = r.sub == p.sub &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</span><br><span class="line"></span><br><span class="line">[policy_effect]</span><br><span class="line">e = some(where (p.eft == allow))</span><br></pre></td></tr></table></figure>

<p>权限由<code>sub,obj,act</code>三要素组成，只有在策略列表中有和它完全相同的策略时，该请求才能通过。匹配器的结果可以通过<code>p.eft</code>获取，<code>some(where (p.eft == allow))</code>表示只要有一条策略允许即可。</p>
<p>然后我们策略文件（比如dajun可以对data1进行read操作）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">p, dajun, data1, read</span><br><span class="line">p, lizi, data2, write</span><br></pre></td></tr></table></figure>

<h2 id="使用代码"><a href="#使用代码" class="headerlink" title="使用代码"></a>使用代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e *casbin.Enforcer, sub, obj, act <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  ok, _ := e.Enforce(sub, obj, act)</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s CAN %s %s\n&quot;</span>, sub, act, obj)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s CANNOT %s %s\n&quot;</span>, sub, act, obj)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  e, err := casbin.NewEnforcer(<span class="string">&quot;./model.conf&quot;</span>, <span class="string">&quot;./policy.csv&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;NewEnforecer failed:%v\n&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check(e, <span class="string">&quot;dajun&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>)</span><br><span class="line">  check(e, <span class="string">&quot;lizi&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;write&quot;</span>)</span><br><span class="line">  check(e, <span class="string">&quot;dajun&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;write&quot;</span>)</span><br><span class="line">  check(e, <span class="string">&quot;dajun&quot;</span>, <span class="string">&quot;data2&quot;</span>, <span class="string">&quot;read&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子比较简单，首先创建一个<code>casbin.Enforcer</code>对象,加载模型文件和策略文件，调用Enforce的方法来检查权限</p>
<p>运行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dajun CAN read data1</span><br><span class="line">lizi CAN write data2</span><br><span class="line">dajun CANNOT write data1</span><br><span class="line">dajun CANNOT read data2</span><br></pre></td></tr></table></figure>

<h2 id="添加超级管理员"><a href="#添加超级管理员" class="headerlink" title="添加超级管理员"></a>添加超级管理员</h2><p><code>ACL</code>显示定义了每个主体对每个资源的权限情况，未定义的就没有权限。我们还可以加上超级管理员，超级管理员可以进行任何操作。假设超级管理员为<code>root</code>，我们只需要修改匹配器：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[matchers]</span><br><span class="line">e = r.sub == p.sub &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act || r.sub == &quot;root&quot;</span><br></pre></td></tr></table></figure>

<p>只要访问主体是<code>root</code>一律放行。</p>
<h1 id="RBAC-模型"><a href="#RBAC-模型" class="headerlink" title="RBAC 模型"></a>RBAC 模型</h1><p>ACL只适合用户和资源比较少的情况下，多的话就要用</p>
<p><code>RBAC</code>（role-based-access-control）模型通过引入角色（<code>role</code>）这个中间层来解决这个问题。每个用户都可以有自己的角色，这样减少分类。</p>
<p>在<code>casbin</code>中使用<code>RBAC</code>模型需要在模型文件中添加<code>role_definition</code>模块：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[role_definition]</span><br><span class="line">g = _, _</span><br><span class="line"></span><br><span class="line">[matchers]</span><br><span class="line">m = g(r.sub, p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</span><br></pre></td></tr></table></figure>

<p><code>g = _,_</code>定义了用户——角色，角色——角色的映射关系，前者是后者的成员，拥有后者的权限。然后在匹配器中，我们只需要使用<code>g(r.sub, p.sub)</code>来判断请求主体<code>r.sub</code>是否属于<code>p.sub</code>这个角色即可。最后我们修改策略文件添加用户——角色定义：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">p, admin, data, read</span><br><span class="line">p, admin, data, write</span><br><span class="line">p, developer, data, read</span><br><span class="line">g, dajun, admin</span><br><span class="line">g, lizi, developer</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>casbin</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机</title>
    <url>/2024/02/29/51%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[<p> 开始智能车之旅前的一小练习，其实在玩过stm32之后才发现51单片机还是非常简单的</p>
<h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><p>单片机，英文Micro ControllerUnit，简称MCU内部集成了CPU、RAM、ROM、定时器、中断系统、通讯接口等一系列电脑的常用硬件功能<br>单片机的任务是信息采集(依靠传感器)、处理(依靠CPU)和硬件设备(例如电机，LED等)的控制单片机跟计算机相比，单片机算是一个袖珍版计算机，一个芯片就能构成完整的计算机系统。但在性能上，与计算机相差甚远，但单片机成本低、体积小、结构简单，在生活和工业控制领域大有所用同时，学习使用单片机是了解计算机原理与结构的最佳选择</p>
<h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><p>单片机的使用领域已十分广泛，如智能仪表、实时工控、通讯设备导航系统、家用电器等。各种产品一旦用上了单片机，就能起到使产品升级换代的功效，常在产品名称前冠以形容词“智能型”如智能型洗衣机等</p>
<h2 id="51单片机"><a href="#51单片机" class="headerlink" title="51单片机"></a>51单片机</h2><p>51单片机是对所有兼容Inte18031指令系统的单片机的统称。该系列单片机的始祖是Intel的8004单片机，后来随着Flash rom技术的发展，8004单片机取得了长足的进展，成为应用最广泛的8位单片机之一，其代表型号是ATMEL公司的AT89系列，它广泛应用于工业测控系统之中。很多公司都有51系列的兼容机型推出，今后很长的一段时间内将占有大量市场。51单片机是基础入门的一个单片机，还是应用最广泛的一种。需要注意的是51系列的单片机一般不具备自编程能力。</p>
<h2 id="STC89C52单片机"><a href="#STC89C52单片机" class="headerlink" title="STC89C52单片机"></a>STC89C52单片机</h2><p>所属系列:51单片机系列公司:STC公司<br>位数:8位<br>RAM:512字节<br>ROM:8K(Flash)<br>工作频率:12MHz(本开发板使用)</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240229091351793.png" alt="image-20240229091351793"></p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240229092111625.png" alt="image-20240229092111625"></p>
<p> 模块原理图：C:\Users\HUAWEI\Desktop\智能车\51单片机\开发板资料包\HC6800-ES V2.0.zip\HC6800-ES V2.0\开发板原理图</p>
<h1 id="开始步骤"><a href="#开始步骤" class="headerlink" title="开始步骤"></a>开始步骤</h1><p>打开keil5，新建project，在keilproject中新建项目对应文件夹，进入文件夹命名project保存<img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240229104823101.png" alt="image-20240229104823101"></p>
<p>选择Atmel的AT89c52确定，弹窗选否 </p>
<p>右键Source Group 1新建c语言文件夹，命名为main。</p>
<p>头文件#include &lt;REGX52.H&gt;</p>
<p>编写代码完成之后，点击build，在这之前把创建HEX打开</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240229112945649.png" alt="image-20240229112945649"></p>
<p>stc-isp打开，连接单片机到电脑，选择<strong>正确</strong>的串口</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240229113200097.png" alt="image-20240229113200097"></p>
<p>打开程序文件，选择对应项目文件夹的HEX文件，下载编程，打开单片机开关</p>
<h2 id="程序为什么要放在while里面"><a href="#程序为什么要放在while里面" class="headerlink" title="程序为什么要放在while里面"></a>程序为什么要放在while里面</h2><p>将程序放在while循环中的目的是为了实现程序的持续执行。</p>
<p>在嵌入式系统中，程序一般只会被执行一次，然后就会停止。但是在实际的应用中，我们通常需要程序能够持续地执行某些任务或者实时地响应外部的事件。这就需要使用循环来让程序重复执行，以实现持续性的功能。</p>
<p>在你提供的代码中，将程序放在while循环中，使得程序会不断地检测P3_1口的状态，并根据状态来控制P2_1口的输出。如果P3_1口为低电平（按键按下），则P2_1口输出低电平；如果P3_1口为高电平（按键释放），则P2_1口输出高电平。通过将程序放在while循环中，可以实现对按键状态的实时监测和相应的输出控制。</p>
<p>总结来说，将程序放在while循环中是为了使程序能够持续地执行，以实现某些功能的持续性、实时性或者循环性。</p>
<h2 id="C51数据运算"><a href="#C51数据运算" class="headerlink" title="C51数据运算"></a>C51数据运算</h2><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240229125637025.png" alt="image-20240229125637025"></p>
<h1 id="stc-isp工具"><a href="#stc-isp工具" class="headerlink" title="stc-isp工具"></a>stc-isp工具</h1><p>延时计算器：</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240229110557257.png" alt="image-20240229110557257"></p>
<p>把指令集改成Y1，时间改成毫秒,系统频率改为12</p>
<p>这里可以定时长度，复制代码，在main上面粘贴，添加&lt;INTRINS.H&gt;头文件就可以直接用这个函数了。</p>
<h1 id="按键操作"><a href="#按键操作" class="headerlink" title="按键操作"></a>按键操作</h1><p>根据开发板原理图，，每个按钮对应如下图</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240229123012244.png" alt="image-20240229123012244"></p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240229123418246.png" alt="image-20240229123418246"></p>
<p>按下K1后亮，松手灭。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(P3_1==<span class="number">0</span>)&#123;</span><br><span class="line">				P2_1=<span class="number">0</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				P2_1=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="按键消抖"><a href="#按键消抖" class="headerlink" title="按键消抖"></a>按键消抖</h2><p>按下松开之后亮                                                              </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>	<span class="comment">//@12.000MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line">	<span class="keyword">while</span>(xms)&#123;</span><br><span class="line">		i = <span class="number">2</span>;</span><br><span class="line">		j = <span class="number">239</span>;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (--j);</span><br><span class="line">		&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">		xms--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(P3_1==<span class="number">0</span>)&#123;</span><br><span class="line">				Delay(<span class="number">20</span>);<span class="comment">//按下与松开时候要delay</span></span><br><span class="line">				<span class="keyword">while</span>(P3_1==<span class="number">0</span>);<span class="comment">//一直按住</span></span><br><span class="line">				Delay(<span class="number">20</span>);</span><br><span class="line">				P2_0=~P2_0;<span class="comment">//取反</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在Delay中终止运行"><a href="#在Delay中终止运行" class="headerlink" title="在Delay中终止运行"></a>在Delay中终止运行</h2><p>之前可能不知道，后来才意识到程序的大部分时间都是在delay中进行的，因此在delay中设置终止条件才是可能的，但是delay中不能用delay消抖，因此我在前面有嵌入了一个delay20ms来专门控制消抖的delay</p>
<p>按下K1启动流水灯，再按一下关闭。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;MATH.H&gt;</span></span></span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay20ms</span><span class="params">(<span class="type">void</span>)</span>	<span class="comment">//@12.000MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">234</span>;</span><br><span class="line">	j = <span class="number">115</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>	<span class="comment">//@12.000MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line">	<span class="keyword">while</span>(xms)&#123;</span><br><span class="line">		i = <span class="number">2</span>;</span><br><span class="line">		j = <span class="number">239</span>;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (--j);</span><br><span class="line">		&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">		xms--;</span><br><span class="line">		<span class="keyword">if</span>(P3_1==<span class="number">0</span>)&#123;</span><br><span class="line">			Delay20ms();</span><br><span class="line">			<span class="keyword">while</span>(P3_1==<span class="number">0</span>);</span><br><span class="line">			Delay20ms();</span><br><span class="line">			flag=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">waterfall_light</span><span class="params">()</span>&#123;</span><br><span class="line">	flag=<span class="number">0</span>;</span><br><span class="line">	P2=<span class="number">0xFE</span>;</span><br><span class="line">	Delay(<span class="number">500</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		P2=(P2&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">		Delay(<span class="number">500</span>);</span><br><span class="line">		<span class="keyword">if</span>(P2==<span class="number">0x7F</span>)&#123;</span><br><span class="line">			P2=<span class="number">0xFE</span>;</span><br><span class="line">			Delay(<span class="number">500</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">		P2=<span class="number">0xFF</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(P3_1==<span class="number">0</span>)&#123;</span><br><span class="line">				Delay20ms();</span><br><span class="line">				<span class="keyword">while</span>(P3_1==<span class="number">0</span>);</span><br><span class="line">				Delay20ms();</span><br><span class="line">				<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">					waterfall_light();</span><br><span class="line">					<span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">						P2=<span class="number">0xFF</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h1><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240301155542256.png" alt="image-20240301155542256"></p>
<p>.c文件:函数、变量的定义</p>
<p>.h文件:可被外部调用的函数、变量的声明<br>任何自定义的变量、函数在调用前必须有定义或声明(同一个.c)使用到的自定义函数的.c文件必须添加到工程参与编译使用到的.h文件必须要放在编译器可寻找到的地方(工程文件夹根目录、安装目录、自定义)</p>
<p>如果想要在项目文件夹中看到h文件可以右键Source Group，添加已有文件，然后选择全部文件，再add。</p>
<h1 id="LCD1602"><a href="#LCD1602" class="headerlink" title="LCD1602"></a>LCD1602</h1><p>在课程源码中有函数库，仔细阅读源码，可以发现原理</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240301195138487.png" alt="image-20240301195138487"></p>
<p>阅读源码要注意的点</p>
<ul>
<li><code>brief</code>：简要说明函数的作用或功能。</li>
<li><code>param</code>：说明函数的参数及其含义。在这个标签后面列出了每个函数参数的名称和说明。</li>
<li><code>retval</code>：描述函数的返回值的含义或取值范围。</li>
</ul>
<h1 id="定时器系统"><a href="#定时器系统" class="headerlink" title="定时器系统"></a>定时器系统</h1><p>作用：可以用于实现软件计时，使程序每隔一段时间实现操作</p>
<p>可以替代长时间的delay，提高CPU的运行效率和处理速度</p>
<p>想我之前研究出的在delay中的流水灯，在delay中加入跳出条件会十分麻烦</p>
<p>有三个定时器，T0，T1，T2，其中T0 and T1 与传统51单片机兼容</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>STC89C52系列单片机内部设置的两个16位定时器&#x2F;计数器T0和T1都具有计数方式和定时方式两种工作方式。对每个定时器&#x2F;计数器(T0和T1)，在特殊功能寄存器TMOD中都有一控制位一C&#x2F;T来选择TO或T1为定时器还是计数器。定时器&#x2F;计数器的核心部件是一个加法(也有减法)的计数器，其本质是对脉冲进行计数。只是计数脉冲来源不同:如果计数脉冲来自系统时钟，则为定时方式，此时定时器&#x2F;计数器每12个时钟或者每6个时钟得到一个计数脉冲，计数值加1:如果计数脉冲来自单片机外部引脚(TO为P3.4,T1为P3.5)，则为计数方式，每来一个脉冲加1。</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240302104902702.png" alt="image-20240302104902702"></p>
<p>具体可以查看手册第七章 C:\Users\HUAWEI\Desktop\智能车\51单片机\课件及程序源码\相关资料.zip\相关资料</p>
<h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><p>​	中断系统是为使CPU具有对外界紧急事件的实时处理能力而设置的。当中央处理机CPU正在处理某件事的时候外界发生了紧急事件请求，要求CPU暂停当前的工作，转而去处理这个紧急事件，处理完以后，再回到原来被中断的地方，继续原来的工作，这样的过程称为中断。实现这种功能的部件称为中断系统，请示CPU中断的请求源称为中断源。微型机的中断系统一般允许多个中断源，当几个中断源同时向CPU请求中断，要求为它服务的时候，这就存在CPU优先响应哪一个中断源请求的问题。通常根据中断源的轻重缓急排队，优先处理最紧急事件的中断请求源，即规定每一个中断源有一个优先级别。CPU总是先响应优先级别最高的中断请求。<br>​	当CPU正在处理一个中断源请求的时候(执行相应的中断服务程序)，发生了另外一个优先级比它还高的中断源请求。如果CPU能够暂停对原来中断源的服务程序，转而去处理优先级更高的中断请求源，处理完以后，再回到原低级中断服务程序，这样的过程称为中断嵌套。这样的中断系统称为多级中断系统，没有中断嵌套功能的中断系统称为单级中断系统。</p>
<p>有时候，中断系统类似于一种多线程，比如在其他任务进行的过程中sec++，最好不要把复杂的任务放在中断函数当中。</p>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240301210640494.png" alt="image-20240301210640494"></p>
<h2 id="流水系统"><a href="#流水系统" class="headerlink" title="流水系统"></a>流水系统</h2><p>定时器配置，尤其注意右上角的配置<img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240302120301463.png" alt="image-20240302120301463"></p>
<p><code>	AUXR &amp;= 0x7F;			//定时器时钟12T模式</code>记得把这句删掉</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Init</span><span class="params">(<span class="type">void</span>)</span>		<span class="comment">//1毫秒@12.000MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	TMOD &amp;= <span class="number">0xF0</span>;			<span class="comment">//设置定时器模式</span></span><br><span class="line">	TMOD |= <span class="number">0x01</span>;			<span class="comment">//设置定时器模式</span></span><br><span class="line">	TL0 = <span class="number">0x18</span>;				<span class="comment">//设置定时初始值</span></span><br><span class="line">	TH0 = <span class="number">0xFC</span>;				<span class="comment">//设置定时初始值</span></span><br><span class="line">	TF0 = <span class="number">0</span>;				<span class="comment">//清除TF0标志</span></span><br><span class="line">	TR0 = <span class="number">1</span>;				<span class="comment">//定时器0开始计时</span></span><br><span class="line">	ET0=<span class="number">1</span>; <span class="comment">//中断配置</span></span><br><span class="line">	EA=<span class="number">1</span>;</span><br><span class="line">	PT0=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定时器初始化 (<code>Timer0_Init</code>) 函数</strong>:</p>
<ol>
<li><code>TMOD &amp;= 0xF0;</code>：清除TMOD寄存器的低四位（用于控制定时器0的模式）。这是为了将定时器0的工作模式设置为模式1，即16位计数器模式。<code>&amp;= 0xF0</code>操作确保了TMOD寄存器的高四位（控制定时器1）保持不变。</li>
<li><code>TMOD |= 0x01;</code>：在清除低四位之后，通过<code>|= 0x01</code>给定时器0设置了工作模式1。</li>
<li><code>TL0 = 0x18;</code> 及 <code>TH0 = 0xFC;</code>：设置定时器的初始计数值。定时器的计数由TH0和TL0寄存器组成的16位数值递增，当这个值从<code>0xFC18</code>递增到<code>0xFFFF</code>后，会溢出并从<code>0x0000</code>开始重新计数，此时定时器0的溢出标志TF0会被置位。</li>
<li><code>TF0 = 0;</code>：清除定时器溢出标志TF0，以确保它不会影响定时器的启动。</li>
<li><code>TR0 = 1;</code>：设置TR0位，使定时器0开始计时。</li>
<li><code>ET0=1;</code>：使能定时器0的中断。</li>
<li><code>EA=1;</code>：使能（或允许）全局中断。</li>
<li><code>PT0=0;</code>：设置定时器0中断的优先级为低。</li>
</ol>
<p>·其中TL0 and TH0的设置会决定一定时间内中断的次数，上面的设置使下面的中断器一毫秒中断一次，也就是一毫秒执行一遍下面的程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1<span class="comment">//中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> T0Count;<span class="comment">//静态，本函数引用，退出函数时不丢失数据</span></span><br><span class="line">	TL0 =<span class="number">0x18</span>;<span class="comment">//设定定时初值</span></span><br><span class="line">	TH0=<span class="number">0xFC</span>;</span><br><span class="line">	T0Count++;</span><br><span class="line">	<span class="keyword">if</span>(T0Count&gt;<span class="number">1000</span>)&#123;</span><br><span class="line">		T0Count=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title="&lt;INTRINS.H&gt;"></a>&lt;INTRINS.H&gt;</h2><p><code>&lt;INTRINS.H&gt;</code> 是一个针对 Keil C 编译器的头文件，它为 8051 微控制器提供了一系列的内置函数。这些函数通常是一些简单的指令，它们是用汇编语言编写的，可以直接访问 CPU 的某些特殊功能，比如 NOP（无操作）、开关中断等。它们在嵌入式系统的编程中非常有用，因为这些操作通常是实现硬件控制和优化代码性能的关键。</p>
<p>以下是一些常见的 <code>&lt;INTRINS.H&gt;</code> 中定义的内置函数及其用法：</p>
<ol>
<li><code>_nop_()</code>：执行一个无操作（NOP）指令，基本上是用来插入一个CPU周期的延迟。</li>
<li><code>_cror_()</code>：循环右移操作，将寄存器内容循环右移指定的位数。</li>
<li><code>_crol_()</code>：循环左移操作，将寄存器内容循环左移指定的位数。</li>
<li><code>_get_()</code>：从SFR（特殊功能寄存器）中读取值。</li>
<li><code>_put_()</code>：向SFR写入值。</li>
<li><code>_clrbit_()</code>：清除（置0）特定位。</li>
<li><code>_setbit_()</code>：设置（置1）特定位。</li>
<li><code>_testbit_()</code>：测试特定位是否被设置。</li>
<li><code>_pop_()</code>：从栈中弹出一个字节。</li>
<li><code>_push_()</code>：向栈中压入一个字节。</li>
<li><code>_disgint_()</code>：禁用全局中断。</li>
<li><code>_enaint_()</code>：启用全局中断。</li>
<li><code>_bset_()</code>：置位一个字节中的特定位。</li>
<li><code>_bclr_()</code>：清除一个字节中的特定位。</li>
<li><code>_bdset_()</code>：置位一个位地址变量。</li>
<li><code>_bdclr_()</code>：清除一个位地址变量。</li>
<li><code>_bp_()</code>：置位一个位地址变量，并在几个机器周期后自动清除。</li>
</ol>
<p>具体的函数内容要看头文件中函数的参数</p>
<h1 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h1><p>蜂鸣器是一种将电信号转换为声音信号的器件，常用来产生设备的按键音、报警音等提示信号蜂鸣器按驱动方式可分为有源蜂鸣器和无源蜂鸣器<br>有源蜂鸣器:内部自带振荡源，将正负极接上直流电压即可持续发声，频率固定<br>无源蜂鸣器:内部不带振荡源，需要控制器提供振荡脉冲才可发声调整提供振荡脉冲的频率，可发出不同频率的声音</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240302160251482.png" alt="image-20240302160251482"></p>
<p>P2_5控制蜂鸣器，注意新版的不同</p>
<h1 id="LED呼吸灯"><a href="#LED呼吸灯" class="headerlink" title="LED呼吸灯"></a>LED呼吸灯</h1><p>原理：通过延长明暗的时间来调整LED的亮度</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240303130257353.png" alt="image-20240303130257353"></p>
<h1 id="重要提醒"><a href="#重要提醒" class="headerlink" title="重要提醒"></a>重要提醒</h1><p>不要再中断器里面添加循环</p>
<p>中断器时间设置太快会导致按键延迟</p>
<h1 id="AD模数转换（Analog-to-Digital）"><a href="#AD模数转换（Analog-to-Digital）" class="headerlink" title="AD模数转换（Analog to Digital）"></a>AD模数转换（Analog to Digital）</h1><p>首先要明白的是，ADC的模块并不属于单片机，因此他需要SPI传输协议来与单片机相互传输数据</p>
<h2 id="ADC模块"><a href="#ADC模块" class="headerlink" title="ADC模块"></a>ADC模块</h2><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240305191006215.png" alt="image-20240305191006215"></p>
<p><strong>CS (Chip Select)</strong>: CS信号用于选择或激活外部ADC芯片。当多个外设通过SPI（串行外设接口）或其他通信协议与单片机连接时，CS信号可以用来指定当前通信的是哪一个外设。<strong>在通信开始前，CS信号通常被拉低，以选中特定的ADC芯片；通信结束后，CS信号被拉高，以取消选中。</strong></p>
<p><strong>DIN (Data Input)</strong>: DIN是<strong>数据输入</strong>信号线，用于从单片机向ADC芯片发送数据或命令。在ADC转换过程中，DIN可能用于配置ADC的工作模式、启动转换过程或选择</p>
<p>DOUT：<strong>数据输出</strong>信号。这是从外部ADC模块传输到单片机的数据路径。</p>
<p><strong>DCLK（Data Clock）</strong>：通常指的是数据时钟信号，在与外部ADC模块通信时用于同步数据的传输。对于没有内置ADC模块的51单片机系统，当使用串行通信接口（如SPI）与外部ADC进行通信时，DCLK信号是至关重要的。</p>
<p>在串行通信协议（如SPI）中，单片机通过DIN（Data Input）线向ADC发送指令，ADC处理这些指令后，可能需要将转换结果或其他数据通过DOUT线发送回单片机。在SPI协议中，DOUT对应的可能是MISO（Master In Slave Out）信号，即主设备输入、从设备输出。</p>
<p>通信时，单片机会提供DCLK（Data Clock）信号，用于同步数据的读取。在DCLK的每个时钟周期，数据会从ADC的DOUT引脚移位出来，单片机通过其对应的接收引脚来读取这些数据。这个过程通常在单片机的CS（Chip Select）信号激活ADC芯片后进行。</p>
<p>在SPI通信中，数据的接收和发送都是同步进行的，即使在单片机发送配置指令给ADC时，ADC的DOUT线也可能在每个DCLK时钟周期输出数据，但这些数据通常在配置阶段不被单片机使用。当ADC开始数据转换并且单片机需要读取结果时，DOUT线上传输的数据才是重要的，单片机会在适当的时钟边沿捕获这些数据。</p>
<h2 id="XPT2046"><a href="#XPT2046" class="headerlink" title="XPT2046"></a>XPT2046</h2><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240305192525700.png" alt="image-20240305192525700"></p>
<p>SPI通信：</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240305185934224.png" alt="image-20240305185934224"></p>
<p>CS:我想和谁通信，我就可以选中谁</p>
<p>首先片选，其次DCLK上升沿输入数据，下降沿输出数据，同时DIN和DOUT同时工作。这样经历8位之后就会与单片机的八位的寄存器进行交换，就可以实现通信了。之后就可以连续不断的发送数据了，通信之后再把CS拉高就好了</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240305194610081.png" alt="image-20240305194610081"></p>
<h3 id="控制字"><a href="#控制字" class="headerlink" title="控制字"></a>控制字</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240306155840710.png" alt="image-20240306155840710"></p>
<p>SERDFR：在此开发板内X-Y-直接接地，所以直接使用单端模式</p>
<p>PD1PD0：如果PD1是1，内部参考电压2.5，电位器一半刻度就会满，因此最好选择外部电压0.PD0.</p>
<p>在这个程序里面的command：1 A2A1A0 1&#x2F;0 1 0 0</p>
<p>但SERDFR为1时</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240306163207908.png" alt="image-20240306163207908"></p>
<p>XP就是X+（positive）测变阻器电压 +in表示就可以测什么，</p>
<p>VBAT测电池电压</p>
<p>当SERDFR为0时</p>
<h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><p>串口是一种应用十分广泛的通讯接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信。I单片机的串口可以使单片机与单片机、单片机与电脑、单片机与各式各样的模块互相通信，极大的扩展了单片机的应用范围，增强了单片机系统的硬件实力。</p>
<p>51单片机内部自带UART(UniversalAsynchronous ReceiverTransmitter，通用异步收发器)，可实现单片机的串口通信</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240310123901339.png" alt="image-20240310123901339"></p>
<h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><p>51单片机（如Intel的8051系列单片机）通常内置有一个UART（Universal Asynchronous Receiver&#x2F;Transmitter，通用异步收发传输器）模块，这个模块使得单片机能够通过串行通信与其他设备进行数据交换。</p>
<p>UART通信标准是基于异步串行通信协议，它不需要时钟同步信号，因为发送方和接收方各自使用独立的时钟，只要两者的波特率（数据传输速率）匹配，就能够正确地进行数据传输。</p>
<p>51单片机的UART特点：</p>
<ol>
<li><strong>异步通信</strong>：数据的发送和接收是异步的，即没有单独的时钟线来同步发送和接收方。</li>
<li><strong>可编程波特率</strong>：UART模块可以通过编程来设置波特率，波特率是通过定时器或直接配置UART的特殊功能寄存器来实现。</li>
<li><strong>起始位和停止位</strong>：每个数据字节通常以一个起始位开始，后跟8个数据位，然后是可选的奇偶校验位，最后是一个或两个停止位。</li>
<li><strong>全双工通信</strong>：51单片机的UART允许同时进行发送和接收操作，即可以进行全双工通信。</li>
<li><strong>寄存器</strong>：51单片机的UART通信主要通过几个特殊功能寄存器来控制，例如SCON（串行控制寄存器），用于控制UART模式、波特率以及接收传输的控制；SBUF（串行数据缓冲器），用于存储正在发送或接收的数据字节。</li>
<li><strong>中断</strong>：UART模块通常有与之相关的中断，当发送或接收完成时，可以触发中断来通知CPU处理数据。</li>
<li><strong>串行通信引脚</strong>：51单片机的UART使用专门的引脚，通常是P3.0（RXD）和P3.1（TXD）作为接收和发送数据的线路。</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240310124935283.png" alt="image-20240310124935283"></li>
</ol>
<p>一般采用模式一</p>
<h2 id="开始（发送数据到电脑）"><a href="#开始（发送数据到电脑）" class="headerlink" title="开始（发送数据到电脑）"></a>开始（发送数据到电脑）</h2><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240310122011821.png" alt="image-20240310122011821"></p>
<p>还有一个波特率要改为4800</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240310125344262.png" alt="image-20240310125344262"></p>
<p>我们先把八位的数据发到上面的SBUF上，然后通过控制门来到达TXD，然后从RXD接受数据，通过移位寄存器来到下面的SBUF上，想要这个数据直接把数据的缓存读出来就行了。每次发送一位数据的时候，就会触发中断函数。</p>
<h3 id="配置到模式一的工作状态"><a href="#配置到模式一的工作状态" class="headerlink" title="配置到模式一的工作状态"></a>配置到模式一的工作状态</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240310140452047.png" alt="image-20240310140452047"></p>
<p>发送数据无需中断的相关的寄存器，所以IE IPH IP不用配置</p>
<h4 id="SCON"><a href="#SCON" class="headerlink" title="SCON"></a>SCON</h4><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240310134554906.png" alt="image-20240310134554906"></p>
<p>SM1&#x2F;SM0:0&#x2F;1</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240310134946776.png" alt="image-20240310134946776"></p>
<p>REN：</p>
<p>允许&#x2F;禁止串行接收控制位。由软件置位REN，即REN&#x3D;1为允许串行接收状态，可启动串行接收器RxD，开始接收信息。软件复位REN，即REN&#x3D;0，则禁止接收。接受电脑数据设为1，电脑接受数据设为0.</p>
<p>TB8&#x2F;RB8：由于是接受第九位数据，所以我们不管它。</p>
<p>TI：发送中断请求标志位。在方式0，当串行发送数据第8位结束时，由内部硬件自动置位，即TI&#x3D;1，向主机请求中断，响应中断后必须用软件复位，即T&#x3D;0。在其他方式中，则在停止位开始发送时由内部硬件置位，必须用软件复位。可以用于检测数据是否发送完。</p>
<p>初始化配置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span>&#123;</span><br><span class="line">	SCON=<span class="number">0x40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240310135916427.png" alt="image-20240310135916427"></p>
<h4 id="PCON电源控制寄存器"><a href="#PCON电源控制寄存器" class="headerlink" title="PCON电源控制寄存器"></a>PCON电源控制寄存器</h4><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240310140427507.png" alt="image-20240310140427507"></p>
<h4 id="配置波特率"><a href="#配置波特率" class="headerlink" title="配置波特率"></a>配置波特率</h4><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240310143951516.png" alt="image-20240310143951516"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span>&#123;</span><br><span class="line">	SCON=<span class="number">0x40</span>;<span class="comment">//这个是自己算的</span></span><br><span class="line">	</span><br><span class="line">	PCON |= <span class="number">0x80</span>;		<span class="comment">//使能波特率倍速位SMOD</span></span><br><span class="line">	TMOD &amp;= <span class="number">0x0F</span>;			<span class="comment">//设置定时器模式</span></span><br><span class="line">	TMOD |= <span class="number">0x20</span>;			<span class="comment">//设置定时器模式</span></span><br><span class="line">	TL1 = <span class="number">0xF4</span>;			<span class="comment">//设置定时初始值</span></span><br><span class="line">	TH1 = <span class="number">0xF4</span>;			<span class="comment">//设置定时重载值</span></span><br><span class="line">	ET1 = <span class="number">0</span>;			<span class="comment">//禁止定时器中断</span></span><br><span class="line">	TR1 = <span class="number">1</span>;			<span class="comment">//定时器1开始计时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="发送数据到电脑上"><a href="#发送数据到电脑上" class="headerlink" title="发送数据到电脑上"></a>发送数据到电脑上</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">UART_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Byte)</span>&#123;</span><br><span class="line">	SBUF=Byte;<span class="comment">//由于SBUF在左边，所以是在写数据</span></span><br><span class="line">	<span class="keyword">while</span>(TI==<span class="number">0</span>);<span class="comment">//检测TI等于1表示读完了数据</span></span><br><span class="line">	TI=<span class="number">0</span>;<span class="comment">//要手动重置TI</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="UART的模块化文件"><a href="#UART的模块化文件" class="headerlink" title="UART的模块化文件"></a>UART的模块化文件</h3><h4 id="UART-c"><a href="#UART-c" class="headerlink" title="UART.c"></a>UART.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span>&#123;</span><br><span class="line">	SCON=<span class="number">0x40</span>;</span><br><span class="line">	</span><br><span class="line">	PCON |= <span class="number">0x80</span>;		<span class="comment">//使能波特率倍速位SMOD</span></span><br><span class="line">	TMOD &amp;= <span class="number">0x0F</span>;			<span class="comment">//设置定时器模式</span></span><br><span class="line">	TMOD |= <span class="number">0x20</span>;			<span class="comment">//设置定时器模式</span></span><br><span class="line">	TL1 = <span class="number">0xF4</span>;			<span class="comment">//设置定时初始值</span></span><br><span class="line">	TH1 = <span class="number">0xF4</span>;			<span class="comment">//设置定时重载值</span></span><br><span class="line">	ET1 = <span class="number">0</span>;			<span class="comment">//禁止定时器中断</span></span><br><span class="line">	TR1 = <span class="number">1</span>;			<span class="comment">//定时器1开始计时</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Byte)</span>&#123;</span><br><span class="line">	SBUF=Byte;<span class="comment">//由于SBUF在左边，所以是在写数据</span></span><br><span class="line">	<span class="keyword">while</span>(TI==<span class="number">0</span>);<span class="comment">//检测TI等于1表示读完了数据</span></span><br><span class="line">	TI=<span class="number">0</span>;<span class="comment">//要手动重置TI</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="UART-h"><a href="#UART-h" class="headerlink" title="UART.h"></a>UART.h</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __UART_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __UART_H__</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Byte)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>





<h2 id="电脑控制LED"><a href="#电脑控制LED" class="headerlink" title="电脑控制LED"></a>电脑控制LED</h2><p>因为我们不知道电脑是什么时候发送数据的，所以在中断系统要一直检测，需要配置中断器，在中断函数里处理数据</p>
<h3 id="改造Init函数"><a href="#改造Init函数" class="headerlink" title="改造Init函数"></a>改造Init函数</h3><p>把REN改为1</p>
<p>SCON&#x3D;0x50</p>
<p>要配置IE IPH IP</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span>&#123;</span><br><span class="line">	SCON=<span class="number">0x50</span>;</span><br><span class="line">	</span><br><span class="line">	PCON |= <span class="number">0x80</span>;		<span class="comment">//使能波特率倍速位SMOD</span></span><br><span class="line">	TMOD &amp;= <span class="number">0x0F</span>;			<span class="comment">//设置定时器模式</span></span><br><span class="line">	TMOD |= <span class="number">0x20</span>;			<span class="comment">//设置定时器模式</span></span><br><span class="line">	TL1 = <span class="number">0xF4</span>;			<span class="comment">//设置定时初始值</span></span><br><span class="line">	TH1 = <span class="number">0xF4</span>;			<span class="comment">//设置定时重载值</span></span><br><span class="line">	ET1 = <span class="number">0</span>;			<span class="comment">//禁止定时器中断</span></span><br><span class="line">	TR1 = <span class="number">1</span>;			<span class="comment">//定时器1开始计时</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	EA=<span class="number">1</span>;		<span class="comment">//中断函数</span></span><br><span class="line">	ES=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main函数里面的中断函数要加上终端号码</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240310152917780.png" alt="image-20240310152917780"></p>
<p>这个地方是interrupt 4</p>
<p>串口在接受到数据之后，硬件会自动把R1&#x3D;1，R1或者T1&gt;&#x3D;1，那么就会触发中断，进而可以在中断器里面接收到数据。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>P3_6与P3^6有什么区别</p>
<p>PWM比较数不能是小数？</p>
]]></content>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言常用函数，占位符</title>
    <url>/2024/01/11/c%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在考试的时候，有一个非常好用的函数可以达到事半功倍的效果，但是自己常常会忘记文件头以及对应函数怎么写。这里我将列出几个可供参考的函数</p>
<h2 id="include"><a href="#include" class="headerlink" title="#include&lt;stdio.h&gt;"></a>#include&lt;stdio.h&gt;</h2><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><h2 id="include-1"><a href="#include-1" class="headerlink" title="#include&lt;string.h&gt;"></a>#include&lt;string.h&gt;</h2><p>有些对字符数组的操作只能使用这些函数</p>
<h4 id="1-字符串复制函数strcpy"><a href="#1-字符串复制函数strcpy" class="headerlink" title="1.字符串复制函数strcpy"></a>1.字符串复制函数strcpy</h4><p><code>char *strcpy(char *s1,char *s2)</code></p>
<p>从c位置开始（包括 c）往后面加“water”，会覆盖原有数据，<strong>而且会在你输入的数据之后加“\0”!</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">11</span>]=<span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(c,<span class="string">&quot;rain &quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(c+<span class="number">5</span>,<span class="string">&quot;water&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(c);</span><br></pre></td></tr></table></figure>

<p>结果是rain water</p>
<h4 id="2-字符串连接函数strcat"><a href="#2-字符串连接函数strcat" class="headerlink" title="2.字符串连接函数strcat"></a>2.字符串连接函数strcat</h4><p><code>char *strcat(char *s1,char *s2)</code></p>
<p>直接在s1的位置后面链接s2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">20</span>]=<span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(c,<span class="string">&quot;rain &quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(c);</span><br></pre></td></tr></table></figure>

<p>结果是0123456789rain </p>
<h4 id="3-字符串比较函数strcmp"><a href="#3-字符串比较函数strcmp" class="headerlink" title="3.字符串比较函数strcmp"></a>3.字符串比较函数strcmp</h4><p><code>int strcmp(char *s1,char *s2)</code></p>
<p>当结果&#x3D;&#x3D;0，s1&#x3D;s2</p>
<p>当结果&gt;0,     s1&gt;s2</p>
<p>当结果&lt;0,     s2&gt;s1</p>
<h4 id="4-字符串长度函数strlen"><a href="#4-字符串长度函数strlen" class="headerlink" title="4.字符串长度函数strlen"></a>4.字符串长度函数strlen</h4><p><code>unsigned int strlen(char *s1)</code></p>
<p>返回值为”\0”前的长度</p>
<h2 id="include-2"><a href="#include-2" class="headerlink" title="#include&lt;ctype.h&gt;"></a>#include&lt;ctype.h&gt;</h2><h4 id="1-字符检测函数isascii"><a href="#1-字符检测函数isascii" class="headerlink" title="1.字符检测函数isascii"></a>1.字符检测函数isascii</h4><p><code>int isascii(x)</code></p>
<p>x为字符：返回非0</p>
<p>x为非字符：返回0</p>
<h4 id="2-数字检测函数isdigit"><a href="#2-数字检测函数isdigit" class="headerlink" title="2.数字检测函数isdigit"></a>2.数字检测函数isdigit</h4><p><code>int isdigit (x)</code></p>
<p>x为数字：返回非0</p>
<p>x为非数字：返回0</p>
<h4 id="3-英文字符检测函数isalpha"><a href="#3-英文字符检测函数isalpha" class="headerlink" title="3.英文字符检测函数isalpha"></a>3.英文字符检测函数isalpha</h4><p><code>int isalpha(x)</code></p>
<p>x为英文字符：大写返回1,小写返回2</p>
<p>x为非英文字符：返回0</p>
<h2 id="include-3"><a href="#include-3" class="headerlink" title="#include&lt;stdlib.h&gt;"></a>#include&lt;stdlib.h&gt;</h2><p>见<a href="https://jaketmoon.github.io/2024/01/07/c%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/">c语言文件操作 | Jaketmoon の 博客</a></p>
<h2 id="include-4"><a href="#include-4" class="headerlink" title="#include&lt;math.h&gt;"></a>#include&lt;math.h&gt;</h2><p>1.绝对值函数fabs（x）</p>
<p>2.开平方函数sqrt（x）</p>
<p>3.向上取整函数floor(x)·</p>
<p>·+ 4.向下取整函数ceil(x)</p>
<h1 id="常用占位符"><a href="#常用占位符" class="headerlink" title="常用占位符"></a>常用占位符</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%d:十进制整数。</span><br><span class="line">%i:整数，基本等同于%d。</span><br><span class="line">%f:小数（包含 <span class="type">float</span> 类型和 <span class="type">double</span>类型) 。</span><br><span class="line">%Lf: <span class="type">long</span> <span class="type">double</span>类型浮点。</span><br><span class="line">%p:指针。</span><br><span class="line">%s:字符串。</span><br><span class="line">%%:输出一个百分号。</span><br><span class="line">%c:字符。</span><br><span class="line">%ld:十进制 <span class="type">long</span> <span class="type">int</span>类型。</span><br><span class="line">%lld:十进制 <span class="type">long</span> <span class="type">long</span>类型。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言指针</title>
    <url>/2024/01/14/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>作为c语言里面最抽象的一块内容，还是有必要出一块专题的</p>
<h1 id="指针与整形"><a href="#指针与整形" class="headerlink" title="指针与整形"></a>指针与整形</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pa;</span><br><span class="line"><span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">*pa=&amp;x;</span><br></pre></td></tr></table></figure>

<p>或者直接<code>int *pa=&amp;x</code></p>
<h2 id="指针作为函数参数"><a href="#指针作为函数参数" class="headerlink" title="指针作为函数参数"></a>指针作为函数参数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">( <span class="type">int</span> a,<span class="type">int</span> *b)</span>&#123;</span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    *b=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">5</span>,y=<span class="number">5</span>;</span><br><span class="line">    fun(x,&amp;y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是x&#x3D;5,*b&#x3D;10</p>
<p>得出结论：形参改变不了实参，但是用地址操作的时候可以</p>
<h2 id="指针与一维数组"><a href="#指针与一维数组" class="headerlink" title="指针与一维数组"></a>指针与一维数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,*p;</span><br><span class="line">p=a;<span class="comment">/*或者p=&amp;a[0]*/</span></span><br></pre></td></tr></table></figure>





<h3 id="引用数组元素"><a href="#引用数组元素" class="headerlink" title="引用数组元素"></a>引用数组元素</h3><p>1.指针法：*（a+1）</p>
<p>2.下标法 a[1]</p>
<h3 id="一维数组作为参数"><a href="#一维数组作为参数" class="headerlink" title="一维数组作为参数"></a>一维数组作为参数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sum(<span class="type">int</span> *b,<span class="type">int</span> n)&#123;</span><br><span class="line">    <span class="comment">/*此时的b为a数组*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    sum(a,<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h2><p><code>int a[3][4]=1</code></p>
<p>实际上是：</p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言文件操作</title>
    <url>/2024/01/07/c%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>所有程序在实现过程中，变量通过占用内存单元来储存数据，运行结束之后，这些储存单元都会被撤销。那么如何使结果保存呢？</p>
<h2 id="这个是完整的代码"><a href="#这个是完整的代码" class="headerlink" title="这个是完整的代码"></a>这个是完整的代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">int</span> n,i=<span class="number">0</span>;</span><br><span class="line">    fp=fopen(<span class="string">&quot;D:\\work\\code\\c\\File\\sushu.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">/*fopen表示打开文件，r表示文件已存在并且以只读方式来打开文件*/</span></span><br><span class="line">    <span class="keyword">while</span>(!feof(fp))&#123;<span class="comment">/*没有feof的话循环*/</span></span><br><span class="line">        <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">/*格式化读取fp的值，每次读一个数据就往后移动一位*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>,n);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            i=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);<span class="comment">/*断开与File*类型变量与文件之间的关系*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见打开文件的方式："><a href="#常见打开文件的方式：" class="headerlink" title="常见打开文件的方式："></a>常见打开文件的方式：</h2><p>1.<code>FILE *fopen(char *filename,char *mode)</code></p>
<p>成功就为FILE类型结构体变量的首地址，失败则为NULL</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240109162324941.png" alt="image-20240109162324941"></p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240109162355282.png" alt="image-20240109162355282"></p>
<p>注意点：</p>
<ol>
<li>“w”模式打开文件，假如有同名文件，那么会清除掉，没有该文件，那么会自动创建一个，与r和a不同</li>
<li>可读写方式是指完成文件操作之后，移动文件读写指针到文件头，又可以读该文件</li>
<li>用追加模式打开之后fp指向文件的末尾</li>
</ol>
<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*函数原型*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>

<p>若结果为0则表示被正常关闭，非0值表示出错</p>
<h2 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h2><h3 id="字符读写"><a href="#字符读写" class="headerlink" title="字符读写"></a>字符读写</h3><p><strong>1.<code>int fgetc(FILE *fp)</code></strong></p>
<p>读取单个字符，必须以读方式打开。返回值为ASCII码，若读到文件末尾符号（最后一个数据后面一位）返回值为EOF（-1）</p>
<p>读完之后向后移一个字节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">c=fgetc(*fp);<span class="comment">/*常用*/</span></span><br><span class="line">fgetc(<span class="built_in">stdin</span>);<span class="comment">/*从键盘读取*/</span></span><br></pre></td></tr></table></figure>

<p><strong>2.<code>int fputc(char ch,FILE *fp)</code></strong></p>
<p>向fp所指的位置写入一个字符</p>
<p>一般用法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fputc(ch,fp);</span><br><span class="line">fputc(c,<span class="built_in">stdout</span>);<span class="comment">/*显示屏显示*/</span></span><br></pre></td></tr></table></figure>

<p>3.<code>feof**（*fp）</code></p>
<p>若到文件结尾为非0值</p>
<p><strong>4.<code>char *fgets（char *str,int n,FILE *fp）</code></strong></p>
<p>从当前读取位置读入n-1个字符串（包括换行符和文件结束标志，读到他们时终止），并且在末尾添加\0</p>
<p>操作成功返回str首地址，失败则返回NULL</p>
<p><strong>5.<code>int fputs(char *str,FILE *fp)</code></strong></p>
<p>向文件中写入字符串str不包括\0</p>
<p>操作成功返回最后一个字符的ASCII码，否则返回0</p>
<h3 id="格式化读写"><a href="#格式化读写" class="headerlink" title="格式化读写"></a>格式化读写</h3><p>1.<code>int fscanf(FILE *fp,char *format,地址列表)</code></p>
<p>从文件读取数据，自动移动到下一位</p>
<p>2.<code>int fprintf(FILE *fp,char *format,输出表)</code></p>
<p>向文件传入数据，自动移动到下一位</p>
<p>两者返回值都为参数数量</p>
<h3 id="二进制文件的数据块读写"><a href="#二进制文件的数据块读写" class="headerlink" title="二进制文件的数据块读写"></a>二进制文件的数据块读写</h3><p>常用于需要一次性读取一个数据块的时候</p>
<p>1.<code>int fread(T *a,long sizeof(T),unsigned int n,FILE *fp)</code></p>
<p>从fp位置，复制n*sizeof（T）个字节到a所指向的内存区域</p>
<p>返回值为n或0（读到文件结尾）</p>
<p>2.<code>int fwrite(T *a,long sizeof(T),unsigned int n,FILE *fp)</code></p>
<p>从a位置，复制n*sizeof（T）个字节到fp所指向的内存区域</p>
<p>返回值是n</p>
<p>ex1:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> f[<span class="number">2</span>];</span><br><span class="line">fread(f,<span class="keyword">sizeof</span>(<span class="type">float</span>),<span class="number">2</span>,fp);</span><br></pre></td></tr></table></figure>

<p>从文件中读两个实数存入f[0]and f[1]中</p>
<p>ex2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;stu[<span class="number">40</span>];</span><br><span class="line"><span class="comment">/*假设结构体数组已经存放了数据*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++)&#123;</span><br><span class="line">    fwrite(&amp;stu[i],<span class="keyword">sizeof</span>(<span class="keyword">struct</span> student),<span class="number">1</span>,fp)</span><br><span class="line">&#125;<span class="comment">/*读到文件里*/</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++)&#123;</span><br><span class="line">    fread(&amp;stu[i],<span class="keyword">sizeof</span>(<span class="keyword">struct</span> student),<span class="number">1</span>,fp)</span><br><span class="line">&#125;<span class="comment">/*从文件里取出放入结构体之中*/</span> </span><br><span class="line"><span class="comment">/*the same as*/</span></span><br><span class="line">fread(stu,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> student),<span class="number">40</span>,fp)</span><br></pre></td></tr></table></figure>

<h2 id="文件定位函数"><a href="#文件定位函数" class="headerlink" title="文件定位函数"></a>文件定位函数</h2><p>1.<code>void rewind(FILE *fp)</code></p>
<p>移动fp到文件头</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stalib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">    FILE *fp1, *fp2;</span><br><span class="line">	<span class="keyword">if</span>( (fp1=fopen (<span class="string">&quot;lou. txt&quot;</span>, <span class="string">&quot;r&quot;</span>)) ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Can&#x27;t open this file! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">        ｝</span><br><span class="line">	<span class="keyword">if</span> （fp2=fopen （<span class="string">&quot;lj.c，&quot;</span>w<span class="string">&quot;））==NULL）&#123;</span></span><br><span class="line"><span class="string">        printf (&quot;</span>Can<span class="number">&#x27;</span>t open this file! \n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">		exit (1);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    while (!feof (fp1))</span></span><br><span class="line"><span class="string">    	putchar (fgetc (fp1)) ;/*先输出到屏幕*/</span></span><br><span class="line"><span class="string">    rewind (fp1) ;</span></span><br><span class="line"><span class="string">    while (!feof (ip1))</span></span><br><span class="line"><span class="string">    	fputc（ fgetc （fp1），fp2）；</span></span><br><span class="line"><span class="string">    fclose (fp1) ;</span></span><br><span class="line"><span class="string">    fclose (fp2) ;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>



<p>2.<code>int fseek(FILE *fp,long n,unsigned switch)</code></p>
<p>移动fp，n为移动的字节数，n为正则向文件尾部移动，负数的话反之</p>
<p>switch决定移动起点位置：</p>
<table>
<thead>
<tr>
<th align="center">switch</th>
<th align="center">起始位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0(SEEK_SET)</td>
<td align="center">文件头</td>
</tr>
<tr>
<td align="center">1(SEEK_CUR)</td>
<td align="center">当前指针位置</td>
</tr>
<tr>
<td align="center">2(SEEK_END)</td>
<td align="center">文件末尾</td>
</tr>
</tbody></table>
<p>移动成功则返回0；否则返回非0</p>
<p>3.<code>long ftell(FILE *fp)</code></p>
<p>返回文件读写位置到文件首字节的字节数，成功为0</p>
<h2 id="文件操作出错检测"><a href="#文件操作出错检测" class="headerlink" title="文件操作出错检测"></a>文件操作出错检测</h2><p>1.<code>int ferror(FILE *stream)</code></p>
<p>返回值为0表示未出错</p>
<p>注意：对同一个文件进行操作的时候，ferror的值会变。</p>
<p>2.<code>void clearerr(FILE *stream)</code></p>
<p>是文件错误标志和文件结束标志返回值为0，比如ferror返回一个非零值，可以调用clearer（fp）使其的值变为0</p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言的一些巧妙算法</title>
    <url>/2024/01/17/c%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A7%E5%A6%99%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="大整数"><a href="#大整数" class="headerlink" title="大整数"></a>大整数</h2><h3 id="函数接口定义："><a href="#函数接口定义：" class="headerlink" title="函数接口定义："></a>函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print_Factorial</span> <span class="params">( <span class="type">const</span> <span class="type">int</span> N )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>N</code>是用户传入的参数，其值不超过1000。如果<code>N</code>是非负整数，则该函数必须在一行中打印出<code>N</code>!的值，否则打印“Invalid input”。</p>
<h3 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print_Factorial</span> <span class="params">( <span class="type">const</span> <span class="type">int</span> N )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="built_in">Print_Factorial</span>(N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure>

<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1307674368000</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Print_Factorial</span><span class="params">(<span class="type">const</span> <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid input\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span> || N == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result[<span class="number">3000</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">/*result用于逆向储存整数的字符*/</span></span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;<span class="comment">/*len用于储存整数的长度*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>; <span class="comment">/**/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;<span class="comment">/*这个循环让每一位result上面的数字乘上i，如果这个数字乘上i之后大于10.那么多余的位数会储存到carry中，在下一位计算的时候，加到下一位的乘好的数字上*/</span></span><br><span class="line">            <span class="type">int</span> temp = result[j] * i + carry;<span class="comment">/*temp是这个位置乘上i的数字*/</span></span><br><span class="line">            result[j] = temp % <span class="number">10</span>;</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (carry &gt; <span class="number">0</span>) &#123;<span class="comment">/*这个循环让上个循环结束之后剩下的carry增加result的位数*/</span></span><br><span class="line">            result[len] = carry % <span class="number">10</span>;</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result[i]);<span class="comment">/*最后逆向输出result*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个字符数组储存整数的时候的可以类比一下自己在列竖式计算的时候所做的换位</p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>docker使用教学</title>
    <url>/2024/02/16/docker%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%A6/</url>
    <content><![CDATA[<p> 来源：<a href="https://docker.easydoc.net/doc/81170005/cCewZWoN/lTKfePfP">🎉 Docker 简介和安装 - Docker 快速入门 - 易文档 (easydoc.net)</a></p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="用处：打包、分发、部署"><a href="#用处：打包、分发、部署" class="headerlink" title="用处：打包、分发、部署"></a>用处：打包、分发、部署</h3><p><strong>打包</strong>：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包<br><strong>分发</strong>：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装<br><strong>部署</strong>：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows&#x2F;Mac&#x2F;Linux。</p>
<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>桌面版：<a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a><br>服务器版：<a href="https://docs.docker.com/engine/install/#server">https://docs.docker.com/engine/install/#server</a></p>
<h2 id="在docker上安装软件"><a href="#在docker上安装软件" class="headerlink" title="在docker上安装软件"></a>在docker上安装软件</h2><h3 id="演示-Docker-安装-Redis"><a href="#演示-Docker-安装-Redis" class="headerlink" title="演示 Docker 安装 Redis"></a>演示 Docker 安装 Redis</h3><p>Redis 官网：<a href="https://redis.io/">https://redis.io/</a></p>
<blockquote>
<p>官网下载安装教程只有源码安装方式，没有 Windows 版本。想要自己安装 windows 版本需要去找别人编译好的安装包。</p>
</blockquote>
<p>Docker 官方镜像仓库查找 Redis ：<a href="https://hub.docker.com/">https://hub.docker.com/</a><br><img src="https://cos.easydoc.net/46901064/files/kv8zs4qr.png" alt="Docker镜像官网"></p>
<p>一个命令跑起来：<code>docker run -d -p 6379:6379 --name redis redis:latest</code><br>命令参考：<a href="https://docs.docker.com/engine/reference/commandline/run/">https://docs.docker.com/engine/reference/commandline/run/</a></p>
<p><img src="https://cos.easydoc.net/46901064/files/kv8zy4xn.png" alt="Docker运行Redis后"></p>
<h3 id="安装-Wordpress"><a href="#安装-Wordpress" class="headerlink" title="安装 Wordpress"></a>安装 Wordpress</h3><p>docker-compose.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释version: &#x27;3.1&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  wordpress:</span><br><span class="line">    image: wordpress</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">    environment:</span><br><span class="line">      WORDPRESS_DB_HOST: db</span><br><span class="line">      WORDPRESS_DB_USER: exampleuser</span><br><span class="line">      WORDPRESS_DB_PASSWORD: examplepass</span><br><span class="line">      WORDPRESS_DB_NAME: exampledb</span><br><span class="line">    volumes:</span><br><span class="line">      - wordpress:/var/www/html</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_DATABASE: exampledb</span><br><span class="line">      MYSQL_USER: exampleuser</span><br><span class="line">      MYSQL_PASSWORD: examplepass</span><br><span class="line">      MYSQL_RANDOM_ROOT_PASSWORD: &#x27;1&#x27;</span><br><span class="line">    volumes:</span><br><span class="line">      - db:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  wordpress:</span><br><span class="line">  db:</span><br></pre></td></tr></table></figure>

<h3 id="安装-ELK"><a href="#安装-ELK" class="headerlink" title="安装 ELK"></a>安装 ELK</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 5601:5601 -p 9200:9200 -p 5044:5044 -it --name elk sebp/elk</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.microsoft.com/en-us/windows/wsl/wsl-config#global-configuration-options-with-wslconfig">内存不够解决方法</a><br>转到用户目录 <code>cd ~</code>，路径类似这个：<code>C:\Users\&lt;UserName&gt;</code><br>创建 <code>.wslconfig</code> 文件填入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">memory=10GB # Limits VM memory in WSL 2 to 4 GB</span><br><span class="line">processors=2 # Makes the WSL 2 VM use two virtual processors</span><br></pre></td></tr></table></figure>

<p>生效配置，命令行运行 <code>wsl --shutdown</code></p>
<h3 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h3><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止&#x2F;启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p>
<p><code>docker run -d -p 3307:3306 --name mysql -e MYSQL_USER=user -e MYSQL_ROOT_USER=root -e MYSQL_ROOT_PASSWORD=password -e MYSQL_PASSWORD=password -e MYSQL_DATABASE=mysql mysql:latest </code></p>
<p><code>docker pull mysql</code></p>
]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>git操作</title>
    <url>/2024/01/05/git%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p> 由于本文一开始写的时间比较早，所以在前面的vscode中可能处理问题的方式比较蠢，而且现在发现jetbrain的产品可以更好而且更加直观的处理冲突和版本控制(本人在vscode中开发的时候经常被冲突搞的很烦)</p>
<blockquote>
<p>所以还是推荐使用jet brain的产品</p>
</blockquote>
<h1 id="vscode的github上的操作"><a href="#vscode的github上的操作" class="headerlink" title="vscode的github上的操作"></a>vscode的github上的操作</h1><h2 id="vscode连接github远程储存仓库"><a href="#vscode连接github远程储存仓库" class="headerlink" title="vscode连接github远程储存仓库"></a>vscode连接github远程储存仓库</h2><p>先在github上新建一个仓库，选择public，命名仓库</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240102220215550.png" alt="image-20240102220215550"></p>
<p>然后再选择ssh<img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240102220551078.png" alt="image-20240102220551078"></p>
<p>新建一个项目的文件夹test，然后打开vscode—打开文件夹—打开test文件夹—源代码管理—初始化仓库，然后再文件夹建个文件。</p>
<p>到源代码管理中—右上角三个点—推送</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240102221836759.png" alt="image-20240102221836759"></p>
<p>添加远程储存库</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240102222045384.png" alt="image-20240102222045384"></p>
<p>把这个url输入到里面</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240102222138885.png" alt="image-20240102222138885"></p>
<p>然后就连接成功了</p>
<h2 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h2><p>点击加号暂存修改，然后再消息中输入关于此次修改的信息</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240102222437395.png" alt="image-20240102222437395"></p>
<p>然后提交与推送就ok了</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240102223514770.png" alt="image-20240102223514770"></p>
<h2 id="如何用vscode和别人协作开发"><a href="#如何用vscode和别人协作开发" class="headerlink" title="如何用vscode和别人协作开发"></a>如何用vscode和别人协作开发</h2><ol>
<li>获得别人的仓库地址：比如<a href="https://github.com/Echin-h/python_cc%EF%BC%8C%E5%9C%A8%E4%BB%96%E7%9A%84github%E4%B8%8Bfork%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%96%B0fork%EF%BC%8C%E6%88%91%E8%BF%99%E9%87%8C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E5%A5%BD%E4%BA%86![image-20240105155042962](http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240105155042962.png)">https://github.com/Echin-h/python_cc，在他的github下fork中创建自己的新fork，我这里已经建好了![image-20240105155042962](http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240105155042962.png)</a></li>
<li>gitclone你fork出来的仓库，在vscode中克隆你的仓库。<img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240105154434248.png" alt="image-20240105154434248"></li>
<li>然后就可以开始写里面的东西了，写完之后再按之前的步骤提交和推送。</li>
<li>最后在自己的fork下面open  pull request —create new request 填写好信息再creat new request 就ok了，在对方的 pull request 里面会收到request，他可以选择merge request来在项目中添加我的成分。<img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240105155717533.png" alt="image-20240105155717533"></li>
</ol>
<h1 id="git命令行操作"><a href="#git命令行操作" class="headerlink" title="git命令行操作"></a>git命令行操作</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone </span><br></pre></td></tr></table></figure>

<p>可以直接从github上拉取项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>go tour</title>
    <url>/2024/01/25/go-tour/</url>
    <content><![CDATA[<p> 记录一下，寒假开始真正系统的学习go语言</p>
<h1 id="go语言基本语法"><a href="#go语言基本语法" class="headerlink" title="go语言基本语法"></a>go语言基本语法</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数可以没有参数或接受多个参数。</p>
<p>在本例中，<code>swap</code> 接受两个 <code>string</code> 类型的参数。</p>
<p>注意类型在变量名 <strong>之后</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a, b := swap(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与c语言有共同之处，但是函数给出的返回值是处放在整个函数的最后面的</p>
<p>当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。</p>
<p>在本例中，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x string, y string</span><br></pre></td></tr></table></figure>

<p>被缩写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x, y string</span><br></pre></td></tr></table></figure>

<p>除此之外，没有参数的 <code>return</code> 语句返回已命名的返回值。也就是 <code>直接</code> 返回。</p>
<p>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">	x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">	y = sum - x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(split(<span class="number">17</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。</p>
<p>就像在这个例子中看到的一样，<code>var</code> 语句可以出现在包或函数级别。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i,j <span class="type">int</span> =<span class="number">1</span>,<span class="number">2</span><span class="comment">/*变量口语这样初始化*/</span></span><br><span class="line">	fmt.Println(i,j, c, python, java)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h3><p>在函数中，简洁赋值语句 <code>:=</code> 可在类型明确的地方代替 <code>var</code> 声明。</p>
<p>函数外的每个语句都必须以关键字开始（<code>var</code>, <code>func</code> 等等），因此 <code>:=</code> 结构不能在函数外使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">k := <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>另外，程序会根据右边数字的精度类型来确定其类型</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>Go 的基本类型有</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span></span><br><span class="line"><span class="type">uint</span> <span class="type">uint8</span> <span class="type">uint16</span> <span class="type">uint32</span> <span class="type">uint64</span> <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="comment">// uint8 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="type">rune</span> <span class="comment">// int32 的别名</span></span><br><span class="line">    <span class="comment">// 表示一个 Unicode 码点</span></span><br><span class="line"></span><br><span class="line"><span class="type">float32</span> <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="type">complex64</span> <span class="type">complex128</span></span><br></pre></td></tr></table></figure>

<p>本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。</p>
<p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/cmplx&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ToBe   <span class="type">bool</span>       = <span class="literal">false</span></span><br><span class="line">	MaxInt <span class="type">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">	z      <span class="type">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Type: %T Value: %v\n&quot;</span>, ToBe, ToBe)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Type: %T Value: %v\n&quot;</span>, MaxInt, MaxInt)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Type: %T Value: %v\n&quot;</span>, z, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Type: <span class="type">bool</span> Value: <span class="literal">false</span></span><br><span class="line">Type: <span class="type">uint64</span> Value: <span class="number">18446744073709551615</span></span><br><span class="line">Type: <span class="type">complex128</span> Value: (<span class="number">2</span>+<span class="number">3i</span>)</span><br></pre></td></tr></table></figure>





<h3 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h3><p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p>
<p>零值是：</p>
<ul>
<li>数值类型为 <code>0</code>，</li>
<li>布尔类型为 <code>false</code>，</li>
<li>字符串为 <code>&quot;&quot;</code>（空字符串）.</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</p>
<p>一些关于数值的转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var i int = 42</span><br><span class="line">var f float64 = float64(i)</span><br><span class="line">var u uint = uint(f)</span><br></pre></td></tr></table></figure>

<p>或者，更加简单的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i := 42</span><br><span class="line">f := float64(i)</span><br><span class="line">u := uint(f)</span><br></pre></td></tr></table></figure>





<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量可以是任何形式，且不用声明类型，不能使用：&#x3D;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> World = <span class="string">&quot;世界&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello&quot;</span>, World)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Happy&quot;</span>, Pi, <span class="string">&quot;Day&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> Truth = <span class="literal">true</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Go rules?&quot;</span>, Truth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h2 id="Flow-control-statements"><a href="#Flow-control-statements" class="headerlink" title="Flow control statements"></a>Flow control statements</h2><h3 id="for-loop"><a href="#for-loop" class="headerlink" title="for loop"></a>for loop</h3><p> it has only one type of for loop,which is similar to C:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		sum += i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>we can also skip some of the components like this:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span>  sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">		sum += sum</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>this is why we call C’s <code>while</code> is spelled <code>for</code> in GO</p>
<p>infinite loop:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>Go’s <code>if</code> statements are like its <code>for</code> loops; the expression need not be surrounded by parentheses <code>( )</code> but the braces <code>&#123; &#125;</code> are required.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> sqrt(-x) + <span class="string">&quot;i&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(sqrt(<span class="number">2</span>), sqrt(<span class="number">-4</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>we can also add a short statement to execute before the condition.variables declared by the statement are only in scope until the end of the if and else.</p>
<p>calls to <code>pow</code>:对pow的调用</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>A <code>switch</code> statement is a shorter way to write a sequence of <code>if - else</code> statements. It runs the first case whose value is equal to the condition expression.</p>
<p><strong>2 difference from C:</strong></p>
<p>1.you dont need to use <code>break</code> statement after every conditon.</p>
<p>2.Go’s switch cases need not be constants, and the values involved need not be integers.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;Go runs on &quot;</span>)</span><br><span class="line">	<span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// freebsd, openbsd,</span></span><br><span class="line">		<span class="comment">// plan9, windows...</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Switch without a condition is the same as <code>switch true</code>.</p>
<p>This construct can be a clean way to write long if-then-else chains.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := time.Now()</span><br><span class="line">	<span class="keyword">switch</span> &#123;<span class="comment">/*the same as the switch 1*/</span></span><br><span class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h3><p>A defer statement defers the execution of a function until the surrounding function returns.</p>
<p>The deferred call’s arguments are evaluated immediately, but the function call is not executed until the surrounding function returns.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)<span class="comment">/*it is evaluated but not executed*/</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<h4 id="Stacking-defers"><a href="#Stacking-defers" class="headerlink" title="Stacking defers"></a>Stacking defers</h4><p>Deferred function calls are pushed onto a stack. When a function returns, its deferred calls are executed in last-in-first-out order.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">counting</span><br><span class="line">done</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>





<h2 id="More-types"><a href="#More-types" class="headerlink" title="More types"></a>More types</h2><h3 id="pointers"><a href="#pointers" class="headerlink" title="pointers"></a>pointers</h3><p>Go has pointers. A pointer holds the memory address of a value.</p>
<p>The type <code>*T</code> is a pointer to a <code>T</code> value. Its zero value is <code>nil</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var p *int</span><br></pre></td></tr></table></figure>

<p>The <code>&amp;</code> operator generates a pointer to its operand.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i := 42</span><br><span class="line">p = &amp;i</span><br></pre></td></tr></table></figure>

<p>The <code>*</code> operator denotes the pointer’s underlying value.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fmt.Println(*p) // read i through the pointer p</span><br><span class="line">*p = 21         // set i through the pointer p</span><br></pre></td></tr></table></figure>

<p>This is known as “dereferencing” or “indirecting”.</p>
<p><strong>Unlike C, Go has no pointer arithmetic.</strong></p>
<h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><p>A <code>struct</code> is a collection of fields.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="type">int</span></span><br><span class="line">	Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v:=Vertex&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">    v.X=<span class="number">4</span></span><br><span class="line">    fmt.Println(v.X)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Struct fields are accessed using a dot.</p>
<p>outcome:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span> <span class="number">2</span>&#125;</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="Pointers-to-structs"><a href="#Pointers-to-structs" class="headerlink" title="Pointers to structs"></a>Pointers to structs</h4><p>Struct fields can be accessed through a struct pointer.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="type">int</span></span><br><span class="line">	Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	p := &amp;v</span><br><span class="line">	p.X = <span class="number">1e9</span></span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Struct-Literals"><a href="#Struct-Literals" class="headerlink" title="Struct Literals"></a>Struct Literals</h4><p>A struct literal denotes a newly allocated struct value by listing the values of its fields.</p>
<p>You can list just a subset of fields by using the <code>Name:</code> syntax. (And the order of named fields is irrelevant.)</p>
<p>The special prefix <code>&amp;</code> returns a pointer to the struct value.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// has type Vertex</span></span><br><span class="line">	v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 is implicit</span></span><br><span class="line">	v3 = Vertex&#123;&#125;      <span class="comment">// X:0 and Y:0</span></span><br><span class="line">	p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// has type *Vertex</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(v1, p, v2, v3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span> <span class="number">2</span>&#125; &amp;&#123;<span class="number">1</span> <span class="number">2</span>&#125; &#123;<span class="number">1</span> <span class="number">0</span>&#125; &#123;<span class="number">0</span> <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>The type <code>[n]T</code> is an array of <code>n</code> values of type <code>T</code>.</p>
<p>The expression</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a [10]int</span><br></pre></td></tr></table></figure>

<p>declares a variable <code>a</code> as an array of ten integers.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">2</span>]<span class="type">string</span></span><br><span class="line">	a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">	a[<span class="number">1</span>] = <span class="string">&quot;World&quot;</span></span><br><span class="line">	fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">	fmt.Println(a)</span><br><span class="line"></span><br><span class="line">	primes := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">	fmt.Println(primes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Hello World</span><br><span class="line">[Hello World]</span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">11</span> <span class="number">13</span>]</span><br></pre></td></tr></table></figure>



<h3 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h3><p>it is dynamically-sized,more useful</p>
<p>A slice is formed by specifying two indices, a low and high bound, separated by a colon:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[low : high]</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	primes := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> s []<span class="type">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span> <span class="number">5</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p><strong>warning:</strong></p>
<p>A slice does not store any data, it just describes a section of an underlying array.</p>
<p>Changing the elements of a slice modifies the corresponding elements of its underlying array.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	names := [<span class="number">4</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;John&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Paul&quot;</span>,</span><br><span class="line">		<span class="string">&quot;George&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Ringo&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(names)</span><br><span class="line"></span><br><span class="line">	a := names[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">	b := names[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line">	b[<span class="number">0</span>] = <span class="string">&quot;XXX&quot;</span></span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">	fmt.Println(names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[John Paul George Ringo]</span><br><span class="line">[John Paul] [Paul George]</span><br><span class="line">[John XXX] [XXX George]</span><br><span class="line">[John XXX George Ringo]</span><br></pre></td></tr></table></figure>

<h4 id="Slice-literals"><a href="#Slice-literals" class="headerlink" title="Slice literals"></a>Slice literals</h4><p>A slice literal is like an array literal without the length.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	q := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">	fmt.Println(q)</span><br><span class="line"></span><br><span class="line">	r := []<span class="type">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>&#125;</span><br><span class="line">	fmt.Println(r)</span><br><span class="line"></span><br><span class="line">	s := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		i <span class="type">int</span></span><br><span class="line">		b <span class="type">bool</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;<span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;<span class="number">3</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">		&#123;<span class="number">5</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;<span class="number">7</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;<span class="number">11</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">		&#123;<span class="number">13</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">11</span> <span class="number">13</span>]</span><br><span class="line">[<span class="literal">true</span> <span class="literal">false</span> <span class="literal">true</span> <span class="literal">true</span> <span class="literal">false</span> <span class="literal">true</span>]</span><br><span class="line">[&#123;<span class="number">2</span> <span class="literal">true</span>&#125; &#123;<span class="number">3</span> <span class="literal">false</span>&#125; &#123;<span class="number">5</span> <span class="literal">true</span>&#125; &#123;<span class="number">7</span> <span class="literal">true</span>&#125; &#123;<span class="number">11</span> <span class="literal">false</span>&#125; &#123;<span class="number">13</span> <span class="literal">true</span>&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Slice-defaults"><a href="#Slice-defaults" class="headerlink" title="Slice defaults"></a>Slice defaults</h4><p>The default is zero for the low bound and the length of the slice for the high bound.</p>
<p>For the array</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a [10]int</span><br></pre></td></tr></table></figure>

<p>these slice expressions are equivalent:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[0:10]</span><br><span class="line">a[:10]</span><br><span class="line">a[0:]</span><br><span class="line">a[:]</span><br></pre></td></tr></table></figure>

<h4 id="Slice-length-and-capacity"><a href="#Slice-length-and-capacity" class="headerlink" title="Slice length and capacity"></a>Slice length and capacity</h4><p>A slice has both a <em>length</em> and a <em>capacity</em>.</p>
<p>The length of a slice is the number of elements it contains.</p>
<p>The capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice.</p>
<p>The length and capacity of a slice <code>s</code> can be obtained using the expressions <code>len(s)</code> and <code>cap(s)</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">	printSlice(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 截取切片使其长度为 0</span></span><br><span class="line">	s = s[:<span class="number">0</span>]</span><br><span class="line">	printSlice(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拓展其长度</span></span><br><span class="line">	s = s[:<span class="number">4</span>]</span><br><span class="line">	printSlice(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 舍弃前两个值</span></span><br><span class="line">	s = s[<span class="number">2</span>:]</span><br><span class="line">	printSlice(s)</span><br><span class="line">	</span><br><span class="line">	s=s[:<span class="number">4</span>]</span><br><span class="line">	printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">6</span> <span class="built_in">cap</span>=<span class="number">6</span> [<span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">11</span> <span class="number">13</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">6</span> []</span><br><span class="line"><span class="built_in">len</span>=<span class="number">4</span> <span class="built_in">cap</span>=<span class="number">6</span> [<span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">2</span> <span class="built_in">cap</span>=<span class="number">4</span> [<span class="number">5</span> <span class="number">7</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">4</span> <span class="built_in">cap</span>=<span class="number">4</span> [<span class="number">5</span> <span class="number">7</span> <span class="number">11</span> <span class="number">13</span>]</span><br></pre></td></tr></table></figure>

<p><strong>The zero value of a slice is <code>nil</code>.</strong></p>
<p>A nil slice has a length and capacity of 0 and has no underlying array.</p>
<h4 id="Creating-a-slice-with-make"><a href="#Creating-a-slice-with-make" class="headerlink" title="Creating a slice with make"></a>Creating a slice with make</h4><p>Slices can be created with the built-in <code>make</code> function; this is how you create dynamically-sized arrays.</p>
<p>The <code>make</code> function allocates a zeroed array and returns a slice that refers to that array:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a := make([]int, 5)  // len(a)=5,cap(a)=5</span><br></pre></td></tr></table></figure>

<p>To specify a capacity, pass a third argument to <code>make</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b := make([]int, 0, 5) // len(b)=0, cap(b)=5</span><br><span class="line"></span><br><span class="line">b = b[:cap(b)] // len(b)=5, cap(b)=5</span><br><span class="line">b = b[1:]      // len(b)=4, cap(b)=4</span><br></pre></td></tr></table></figure>

<h4 id="Slices-of-slices"><a href="#Slices-of-slices" class="headerlink" title="Slices of slices"></a>Slices of slices</h4><p>Slices can contain any type, including other slices.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Create a tic-tac-toe board.</span></span><br><span class="line">	board := [][]<span class="type">string</span>&#123;</span><br><span class="line">		[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">		[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">		[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The players take turns.</span></span><br><span class="line">	board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">	board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">	board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">	board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">	board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Appending-to-a-slice"><a href="#Appending-to-a-slice" class="headerlink" title="Appending to a slice"></a>Appending to a slice</h4><p>It is common to append new elements to a slice, and so Go provides a built-in <code>append</code> function. The <a href="https://go.dev/pkg/builtin/#append">documentation</a> of the built-in package describes <code>append</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func append(s []T, vs ...T) []T</span><br></pre></td></tr></table></figure>

<p>The first parameter <code>s</code> of <code>append</code> is a slice of type <code>T</code>, and the rest are <code>T</code> values to append to the slice.</p>
<p>The resulting value of <code>append</code> is a slice containing all the elements of the original slice plus the provided values.</p>
<p>If the backing array of <code>s</code> is too small to fit all the given values a bigger array will be allocated. The returned slice will point to the newly allocated array.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">	printSlice(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// append works on nil slices.</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">	printSlice(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The slice grows as needed.</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">	printSlice(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We can add more than one element at a time.</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">	printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">0</span> []</span><br><span class="line"><span class="built_in">len</span>=<span class="number">1</span> <span class="built_in">cap</span>=<span class="number">1</span> [<span class="number">0</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">2</span> <span class="built_in">cap</span>=<span class="number">2</span> [<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">6</span> [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>The <code>range</code> form of the <code>for</code> loop iterates over a slice or map.</p>
<p>When ranging over a slice, two values are returned for each iteration. The first is the index, and the second is a copy of the element at that index.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>**<span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">2</span>**<span class="number">1</span> = <span class="number">2</span></span><br><span class="line"><span class="number">2</span>**<span class="number">2</span> = <span class="number">4</span></span><br><span class="line"><span class="number">2</span>**<span class="number">3</span> = <span class="number">8</span></span><br><span class="line"><span class="number">2</span>**<span class="number">4</span> = <span class="number">16</span></span><br><span class="line"><span class="number">2</span>**<span class="number">5</span> = <span class="number">32</span></span><br><span class="line"><span class="number">2</span>**<span class="number">6</span> = <span class="number">64</span></span><br><span class="line"><span class="number">2</span>**<span class="number">7</span> = <span class="number">128</span></span><br></pre></td></tr></table></figure>

<p>You can skip the index or value by assigning to <code>_</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i, _ := range pow</span><br><span class="line">for _, value := range pow</span><br></pre></td></tr></table></figure>

<p>If you only want the index, you can omit the second variable.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i := range pow</span><br></pre></td></tr></table></figure>





<h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><p>A map maps keys to values.</p>
<p>The zero value of a map is <code>nil</code>. A <code>nil</code> map has no keys, nor can keys be added.</p>
<p>The <code>make</code> function returns a map of the given type, initialized and ready for use.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Vertex)</span><br><span class="line">	m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line">		<span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(m[<span class="string">&quot;Bell Labs&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Map-literals"><a href="#Map-literals" class="headerlink" title="Map literals"></a>Map literals</h4><p>Map literals are like struct literals, but the keys are required.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line">	<span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;</span><br><span class="line">		<span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;Google&quot;</span>: Vertex&#123;</span><br><span class="line">		<span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the top-level type is just a type name, you can omit it from the elements of the literal.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line">	<span class="string">&quot;Bell Labs&quot;</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">	<span class="string">&quot;Google&quot;</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mutating-Maps"><a href="#Mutating-Maps" class="headerlink" title="Mutating Maps"></a>Mutating Maps</h4><p>Insert or update an element in map <code>m</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m[key] = elem</span><br></pre></td></tr></table></figure>

<p>Retrieve an element:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elem = m[key]</span><br></pre></td></tr></table></figure>

<p>Delete an element:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete(m, key)</span><br></pre></td></tr></table></figure>

<p>Test that a key is present with a two-value assignment:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elem, ok = m[key]</span><br></pre></td></tr></table></figure>

<p>If <code>key</code> is in <code>m</code>, <code>ok</code> is <code>true</code>. If not, <code>ok</code> is <code>false</code>.</p>
<p>If <code>key</code> is not in the map, then <code>elem</code> is the zero value for the map’s element type.</p>
<p><strong>Note:</strong> If <code>elem</code> or <code>ok</code> have not yet been declared you could use a short declaration form:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elem, ok := m[key]</span><br></pre></td></tr></table></figure>

<h3 id="Function-values"><a href="#Function-values" class="headerlink" title="Function values"></a>Function values</h3><p>Functions are values too. They can be passed around just like other values.</p>
<p>Function values may be used as function arguments and return values.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="type">float64</span>, <span class="type">float64</span>)</span></span> <span class="type">float64</span>) <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">	fmt.Println(compute(hypot))</span><br><span class="line">	fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure>

<h3 id="Function-closures"><a href="#Function-closures" class="headerlink" title="Function closures"></a>Function closures</h3><p>Go functions may be closures. A closure is a function value that references variables from outside its body. The function may access and assign to the referenced variables; in this sense the function is “bound” to the variables.</p>
<p>For example, the <code>adder</code> function returns a closure. Each closure is bound to its own <code>sum</code> variable.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		sum += x</span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pos, neg := adder(), adder()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(</span><br><span class="line">			pos(i),</span><br><span class="line">			neg(<span class="number">-2</span>*i),</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">-2</span></span><br><span class="line"><span class="number">3</span> <span class="number">-6</span></span><br><span class="line"><span class="number">6</span> <span class="number">-12</span></span><br><span class="line"><span class="number">10</span> <span class="number">-20</span></span><br><span class="line"><span class="number">15</span> <span class="number">-30</span></span><br><span class="line"><span class="number">21</span> <span class="number">-42</span></span><br><span class="line"><span class="number">28</span> <span class="number">-56</span></span><br><span class="line"><span class="number">36</span> <span class="number">-72</span></span><br><span class="line"><span class="number">45</span> <span class="number">-90</span></span><br></pre></td></tr></table></figure>





<h2 id="Methods-and-interfaces"><a href="#Methods-and-interfaces" class="headerlink" title="Methods and interfaces"></a>Methods and interfaces</h2><p>Learn how to define methods on types, how to declare interfaces, and how to put everything together.</p>
<h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><p>Go does not have classes. However, you can define methods on types.</p>
<p>A method is a function with a special <em>receiver</em> argument.</p>
<p>The receiver appears in its own argument list between the <code>func</code> keyword and the method name.</p>
<p>In this example, the <code>Abs</code> method has a receiver of type <code>Vertex</code> named <code>v</code>.</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Methods-continued"><a href="#Methods-continued" class="headerlink" title="Methods continued"></a>Methods continued</h4><p>You can declare a method on non-struct types, too.</p>
<p>In this example we see a numeric type <code>MyFloat</code> with an <code>Abs</code> method.</p>
<p>You can only declare a method with a receiver whose type is defined in the same package as the method. You cannot declare a method with a receiver whose type is defined in another package (which includes the built-in types such as <code>int</code>).</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := MyFloat(-math.Sqrt2)</span><br><span class="line">	fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="change-the-values-by-pointer"><a href="#change-the-values-by-pointer" class="headerlink" title="change the values by pointer"></a>change the values by pointer</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">ScaleFunc(v, 5)  // Compile error!</span><br><span class="line">ScaleFunc(&amp;v, 5) // OK</span><br></pre></td></tr></table></figure>

<p>while methods with pointer receivers take either a value or a pointer as the receiver when they are called:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">v.Scale(5)  // OK</span><br><span class="line">p := &amp;v</span><br><span class="line">p.Scale(10) // OK</span><br></pre></td></tr></table></figure>

<p>For the statement <code>v.Scale(5)</code>, v id equal with &amp;v.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScaleFunc</span><span class="params">(v *Vertex, f <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	v.Scale(<span class="number">2</span>)</span><br><span class="line">	ScaleFunc(&amp;v, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">	p.Scale(<span class="number">3</span>)</span><br><span class="line">	ScaleFunc(p, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(v, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;60 80&#125; &amp;&#123;96 72&#125;</span><br></pre></td></tr></table></figure>

<p><strong>specially</strong>,methods with value receivers take either a value or a pointer as the receiver when they are called:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AbsFunc</span><span class="params">(v Vertex)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(v.Abs()) <span class="comment">// OK</span></span><br><span class="line">p := &amp;v</span><br><span class="line">fmt.Println(p.Abs()) <span class="comment">// OK</span></span><br><span class="line">fmt.Println(AbsFunc(v))  <span class="comment">// OK</span></span><br><span class="line">fmt.Println(AbsFunc(&amp;v)) <span class="comment">// Compile error!</span></span><br></pre></td></tr></table></figure>

<p>In this case, the method call <code>p.Abs()</code> is interpreted as <code>(*p).Abs()</code>.</p>
<h4 id="why-points"><a href="#why-points" class="headerlink" title="why points?"></a>why points?</h4><p>There are two reasons to use a pointer receiver.</p>
<p>The first is so that the method can <strong>modify the value</strong> that its receiver points to.</p>
<p>The second is to avoid copying the value on each method call. This can be more <strong>efficient</strong> if the receiver is a large struct, for example.</p>
<p>In this example, both <code>Scale</code> and <code>Abs</code> are methods with receiver type <code>*Vertex</code>, even though the <code>Abs</code> method needn’t modify its receiver.</p>
<p>In general, all methods on a given type should have either value or pointer receivers, but <strong>not a mixture</strong> of both. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;<span class="comment">/*we can omit the &amp; */</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Before scaling: %+v, Abs: %v\n&quot;</span>, v, v.Abs())</span><br><span class="line">	v.Scale(<span class="number">5</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;After scaling: %+v, Abs: %v\n&quot;</span>, v, v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Before scaling: &#123;X:<span class="number">3</span> Y:<span class="number">4</span>&#125;, Abs: <span class="number">5</span></span><br><span class="line">After scaling: &#123;X:<span class="number">15</span> Y:<span class="number">20</span>&#125;, Abs: <span class="number">25</span></span><br></pre></td></tr></table></figure>

<h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p>interface is a type,an abstract type.</p>
<p>it emphasizes the <strong>behave</strong>,which contains the methods of many receivers，although the types of receviers is different</p>
<p>like <code>dog</code> and <code>cat</code>,they are different type ,but they are all animals,animals could eat and run,they can use the same type and same function via the interface <code>Animal</code>. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span>&#123;</span><br><span class="line">	Run()</span><br><span class="line">	Eat()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Sex <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span>Run()&#123;</span><br><span class="line">	fmt.Println(c.Name,<span class="string">&quot;start running&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span>Eat()&#123;</span><br><span class="line">	fmt.Println(c.Name,<span class="string">&quot;start eating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Dog)</span></span>Run()&#123;</span><br><span class="line">	fmt.Println(c.Name,<span class="string">&quot;start running&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Dog)</span></span>Eat()&#123;</span><br><span class="line">	fmt.Println(c.Name,<span class="string">&quot;start eating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EatRun</span><span class="params">(v Animal)</span></span>&#123;</span><br><span class="line">    v.Eat()</span><br><span class="line">    v.Run()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	c:=Cat&#123;</span><br><span class="line">		Name:<span class="string">&quot;maiomiao&quot;</span>,</span><br><span class="line">		Sex: <span class="literal">false</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	d:=Dog&#123;</span><br><span class="line">		Name:<span class="string">&quot;wool&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> a Animal</span><br><span class="line">	a=c</span><br><span class="line">	a.Run()</span><br><span class="line">	a.Eat()</span><br><span class="line">	a=d</span><br><span class="line">	a.Eat()</span><br><span class="line">	a.Run()</span><br><span class="line">    EatRun(c)</span><br><span class="line">    EatRun(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maiomiao start running</span><br><span class="line">maiomiao start eating</span><br><span class="line">wool start eating</span><br><span class="line">wool start running</span><br></pre></td></tr></table></figure>

<h4 id="the-values-and-type-of-the-interface"><a href="#the-values-and-type-of-the-interface" class="headerlink" title="the values and type of the interface"></a>the values and type of the interface</h4><p>Under the hood, interface values can be thought of as a tuple of a value and a concrete type:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(value, type)</span><br></pre></td></tr></table></figure>

<p>An interface value holds a value of a specific underlying concrete type.</p>
<p>Calling a method on an interface value executes the method of the same name on its underlying type.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">	M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M() &#123;</span><br><span class="line">	fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span></span> M() &#123;</span><br><span class="line">	fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line">	i = &amp;T&#123;<span class="string">&quot;Hello&quot;</span>&#125;</span><br><span class="line">	describe(i)</span><br><span class="line">	i.M()</span><br><span class="line"></span><br><span class="line">	i = F(math.Pi)</span><br><span class="line">	describe(i)</span><br><span class="line">	i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&amp;&#123;Hello&#125;, *main.T)</span><br><span class="line">Hello</span><br><span class="line">(3.141592653589793, main.F)</span><br><span class="line">3.141592653589793</span><br></pre></td></tr></table></figure>

<h4 id="Interface-values-with-nil-underlying-values"><a href="#Interface-values-with-nil-underlying-values" class="headerlink" title="Interface values with nil underlying values"></a>Interface values with nil underlying values</h4><p>when facing nil underlying values,we coud gracefully handle the problems like <code>m()</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">	M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M() &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;&lt;nil&gt;&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t *T</span><br><span class="line">	i = t</span><br><span class="line">	describe(i)</span><br><span class="line">	i.M()</span><br><span class="line"></span><br><span class="line">	i = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">	describe(i)</span><br><span class="line">	i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&lt;nil&gt;, *main.T)</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">(&amp;&#123;hello&#125;, *main.T)</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<h4 id="Nil-interface-values"><a href="#Nil-interface-values" class="headerlink" title="Nil interface values"></a>Nil interface values</h4><p>A nil interface value holds neither value nor concrete type.</p>
<p>Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which <em>concrete</em> method to call.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">	M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i I</span><br><span class="line">	describe(i)</span><br><span class="line">	i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(&lt;<span class="literal">nil</span>&gt;, &lt;<span class="literal">nil</span>&gt;)</span><br><span class="line"><span class="built_in">panic</span>: runtime <span class="type">error</span>: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=<span class="number">0x1</span> addr=<span class="number">0x0</span> pc=<span class="number">0x47c279</span>]</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">	/tmp/sandbox3134673304/prog.<span class="keyword">go</span>:<span class="number">12</span> +<span class="number">0x19</span></span><br></pre></td></tr></table></figure>

<h4 id="The-empty-interface"><a href="#The-empty-interface" class="headerlink" title="The empty interface"></a>The empty interface</h4><p>The interface type that specifies zero methods is known as the <em>empty interface</em>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>An empty interface may hold values of any type. (Every type implements at least zero methods.)</p>
<p>Empty interfaces are used by code that handles values of unknown type. For example, <code>fmt.Print</code> takes any number of arguments of type <code>interface&#123;&#125;</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	describe(i)</span><br><span class="line"></span><br><span class="line">	i = <span class="number">42</span></span><br><span class="line">	describe(i)</span><br><span class="line"></span><br><span class="line">	i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">	describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&lt;nil&gt;, &lt;nil&gt;)</span><br><span class="line">(42, int)</span><br><span class="line">(hello, string)</span><br></pre></td></tr></table></figure>

<h4 id="type-assertions"><a href="#type-assertions" class="headerlink" title="type assertions"></a>type assertions</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t := i.(T)</span><br></pre></td></tr></table></figure>

<p>if the interface value <code>i</code> holds the concrete type <code>T</code>,it will assigns the underlying <code>T</code> value to the variable <code>t</code>,or the statement will trigger a panic.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure>

<p>If <code>i</code> holds a <code>T</code>, then <code>t</code> will be the underlying value and <code>ok</code> will be true.</p>
<p>If not, <code>ok</code> will be false and <code>t</code> will be the zero value of type <code>T</code>, and no panic occurs.</p>
<p>Note the similarity between this syntax and that of reading from a map.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">	s := i.(<span class="type">string</span>)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line"></span><br><span class="line">	s, ok := i.(<span class="type">string</span>)</span><br><span class="line">	fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">	f, ok := i.(<span class="type">float64</span>)</span><br><span class="line">	fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">	f = i.(<span class="type">float64</span>) <span class="comment">// panic</span></span><br><span class="line">	fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">hello true</span><br><span class="line">0 false</span><br><span class="line">panic: interface conversion: interface &#123;&#125; is string, not float64</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">	/tmp/sandbox15807903/prog.go:17 +0x14f</span><br></pre></td></tr></table></figure>

<h4 id="type-switch"><a href="#type-switch" class="headerlink" title="type switch"></a>type switch</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	do(<span class="number">21</span>)</span><br><span class="line">	do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>the <code>i</code> receive any kind of types,and assign its type to the <code>v</code> via <code>v := i.(type)</code>,the <code>switch</code></p>
<p>choose the types,and the like the normal switch</p>
<p>outcome:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Twice 21 is 42</span><br><span class="line">&quot;hello&quot; is 5 bytes long</span><br><span class="line">I don&#x27;t know about type bool!</span><br></pre></td></tr></table></figure>

<h4 id="stringers"><a href="#stringers" class="headerlink" title="stringers"></a>stringers</h4><p>One of the most ubiquitous interfaces is <a href="https://go.dev/pkg/fmt/#Stringer"><code>Stringer</code></a> defined by the <a href="https://go.dev/pkg/fmt/"><code>fmt</code></a> package.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Stringer interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A <code>Stringer</code> is a type that can describe itself as a string. The <code>fmt</code> package (and many others) look for this interface to print values.</p>
<p>it can make the other type of variables be print as a type of strings</p>
<h6 id="Exercise-Stringers"><a href="#Exercise-Stringers" class="headerlink" title="Exercise: Stringers"></a>Exercise: Stringers</h6><p>Make the <code>IPAddr</code> type implement <code>fmt.Stringer</code> to print the address as a dotted quad.</p>
<p>For instance, <code>IPAddr&#123;1, 2, 3, 4&#125;</code> should print as <code>&quot;1.2.3.4&quot;</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPAddr [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Add a &quot;String() string&quot; method to IPAddr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ip IPAddr)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d.%d.%d.%d&quot;</span>, ip[<span class="number">0</span>], ip[<span class="number">1</span>], ip[<span class="number">2</span>],ip[<span class="number">3</span>])</span><br><span class="line">&#125;<span class="comment">//we need use Sprintf() because we need string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hosts := <span class="keyword">map</span>[<span class="type">string</span>]IPAddr&#123;</span><br><span class="line">		<span class="string">&quot;loopback&quot;</span>:  &#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		<span class="string">&quot;googleDNS&quot;</span>: &#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> name, ip := <span class="keyword">range</span> hosts &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, name, ip)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loopback: 127.0.0.1</span><br><span class="line">googleDNS: 8.8.8.8</span><br></pre></td></tr></table></figure>

<h4 id="error"><a href="#error" class="headerlink" title="error"></a>error</h4><p>Go programs express error state with <code>error</code> values.</p>
<p>The <code>error</code> type is a built-in interface similar to <code>fmt.Stringer</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(As with <code>fmt.Stringer</code>, the <code>fmt</code> package looks for the <code>error</code> interface when printing values.)</p>
<p>Functions often return an <code>error</code> value, and calling code should handle errors by testing whether the error equals <code>nil</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i, err := strconv.Atoi(<span class="string">&quot;42&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;couldn&#x27;t convert number: %v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Converted integer:&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<p>A nil <code>error</code> denotes success; a non-nil <code>error</code> denotes failure.</p>
]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>gorm</title>
    <url>/2024/04/30/gorm/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u gorm.io/gorm</span><br><span class="line"><span class="keyword">go</span> get -u gorm.io/driver/mysql<span class="comment">//ex</span></span><br></pre></td></tr></table></figure>

<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">  <span class="string">&quot;gorm.io/driver/sqlite&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//定义一个结构体用于存储数据</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Code  <span class="type">string</span></span><br><span class="line">  Price <span class="type">uint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(sqlite.Open(<span class="string">&quot;test.db&quot;</span>), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;failed to connect database&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迁移 schema</span></span><br><span class="line">  db.AutoMigrate(&amp;Product&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create</span></span><br><span class="line">  db.Create(&amp;Product&#123;Code: <span class="string">&quot;D42&quot;</span>, Price: <span class="number">100</span>&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read</span></span><br><span class="line">  <span class="keyword">var</span> product Product</span><br><span class="line">  db.First(&amp;product, <span class="number">1</span>) <span class="comment">// 根据整型主键查找</span></span><br><span class="line">  db.First(&amp;product, <span class="string">&quot;code = ?&quot;</span>, <span class="string">&quot;D42&quot;</span>) <span class="comment">// 查找 code 字段值为 D42 的记录</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update - 将 product 的 price 更新为 200</span></span><br><span class="line">  db.Model(&amp;product).Update(<span class="string">&quot;Price&quot;</span>, <span class="number">200</span>)</span><br><span class="line">  <span class="comment">// Update - 更新多个字段</span></span><br><span class="line">  db.Model(&amp;product).Updates(Product&#123;Price: <span class="number">200</span>, Code: <span class="string">&quot;F42&quot;</span>&#125;) <span class="comment">// 仅更新非零值字段</span></span><br><span class="line">  db.Model(&amp;product).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;Price&quot;</span>: <span class="number">200</span>, <span class="string">&quot;Code&quot;</span>: <span class="string">&quot;F42&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete - 删除 product</span></span><br><span class="line">  db.Delete(&amp;product, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字段级权限控制"><a href="#字段级权限控制" class="headerlink" title="字段级权限控制"></a>字段级权限控制</h2><p>可导出的字段在使用 GORM 进行 CRUD 时拥有全部的权限，此外，GORM 允许您用标签控制字段级别的权限。这样您就可以让一个字段的权限是只读、只写、只创建、只更新或者被忽略</p>
<blockquote>
<p><strong>注意：</strong> 使用 GORM Migrator 创建表时，不会创建被忽略的字段</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:create&quot;`</span> <span class="comment">// 允许读和创建</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:update&quot;`</span> <span class="comment">// 允许读和更新</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-&quot;`</span>        <span class="comment">// 允许读和写（创建和更新）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:false&quot;`</span>  <span class="comment">// 允许读，禁止写</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;&quot;`</span>        <span class="comment">// 只读（除非有自定义配置，否则禁止写）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;;&lt;-:create&quot;`</span> <span class="comment">// 允许读和写</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;:false;&lt;-:create&quot;`</span> <span class="comment">// 仅创建（禁止从 db 读）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&quot;`</span>  <span class="comment">// 通过 struct 读写会忽略该字段</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-:all&quot;`</span>        <span class="comment">// 通过 struct 读写、迁移会忽略该字段</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-:migration&quot;`</span>  <span class="comment">// 通过 struct 迁移会忽略该字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-更新时间追踪（纳秒、毫秒、秒、Time）"><a href="#创建-更新时间追踪（纳秒、毫秒、秒、Time）" class="headerlink" title="创建&#x2F;更新时间追踪（纳秒、毫秒、秒、Time）"></a>创建&#x2F;更新时间追踪（纳秒、毫秒、秒、Time）</h3><p>GORM 约定使用 <code>CreatedAt</code>、<code>UpdatedAt</code> 追踪创建&#x2F;更新时间。如果您定义了这种字段，GORM 在创建、更新时会自动填充 <a href="https://gorm.io/zh_CN/docs/gorm_config.html#now_func">当前时间</a></p>
<p>要使用不同名称的字段，您可以配置 <code>autoCreateTime</code>、<code>autoUpdateTime</code> 标签。</p>
<p>如果您想要保存 UNIX（毫&#x2F;纳）秒时间戳，而不是 time，您只需简单地将 <code>time.Time</code> 修改为 <code>int</code> 即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  CreatedAt time.Time <span class="comment">// 在创建时，如果该字段值为零值，则使用当前时间填充</span></span><br><span class="line">  UpdatedAt <span class="type">int</span>       <span class="comment">// 在创建时该字段值为零值或者在更新时，使用当前时间戳秒数填充</span></span><br><span class="line">  Updated   <span class="type">int64</span> <span class="string">`gorm:&quot;autoUpdateTime:nano&quot;`</span> <span class="comment">// 使用时间戳纳秒数填充更新时间</span></span><br><span class="line">  Updated   <span class="type">int64</span> <span class="string">`gorm:&quot;autoUpdateTime:milli&quot;`</span> <span class="comment">// 使用时间戳毫秒数填充更新时间</span></span><br><span class="line">  Created   <span class="type">int64</span> <span class="string">`gorm:&quot;autoCreateTime&quot;`</span>      <span class="comment">// 使用时间戳秒数填充创建时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌入结构体"><a href="#嵌入结构体" class="headerlink" title="嵌入结构体"></a>嵌入结构体</h3><p>可以直接嵌入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以加上标签<code>embedded</code>作为一种类型嵌入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Author <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="type">int</span></span><br><span class="line">  Author  Author <span class="string">`gorm:&quot;embedded&quot;`</span></span><br><span class="line">  Upvotes <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID    <span class="type">int64</span></span><br><span class="line">  Name  <span class="type">string</span></span><br><span class="line">  Email <span class="type">string</span></span><br><span class="line">  Upvotes  <span class="type">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以自动为其加上前缀</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="type">int</span></span><br><span class="line">  Author  Author <span class="string">`gorm:&quot;embedded;embeddedPrefix:author_&quot;`</span></span><br><span class="line">  Upvotes <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID          <span class="type">int64</span></span><br><span class="line">  AuthorName <span class="type">string</span></span><br><span class="line">  AuthorEmail <span class="type">string</span></span><br><span class="line">  Upvotes     <span class="type">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h3><p>声明 model 时，tag 是可选的，GORM 支持以下 tag： tag 名大小写不敏感，但建议使用 <code>camelCase</code> 风格</p>
<table>
<thead>
<tr>
<th align="left">标签名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">column</td>
<td align="left">指定 db 列名</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像 <code>varbinary(8)</code> 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT</code></td>
</tr>
<tr>
<td align="left">serializer</td>
<td align="left">指定将数据序列化或反序列化到数据库中的序列化器, 例如: <code>serializer:json/gob/unixtime</code></td>
</tr>
<tr>
<td align="left">size</td>
<td align="left">定义列数据类型的大小或长度，例如 <code>size: 256</code></td>
</tr>
<tr>
<td align="left">primaryKey</td>
<td align="left">将列定义为主键</td>
</tr>
<tr>
<td align="left">unique</td>
<td align="left">将列定义为唯一键</td>
</tr>
<tr>
<td align="left">default</td>
<td align="left">定义列的默认值</td>
</tr>
<tr>
<td align="left">precision</td>
<td align="left">指定列的精度</td>
</tr>
<tr>
<td align="left">scale</td>
<td align="left">指定列大小</td>
</tr>
<tr>
<td align="left">not null</td>
<td align="left">指定列为 NOT NULL</td>
</tr>
<tr>
<td align="left">autoIncrement</td>
<td align="left">指定列为自动增长</td>
</tr>
<tr>
<td align="left">autoIncrementIncrement</td>
<td align="left">自动步长，控制连续记录之间的间隔</td>
</tr>
<tr>
<td align="left">embedded</td>
<td align="left">嵌套字段</td>
</tr>
<tr>
<td align="left">embeddedPrefix</td>
<td align="left">嵌入字段的列名前缀</td>
</tr>
<tr>
<td align="left">autoCreateTime</td>
<td align="left">创建时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoCreateTime:nano</code></td>
</tr>
<tr>
<td align="left">autoUpdateTime</td>
<td align="left">创建&#x2F;更新时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoUpdateTime:milli</code></td>
</tr>
<tr>
<td align="left">index</td>
<td align="left">根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 <a href="https://gorm.io/zh_CN/docs/indexes.html">索引</a> 获取详情</td>
</tr>
<tr>
<td align="left">uniqueIndex</td>
<td align="left">与 <code>index</code> 相同，但创建的是唯一索引</td>
</tr>
<tr>
<td align="left">check</td>
<td align="left">创建检查约束，例如 <code>check:age &gt; 13</code>，查看 <a href="https://gorm.io/zh_CN/docs/constraints.html">约束</a> 获取详情</td>
</tr>
<tr>
<td align="left">&lt;-</td>
<td align="left">设置字段写入的权限， <code>&lt;-:create</code> 只创建、<code>&lt;-:update</code> 只更新、<code>&lt;-:false</code> 无写入权限、<code>&lt;-</code> 创建和更新权限</td>
</tr>
<tr>
<td align="left">-&gt;</td>
<td align="left">设置字段读的权限，<code>-&gt;:false</code> 无读权限</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">忽略该字段，<code>-</code> 表示无读写，<code>-:migration</code> 表示无迁移权限，<code>-:all</code> 表示无读写迁移权限</td>
</tr>
<tr>
<td align="left">comment</td>
<td align="left">迁移时为字段添加注释</td>
</tr>
</tbody></table>
<p>举例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Base</span><br><span class="line">    Name      <span class="type">string</span>    <span class="string">`gorm:&quot;varchar(20);not null&quot; json:&quot;name&quot;`</span>     <span class="comment">//姓名</span></span><br><span class="line">    Gender    *<span class="type">string</span>   <span class="string">`gorm:&quot;char&quot; json:&quot;gender&quot;`</span>                   <span class="comment">//性别</span></span><br><span class="line">    Age       <span class="type">int</span>       <span class="string">`json:&quot;age&quot;`</span>                                  <span class="comment">//年龄</span></span><br><span class="line">    Birthday  time.Time <span class="string">`gorm:&quot;not null&quot; json:&quot;birthday&quot;`</span>             <span class="comment">//出生日期</span></span><br><span class="line">    Telephone *<span class="type">string</span>   <span class="string">`gorm:&quot;varchar(20)&quot; json:&quot;telephone&quot;`</span>         <span class="comment">//电话</span></span><br><span class="line">    Password  <span class="type">string</span>    <span class="string">`gorm:&quot;varchar(20);not null&quot; json:&quot;password&quot;`</span> <span class="comment">//密码</span></span><br><span class="line">    Email     <span class="type">string</span>    <span class="string">`gorm:&quot;varchar(30);not null&quot; json:&quot;email&quot;`</span>    <span class="comment">//邮箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go-gin框架搭建todolist网页</title>
    <url>/2024/04/24/go-gin%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BAtodolist%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<p> 里面包含了JWT，viper，middleware，casbin，log，err的一些常见处理方法</p>
<h1 id="与前端的连接"><a href="#与前端的连接" class="headerlink" title="与前端的连接"></a>与前端的连接</h1><p>首先我们要把前端文件都放在web中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web</span><br><span class="line">   |-- static          					//静态文件</span><br><span class="line">   |   |-- css								//css文件</span><br><span class="line">   |   |   |-- app.8eeeaf31.css</span><br><span class="line">   |   |   `-- chunk-vendors.57db8905.css</span><br><span class="line">   |   |-- fonts							//字体文件</span><br><span class="line">   |   |   |-- element-icons.535877f5.woff</span><br><span class="line">   |   |   `-- element-icons.732389de.ttf</span><br><span class="line">   |   `-- js								//js文件</span><br><span class="line">   |       |-- app.007f9690.js</span><br><span class="line">   |       `-- chunk-vendors.ddcb6f91.js</span><br><span class="line">   `-- templates							//模板文件</span><br><span class="line">       |-- favicon.ico						//html图标</span><br><span class="line">       `-- index.html						</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们在main中启用这些文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    <span class="comment">//告诉gin框架去哪里找静态文件</span></span><br><span class="line">    r.Static(<span class="string">&quot;/static&quot;</span>, <span class="string">&quot;web/static&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//告诉gin框架模板文件引用的静态文件去哪里找</span></span><br><span class="line">    r.LoadHTMLGlob(<span class="string">&quot;web/templates/*&quot;</span>)</span><br><span class="line">    r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">       c.HTML(<span class="number">200</span>, <span class="string">&quot;index.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候打开网页，就可以发现可以正常显示了</p>
<p>如果出现问题的话，可以检查html中的css文件的路径</p>
<h1 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h1><h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>gin&#x2F;model</p>
<h2 id="Base-go"><a href="#Base-go" class="headerlink" title="Base.go"></a>Base.go</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">string</span>         <span class="string">`gorm:&quot;primary_key&quot; json:&quot;id&quot;`</span><span class="comment">//指明是主键</span></span><br><span class="line">    CreatedAt time.Time      <span class="string">`json:&quot;-&quot;`</span><span class="comment">//这意味着在将对象序列化为JSON时，这些字段不会被包含，从而不会暴露这些可能敏感的元数据信息。</span></span><br><span class="line">    UpdatedAt time.Time      <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">    DeletedAt gorm.DeletedAt <span class="string">`gorm:&quot;index&quot; json:&quot;-&quot;`</span><span class="comment">//用作索引，用于软删除，快速地定位到“已删除”的记录。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BASE包含了每个用户一定会有的数据，其他数据不一定都有</p>
<h2 id="User-go"><a href="#User-go" class="headerlink" title="User.go"></a>User.go</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/oklog/ulid/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：所有字段的零值, 比如0, &quot;&quot;,false或者其它零值，都不会保存到数据库内，但会使用他们的默认值。</span></span><br><span class="line"><span class="comment">//如果你想避免这种情况，可以考虑使用指针或实现 Scanner/Valuer接口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Base</span><br><span class="line">    Name      <span class="type">string</span>    <span class="string">`gorm:&quot;varchar(20);not null&quot; json:&quot;name&quot;`</span>     <span class="comment">//姓名</span></span><br><span class="line">    Gender    *<span class="type">string</span>   <span class="string">`gorm:&quot;char&quot; json:&quot;gender&quot;`</span>                   <span class="comment">//性别</span></span><br><span class="line">    Age       <span class="type">int</span>       <span class="string">`json:&quot;age&quot;`</span>                                  <span class="comment">//年龄</span></span><br><span class="line">    Birthday  time.Time <span class="string">`gorm:&quot;not null&quot; json:&quot;birthday&quot;`</span>             <span class="comment">//出生日期</span></span><br><span class="line">    Telephone *<span class="type">string</span>   <span class="string">`gorm:&quot;varchar(20)&quot; json:&quot;telephone&quot;`</span>         <span class="comment">//电话</span></span><br><span class="line">    Password  <span class="type">string</span>    <span class="string">`gorm:&quot;varchar(20);not null&quot; json:&quot;password&quot;`</span> <span class="comment">//密码</span></span><br><span class="line">    Email     <span class="type">string</span>    <span class="string">`gorm:&quot;varchar(30);not null&quot; json:&quot;email&quot;`</span>    <span class="comment">//邮箱</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">    u.ID = ulid.Make().String()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>自动填充字段</strong>：</p>
<ul>
<li><code>BeforeCreate</code>方法是GORM的一个钩子（hook），它会在创建记录之前自动被调用。在<code>User</code>模型的<code>BeforeCreate</code>方法中，它使用<code>ulid</code>生成一个唯一的标识符并赋值给<code>ID</code>字段，确保每个用户都有一个独特的ID。</li>
</ul>
<h2 id="Todo-go"><a href="#Todo-go" class="headerlink" title="Todo.go"></a>Todo.go</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/oklog/ulid/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：所有字段的零值, 比如0, &quot;&quot;,false或者其它零值，都不会保存到数据库内，但会使用他们的默认值。</span></span><br><span class="line"><span class="comment">//如果你想避免这种情况，可以考虑使用指针或实现 Scanner/Valuer接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Todo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Base</span><br><span class="line">    Title  <span class="type">string</span> <span class="string">`gorm:&quot;varchar(20);not null&quot; json:&quot;title&quot;`</span>  <span class="comment">//标题</span></span><br><span class="line">    Status <span class="type">bool</span>   <span class="string">`json:&quot;status&quot;`</span>                             <span class="comment">//状态</span></span><br><span class="line">    Userid <span class="type">string</span> <span class="string">`gorm:&quot;varchar(20);not null&quot; json:&quot;userid&quot;`</span> <span class="comment">//用户id</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *Todo)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">    u.ID = ulid.Make().String()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="连接数据库（里面有log，viper）"><a href="#连接数据库（里面有log，viper）" class="headerlink" title="连接数据库（里面有log，viper）"></a>连接数据库（里面有log，viper）</h1><h2 id="位置-1"><a href="#位置-1" class="headerlink" title="位置"></a>位置</h2><p>主体位于internal&#x2F;database，log日志处理在internal&#x2F;log，配置文件位于configs,</p>
<h2 id="configs"><a href="#configs" class="headerlink" title="configs"></a>configs</h2><p>因为使用mysql数据库需要配置大量的信息，而为了代码更加具有复用性，我们将这些个人的信息存放在config.yaml中并且使用viper来让mysql.go能够调用这些数据</p>
<h4 id="config-yaml"><a href="#config-yaml" class="headerlink" title="config.yaml"></a>config.yaml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据库配置信息</span></span><br><span class="line"><span class="attr">database:</span></span><br><span class="line">  <span class="attr">root:</span> <span class="string">&quot;root&quot;</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">&quot;xyf1029&quot;</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">&quot;localhost&quot;</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">dbname:</span> <span class="string">&quot;bubble&quot;</span></span><br><span class="line">  <span class="attr">charset:</span> <span class="string">&quot;utf8mb4&quot;</span></span><br><span class="line">  <span class="attr">parseTime:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">  <span class="attr">loc:</span> <span class="string">&quot;Local&quot;</span></span><br></pre></td></tr></table></figure>

<p>config.yaml包含数据配置所需要的信息</p>
<h4 id="model-go"><a href="#model-go" class="headerlink" title="model.go:"></a>model.go:</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> configs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	DbSettings DatabaseSettings</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DatabaseSettings <span class="keyword">struct</span> &#123;</span><br><span class="line">	Root      <span class="type">string</span></span><br><span class="line">	Password  <span class="type">string</span></span><br><span class="line">	Host      <span class="type">string</span></span><br><span class="line">	Port      <span class="type">int</span></span><br><span class="line">	Dbname    <span class="type">string</span></span><br><span class="line">	Charset   <span class="type">string</span></span><br><span class="line">	ParseTime <span class="type">string</span></span><br><span class="line">	Loc       <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Setting <span class="keyword">struct</span> &#123;</span><br><span class="line">	vp *viper.Viper</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里配置了</p>
<h4 id="setting-go"><a href="#setting-go" class="headerlink" title="setting.go"></a>setting.go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> configs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/spf13/viper&quot;</span> <span class="comment">// 引入viper包，用于处理配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSetting 创建并返回一个包含viper实例的Setting对象，有错误则返回错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSetting</span><span class="params">()</span></span> (*Setting, <span class="type">error</span>) &#123;</span><br><span class="line">	vp := viper.New()             <span class="comment">// 使用viper库创建一个新的viper实例</span></span><br><span class="line">	vp.SetConfigName(<span class="string">&quot;config&quot;</span>)    <span class="comment">// 设置配置文件的名字，不包含文件后缀</span></span><br><span class="line">	vp.AddConfigPath(<span class="string">&quot;./configs&quot;</span>) <span class="comment">// 添加配置文件的搜索路径，这里是相对路径下的configs目录</span></span><br><span class="line">	vp.AddConfigPath(<span class="string">&quot;.&quot;</span>)         <span class="comment">// 添加另一个配置文件的搜索路径，这里是当前工作目录</span></span><br><span class="line">	vp.SetConfigType(<span class="string">&quot;yaml&quot;</span>)      <span class="comment">// 设置配置文件的类型，这里是YAML</span></span><br><span class="line"></span><br><span class="line">	err := vp.ReadInConfig() <span class="comment">// 读取和解析配置文件</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err <span class="comment">// 如果读取配置文件出错，则返回错误</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;Setting&#123;vp&#125;, <span class="literal">nil</span> <span class="comment">// 如果没有错误，则返回一个包含viper实例的Setting对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetUpSettings 用于初始化全局配置，通过调用NewSetting来读取配置文件，</span></span><br><span class="line"><span class="comment">// 并将配置文件中的特定部分映射到全局变量。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetUpSettings</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	setting, err := NewSetting() <span class="comment">// 创建Setting实例，该实例包含了读取的配置</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err <span class="comment">// 如果在创建Setting实例时遇到错误，则返回该错误</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以下代码可以针对配置文件中的多个不同部分进行处理</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取配置文件中的&quot;Database&quot;部分，并将其内容赋值给DbSettings全局变量</span></span><br><span class="line">	err1 := setting.ReadSection(<span class="string">&quot;Database&quot;</span>, &amp;DbSettings)</span><br><span class="line">	<span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err1 <span class="comment">// 如果读取&quot;Database&quot;部分失败，则返回错误</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果所有配置部分都成功读取，则返回nil</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadSection 方法将配置文件中的特定部分解码并绑定到传入的结构体v中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Setting)</span></span> ReadSection(name <span class="type">string</span>, v <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	err := s.vp.UnmarshalKey(name, v) <span class="comment">// 使用viper的UnmarshalKey方法读取指定的键，并将其解码到结构体v中</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err <span class="comment">// 如果解码过程中出现错误，则返回错误</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 如果没有错误，则返回nil表示成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这三个文件都放在configs下，这样就可以直接在mysql.go中直接调用config里面的内容</p>
<h2 id="zap日志记录"><a href="#zap日志记录" class="headerlink" title="zap日志记录"></a>zap日志记录</h2><p>我们在连接数据库的时候，经常需要处理错误，这些错误需要日志报告，我们可以直接只用github上现成的代码。</p>
<h3 id="位置-2"><a href="#位置-2" class="headerlink" title="位置"></a>位置</h3><p>internal&#x2F;global&#x2F;log</p>
<h3 id="log-go"><a href="#log-go" class="headerlink" title="log.go"></a>log.go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为log的包</span></span><br><span class="line"><span class="keyword">package</span> log</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入所需的包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span>          <span class="comment">// 导入gin框架，用于web开发</span></span><br><span class="line">    <span class="string">&quot;github.com/natefinch/lumberjack&quot;</span>   <span class="comment">// 导入lumberjack包，用于日志轮转</span></span><br><span class="line">    <span class="string">&quot;go.uber.org/zap&quot;</span>                   <span class="comment">// 导入zap包，用于日志记录</span></span><br><span class="line">    <span class="string">&quot;go.uber.org/zap/zapcore&quot;</span>           <span class="comment">// 导入zapcore，是zap的核心</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个SugaredLogger的全局变量，用于提供日志记录功能</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    SugarLogger *zap.SugaredLogger</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init函数返回一个闭包，该闭包作为中间件使用，在请求处理链中初始化日志记录器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        initLogger()                     <span class="comment">// 初始化日志记录器</span></span><br><span class="line">        c.Next()                         <span class="comment">// 调用请求处理链中的下一个处理函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initLogger初始化全局的SugarLogger变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Encoder := getEncoder()             <span class="comment">// 获取编码器，用于编码日志条目</span></span><br><span class="line">    WriterSyncer := getWriterSyncer()   <span class="comment">// 获取WriteSyncer，用于确定日志写入位置</span></span><br><span class="line">    core := zapcore.NewCore(Encoder, WriterSyncer, zapcore.DebugLevel) <span class="comment">// 创建核心日志记录器，设置日志级别为Debug</span></span><br><span class="line">    logger := zap.New(core, zap.AddCaller()) <span class="comment">// 创建一个zap日志记录器实例，添加调用者信息</span></span><br><span class="line">    SugarLogger = logger.Sugar()        <span class="comment">// 使用SugaredLogger，更友好的API</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getEncoder创建并返回一个用于日志条目的JSON格式编码器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getEncoder</span><span class="params">()</span></span> zapcore.Encoder &#123;</span><br><span class="line">    encoderConfig := zap.NewProductionEncoderConfig() <span class="comment">// 获取默认的生产环境编码器配置</span></span><br><span class="line">    encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder <span class="comment">// 设置时间编码器，使用ISO8601格式</span></span><br><span class="line">    encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder <span class="comment">// 设置日志级别编码器，使其大写</span></span><br><span class="line">    <span class="keyword">return</span> zapcore.NewJSONEncoder(encoderConfig) <span class="comment">// 创建一个新的JSON编码器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getWriterSyncer创建并返回一个WriteSyncer，它指定日志应当如何写入文件系统</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getWriterSyncer</span><span class="params">()</span></span> zapcore.WriteSyncer &#123;</span><br><span class="line">    lumberJackLogger := &amp;lumberjack.Logger&#123;</span><br><span class="line">        Filename:   <span class="string">&quot;./text.log&quot;</span>,         <span class="comment">// 日志文件的名字</span></span><br><span class="line">        MaxSize:    <span class="number">10</span>,                   <span class="comment">// 日志文件的最大大小（单位：MB）</span></span><br><span class="line">        MaxBackups: <span class="number">5</span>,                    <span class="comment">// 最大备份文件数量</span></span><br><span class="line">        MaxAge:     <span class="number">30</span>,                   <span class="comment">// 备份文件的最大存活天数</span></span><br><span class="line">        Compress:   <span class="literal">false</span>,                <span class="comment">// 是否压缩/归档旧文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zapcore.AddSync(lumberJackLogger) <span class="comment">// 使用lumberjack作为zap的WriteSyncer实现，提供日志文件轮转功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<p>现在根目录创建一个text.log</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">log.SugarLogger.Error(err)</span><br></pre></td></tr></table></figure>

<p>这将会在text.log记录错误信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err1 := db.AutoMigrate(&amp;model.User&#123;&#125;)</span><br><span class="line">log.SugarLogger.Error(err1)<span class="comment">//2  3  ....</span></span><br></pre></td></tr></table></figure>

<p>如此可以区分错误的类型</p>
<h2 id="mysql-go"><a href="#mysql-go" class="headerlink" title="mysql.go"></a>mysql.go</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> database</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;gin/configs&quot;</span></span><br><span class="line">    <span class="string">&quot;gin/internal/global/log&quot;</span></span><br><span class="line">    <span class="string">&quot;gin/model&quot;</span></span><br><span class="line">    <span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">    <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    DB *gorm.DB</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Connect</span><span class="params">()</span></span> *gorm.DB &#123;</span><br><span class="line">    dsn := fmt.Sprint(<span class="string">&quot;%s:%s@tcp(%s:%d)/%s?charset=%s&amp;parseTime=%s&amp;loc=%s&quot;</span>,</span><br><span class="line">       configs.DbSettings.Root,</span><br><span class="line">       configs.DbSettings.Password,</span><br><span class="line">       configs.DbSettings.Host,</span><br><span class="line">       configs.DbSettings.Port,</span><br><span class="line">       configs.DbSettings.Dbname,</span><br><span class="line">       configs.DbSettings.Charset,</span><br><span class="line">       configs.DbSettings.ParseTime,</span><br><span class="line">       configs.DbSettings.Loc,</span><br><span class="line">    )</span><br><span class="line">    db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;) <span class="comment">//gorm.Open方法尝试使用构建的DSN（数据源名称）和MySQL驱动打开一个新的数据库连接。</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       log.SugarLogger.Error(err)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;连接数据库成功&quot;</span>)</span><br><span class="line">    err1 := db.AutoMigrate(&amp;model.User&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">       log.SugarLogger.Error(err1)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;数据库迁移成功&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    DB = Connect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时我们也注意一下代码的组织形式，旨在实现模块化和分离关注点，这种做法有助于维护和可读性，并且使得数据库连接可以被重用。</p>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>虽然在程序中已经写好了连接数据库的操作，但是我们需要在电脑中提供mysql的运行环境</p>
<h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&quot;3.1&quot;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:latest</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_DATABASE: <span class="string">&#x27;todolist&#x27;</span></span><br><span class="line">      MYSQL_USER: <span class="string">&#x27;user&#x27;</span></span><br><span class="line">      MYSQL_PASSWORD: <span class="string">&#x27;xyf1029&#x27;</span></span><br><span class="line">      MYSQL_ROOT_PASSWORD: <span class="string">&#x27;xyf1029&#x27;</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;3306:3306&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h3><p>打开docker desktop，运行compose，然后在在goland自己的数据库里面填写好信息，就可以连接了</p>
<h1 id="错误处理errs"><a href="#错误处理errs" class="headerlink" title="错误处理errs"></a>错误处理errs</h1><p>为了简化和规范模组中错误提示，我们自定义了错误处理包errs</p>
<h2 id="位置-3"><a href="#位置-3" class="headerlink" title="位置"></a>位置</h2><p>global&#x2F;errs</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="logic-go"><a href="#logic-go" class="headerlink" title="logic.go"></a>logic.go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> errs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面展现如何生成“错误”的过程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code    <span class="type">int64</span>  <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">    Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">    Origin  <span class="type">string</span> <span class="string">`json:&quot;origin&quot;`</span> <span class="comment">// Origin字段通常用于只是错误的来源或者上下文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定数字和文字之间的关联</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newError</span><span class="params">(code <span class="type">int64</span>, msg <span class="type">string</span>)</span></span> *Error &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Error&#123;</span><br><span class="line">       Code:    code,</span><br><span class="line">       Message: msg,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示数字背后的含义（人能看懂）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Error)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Error)</span></span> Is(target <span class="type">error</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t *Error</span><br><span class="line">    <span class="comment">// errors.As是把target转化成t的类型</span></span><br><span class="line">    ok := errors.As(target, &amp;t)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.Code == t.Code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加error类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Error)</span></span> WithOrigin(err <span class="type">error</span>) *Error &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Error&#123;</span><br><span class="line">       Code:    e.Code,</span><br><span class="line">       Message: e.Message,</span><br><span class="line">       Origin:  fmt.Sprintf(<span class="string">&quot;%+v&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加字符串进入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Error)</span></span> WithTips(details ...<span class="type">string</span>) *Error &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Error&#123;</span><br><span class="line">       Code:    e.Code,</span><br><span class="line">       Message: e.Message + <span class="string">&quot; &quot;</span> + fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, details),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个文件实现了错误类型 <code>Error</code> 的构造函数和一些助手方法，以方便地创建和操作错误实例。</p>
<ul>
<li><code>newError</code>: 构造函数，用来创建一个新的 <code>Error</code> 实例。</li>
<li><code>Error</code>: 实现了 Go 的 <code>error</code> 接口，返回错误的描述。</li>
<li><code>Is</code>: 检查两个错误是否相同。</li>
<li><code>WithOrigin</code>: 添加原始错误信息，用于追踪错误的根源。</li>
<li><code>WithTips</code>: 添加额外的描述信息到错误消息中。</li>
</ul>
<p>tip</p>
<h3 id="code-go"><a href="#code-go" class="headerlink" title="code.go"></a>code.go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> errs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个代码是用作特定类型定义</span></span><br><span class="line"><span class="comment">//可以预定义一些成功类型和错误类型，以便在整个系统中使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参照NX的博客，反正就是参照了HTTP状态码的语义，方便识别错误类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的code都是*Error的类型</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    SUCCESS = newError(<span class="number">200</span>, <span class="string">&quot;Success&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    INVALID_REQUEST = newError(<span class="number">40001</span>, <span class="string">&quot;无效的请求&quot;</span>)</span><br><span class="line">    NOTFOUND        = newError(<span class="number">40002</span>, <span class="string">&quot;目标不存在&quot;</span>)</span><br><span class="line">    HAS_EXIST       = newError(<span class="number">40003</span>, <span class="string">&quot;目标已存在&quot;</span>)</span><br><span class="line">    LOGIN_ERROR     = newError(<span class="number">40004</span>, <span class="string">&quot;d登陆失败&quot;</span>)</span><br><span class="line">    UNTHORIZATION   = newError(<span class="number">40005</span>, <span class="string">&quot;鉴权失败&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    DB_LINK_ERROR = newError(<span class="number">50001</span>, <span class="string">&quot;连接数据库失败&quot;</span>)</span><br><span class="line">    DB_CRUD_ERROR = newError(<span class="number">50002</span>, <span class="string">&quot;数据库操作失败&quot;</span>)</span><br><span class="line">    DB_BASE_ERROR = newError(<span class="number">50003</span>, <span class="string">&quot;数据库内部错误&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    SERVE_INTERNAL = newError(<span class="number">60001</span>, <span class="string">&quot;服务器内部故障&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个文件定义了自定义错误类型 <code>Error</code> 和一系列预定义的错误实例，这些错误实例将在整个应用中使用，以确保错误处理的一致性。</p>
<h3 id="response-go"><a href="#response-go" class="headerlink" title="response.go"></a>response.go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> errs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> responseBody <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code   <span class="type">int64</span>  <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">    Msg    <span class="type">string</span> <span class="string">`json:&quot;msg&quot;`</span></span><br><span class="line">    Origin <span class="type">string</span> <span class="string">`json:&quot;origin&quot;`</span></span><br><span class="line">    Data   any    <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...any可以当作切片来处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Success</span><span class="params">(c *gin.Context, data ...any)</span></span> &#123;</span><br><span class="line">    response := responseBody&#123;</span><br><span class="line">       Code:   SUCCESS.Code,</span><br><span class="line">       Msg:    SUCCESS.Message,</span><br><span class="line">       Origin: SUCCESS.Origin,</span><br><span class="line">       Data:   data,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if len(data) &gt; 0 &#123;</span></span><br><span class="line">    <span class="comment">// response.Data = data[0]</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    c.JSON(http.StatusOK, response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fail</span><span class="params">(c *gin.Context, err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> e *Error</span><br><span class="line">    ok := errors.As(err, &amp;e)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">       e = SERVE_INTERNAL.WithOrigin(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resp responseBody</span><br><span class="line">    resp.Code = e.Code</span><br><span class="line">    resp.Msg = e.Message</span><br><span class="line">    resp.Origin = e.Origin</span><br><span class="line"></span><br><span class="line">    c.JSON(<span class="type">int</span>(e.Code/<span class="number">100</span>), resp)</span><br><span class="line">    c.Abort()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Recovery</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> info := <span class="built_in">recover</span>(); info != <span class="literal">nil</span> &#123;</span><br><span class="line">       err, ok := info.(<span class="type">error</span>)</span><br><span class="line">       <span class="keyword">if</span> ok &#123;</span><br><span class="line">          Fail(c, SERVE_INTERNAL.WithOrigin(err))</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Fail(c, errors.New(fmt.Sprintf(<span class="string">&quot;%+v&quot;</span>, info)))</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个文件展示了如何在基于 Gin 框架的 Web 应用中使用前面定义的错误处理包，来统一处理成功响应和错误响应。</p>
<ul>
<li><code>Success</code>: 用于处理成功的请求，返回标准的成功响应。</li>
<li><code>Fail</code>:这个函数的主要目的是根据提供的错误生成一个符合规范的错误响应，并将其发送给客户端。如果提供的错误不是自定义的错误类型，则默认返回一个内部服务器错误响应。</li>
<li><code>Recovery</code>: 这个 <code>Recovery</code> 函数的作用是捕获并处理请求处理过程中可能发生的意外恐慌。如果发生了恐慌，它会尝试将其转换为一个错误对象，并调用 <code>Fail()</code> 函数生成相应的错误响应。如果无法将恐慌转换为错误对象，则将其转换为字符串，并创建一个新的错误对象进行处理。</li>
</ul>
<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>介绍的话在我之前的博客上，这里直接使用。要注意的是，保存token一般都是前端的工作，在apifox进行登录之后要把</p>
<h2 id="个性化claim并且初始化token"><a href="#个性化claim并且初始化token" class="headerlink" title="个性化claim并且初始化token"></a>个性化claim并且初始化token</h2><p>创建自己的一个<code>Mycustomclaims</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mycustomclaims <span class="keyword">struct</span> &#123;</span><br><span class="line">    Payload</span><br><span class="line">    jwt.RegisteredClaims</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义Payload来储存用户登录的信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Payload <span class="keyword">struct</span> &#123;</span><br><span class="line">	Authorized <span class="type">bool</span>   <span class="string">`json:&quot;authorized&quot;`</span></span><br><span class="line">	User       <span class="type">string</span> <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line">    Userid     <span class="type">string</span> <span class="string">`json:&quot;userid&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置一个函数用来创建一个新的token</p>
<p>需要注意的是，这里的需要配置configs文件，按照连接数据库目录来配置自己的configs</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewToken</span><span class="params">(name <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    claims := &amp;Mycustomclaims&#123;</span><br><span class="line">       Payload: Payload&#123;</span><br><span class="line">          Authorized: <span class="literal">true</span>,</span><br><span class="line">          User:       name,</span><br><span class="line">           Userid:     userid,</span><br><span class="line">       &#125;,</span><br><span class="line">       RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">          Issuer:    configs.JwtSettings.Issuer,</span><br><span class="line">          Subject:   configs.JwtSettings.Subject,</span><br><span class="line">          ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour * <span class="number">24</span>)), <span class="comment">// jwt.NewNumericDate 可以创建一个符合JWT标准的时间格式,这里是24小时</span></span><br><span class="line">       &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)</span><br><span class="line">    tokenString, err := token.SignedString([]<span class="type">byte</span>(configs.JwtSettings.SecretKey))</span><br><span class="line">    <span class="keyword">return</span> tokenString, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="获取用户的信息函数"><a href="#获取用户的信息函数" class="headerlink" title="获取用户的信息函数"></a>获取用户的信息函数</h2><p>在这个用户要查看自己的todo的时候，要如何才能只看到自己的信息呢，答案就是时刻获取自己的token里面payload中的信息，然后根据唯一表示符<code>ID</code>来筛选</p>
<p>getuser.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jwt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;gin/internal/global/database&quot;</span></span><br><span class="line">    <span class="string">&quot;gin/internal/global/errs&quot;</span></span><br><span class="line">    <span class="string">&quot;gin/internal/global/log&quot;</span></span><br><span class="line">    <span class="string">&quot;gin/internal/model&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getcurrentuser</span><span class="params">(c *gin.Context)</span></span> model.User &#123;</span><br><span class="line">    payload, exists := c.Get(<span class="string">&quot;Payload&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> !exists &#123;</span><br><span class="line">       errs.Fail(c, errs.UNTHORIZATION.WithTips(<span class="string">&quot;没有token，无法从中获取用户信息&quot;</span>))</span><br><span class="line">       <span class="keyword">return</span> model.User&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    load := payload.(*Mycustomclaims)</span><br><span class="line">    <span class="keyword">var</span> user model.User</span><br><span class="line">    tx := database.DB.Where(<span class="string">&quot;id = ?&quot;</span>, load.Userid).First(&amp;user)</span><br><span class="line">    <span class="keyword">if</span> tx.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">       log.SugarLogger.Error(tx.Error)</span><br><span class="line">       errs.Fail(c, errs.DB_CRUD_ERROR.WithTips(<span class="string">&quot;该用户id不存在&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="解析jwt"><a href="#解析jwt" class="headerlink" title="解析jwt"></a>解析jwt</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jwt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;gin/configs&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/golang-jwt/jwt/v5&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析token</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseToken</span><span class="params">(token <span class="type">string</span>)</span></span> (*Mycustomclaims, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 解析方式需要添加 Bearer token模式</span></span><br><span class="line">    tokenParts := strings.Split(token, <span class="string">&quot; &quot;</span>) <span class="comment">//通过空格分隔出两个部分，并且存入数组之中</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tokenParts) != <span class="number">2</span> || strings.ToLower(tokenParts[<span class="number">0</span>]) != <span class="string">&quot;bearer&quot;</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;invalid token format,you need add bearer&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    tokenString := tokenParts[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 解析后续token</span></span><br><span class="line">    claims := &amp;Mycustomclaims&#123;&#125;</span><br><span class="line">    <span class="comment">// 是*token和string之间的转换</span></span><br><span class="line">    <span class="comment">// 这是一个回调函数具体结构就是 jwt.Parse(string,KeyFunc)</span></span><br><span class="line">    _, err := jwt.ParseWithClaims(tokenString, claims, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">       <span class="comment">// 验证签名方法 HMAC-SHA56签名方法</span></span><br><span class="line">       <span class="keyword">if</span> _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;unexpected Signing Method&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> []<span class="type">byte</span>(configs.JwtSettings.SecretKey), <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> claims, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码首先检查传入的令牌是否符合Bearer Token的标准格式。然后去后面额token，之后再定义一个<code>claims</code>来接受解析出来的声明，使用 <code>jwt.ParseWithClaims</code> 函数来解析JWT令牌。这个函数需要三个参数：要解析的令牌字符串、一个用于接收解析出的声明（claims）的结构体指针，以及一个回调函数，用于验证令牌的签名。回调函数检查签名方法是否为HMAC-SHA256，如果不是，则返回一个错误。如果签名方法正确，回调函数返回用于验证签名的密钥。</p>
<h2 id="设置中间件来验证身份"><a href="#设置中间件来验证身份" class="headerlink" title="设置中间件来验证身份"></a>设置中间件来验证身份</h2><p>位置：global&#x2F;middleware中</p>
<h3 id="Auth-go"><a href="#Auth-go" class="headerlink" title="Auth.go"></a>Auth.go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;gin/internal/global/jwt&quot;</span></span><br><span class="line">    <span class="string">&quot;gin/internal/global/log&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Auth</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">       <span class="comment">// 从请求头中获取token</span></span><br><span class="line">       token := c.GetHeader(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">       <span class="keyword">if</span> token == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">          <span class="comment">// 如果token为空，返回错误信息</span></span><br><span class="line">          c.JSON(http.StatusUnauthorized, gin.H&#123;</span><br><span class="line">             <span class="string">&quot;error&quot;</span>: <span class="string">&quot;Failed to fetch token&quot;</span>,</span><br><span class="line">          &#125;)</span><br><span class="line">          c.Abort()</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果token不为空，继续执行</span></span><br><span class="line">       parseToken, err := jwt.ParseToken(token)</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="comment">// 如果解析token失败，返回错误信息</span></span><br><span class="line">          log.SugarLogger.Error(err.Error())</span><br><span class="line">          c.JSON(http.StatusUnauthorized, gin.H&#123;</span><br><span class="line">             <span class="string">&quot;msg&quot;</span>:   <span class="string">&quot;Failed to Auth&quot;</span>,</span><br><span class="line">             <span class="string">&quot;error&quot;</span>: err,</span><br><span class="line">          &#125;)</span><br><span class="line">          c.Abort()</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">       c.Set(<span class="string">&quot;Payload&quot;</span>, parseToken)</span><br><span class="line">       c.Next() <span class="comment">// 继续执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个中间件的作用是验证HTTP请求中的Token是否有效，并且在Token有效时将其解析后的信息存储在请求上下文中，供后续处理函数使用。如果Token无效或不存在，请求将被拒绝并返回错误信息。</p>
<h3 id="recovery-go"><a href="#recovery-go" class="headerlink" title="recovery.go"></a>recovery.go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;gin/internal/global/errs&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Recovery</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">       <span class="keyword">defer</span> errs.Recovery(c)</span><br><span class="line">       c.Next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是用来错误恢复的</p>
<h1 id="casbin"><a href="#casbin" class="headerlink" title="casbin"></a>casbin</h1><p>位置：global中，其实这个项目没必要用casbin的，因为只有user一个身份，之后有时间可以设置一个管理员身份</p>
<h2 id="casbin-go"><a href="#casbin-go" class="headerlink" title="casbin.go"></a>casbin.go</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> casbin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyEnforce <span class="keyword">struct</span> &#123;</span><br><span class="line">    *casbin.Enforcer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetEnforce</span><span class="params">()</span></span> *MyEnforce &#123;</span><br><span class="line">    <span class="keyword">return</span> Enforce</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个文件定义了一个包装了<code>casbin.Enforcer</code>的结构体<code>MyEnforce</code>。它提供了一个方法<code>GetEnforce()</code>来获取全局的<code>MyEnforce</code>实例。</p>
<h2 id="init-go"><a href="#init-go" class="headerlink" title="init.go"></a>init.go</h2><p>首先定义了casbin模型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义casbin的model</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    casModel = <span class="string">`</span></span><br><span class="line"><span class="string">[request_definition]</span></span><br><span class="line"><span class="string">r = sub, obj, act</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[policy_definition]</span></span><br><span class="line"><span class="string">p = sub, obj, act</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[role_definition]</span></span><br><span class="line"><span class="string">g = _, _</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[policy_effect]</span></span><br><span class="line"><span class="string">e = some(where (p.eft == allow))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[matchers]</span></span><br><span class="line"><span class="string">m = g(r.sub, p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>具体设置原因可以看<a href="https://jaketmoon.github.io/2024/05/18/casbin/">casbin模型 | Jaketmoon の 博客</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Enforce *MyEnforce</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化casbin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	Enforce, err = createEnforcer()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	err1 := Enforce.LoadPolicy()</span><br><span class="line">	<span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	Enforce.EnableAutoSave(<span class="literal">true</span>)</span><br><span class="line">	Enforce.AddBasedPolicies()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建casbin的enforcer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createEnforcer</span><span class="params">()</span></span> (*MyEnforce, <span class="type">error</span>) &#123;</span><br><span class="line">	m, err := model.NewModelFromString(casModel)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//使用config文件里面的参数创建适配器</span></span><br><span class="line">	dsn := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s:%d)/%s&quot;</span>,</span><br><span class="line">		configs.DbSettings.Root,</span><br><span class="line">		configs.DbSettings.Password,</span><br><span class="line">		configs.DbSettings.Host,</span><br><span class="line">		configs.DbSettings.Port,</span><br><span class="line">		configs.DbSettings.Dbname,</span><br><span class="line">	)</span><br><span class="line">	adapter, err := gormadapter.NewAdapter(<span class="string">&quot;mysql&quot;</span>, dsn, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	e, err := casbin.NewEnforcer(m, adapter)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;MyEnforce&#123;e&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里具体的代码逻辑可以不深究，就是初始化了casbin，init之后就可以直接使用util.go里面的文件</p>
<h2 id="util-go"><a href="#util-go" class="headerlink" title="util.go"></a>util.go</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> casbin</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddBasedPolicies 添加基础策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyEnforce)</span></span> AddBasedPolicies() &#123;</span><br><span class="line">    e.AddPolicy(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;users&quot;</span>, <span class="string">&quot;read&quot;</span>)</span><br><span class="line">    e.AddPolicy(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;users&quot;</span>, <span class="string">&quot;write&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkUserWithPolicy 关联用户与策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyEnforce)</span></span> LinkUserWithPolicy(name <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    _, err := e.AddGroupingPolicy(name, <span class="string">&quot;user&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnLinkUserWithPolicy 解除用户与策略的关联</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyEnforce)</span></span> UnLinkUserWithPolicy(name <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    _, err := e.RemoveGroupingPolicy(name, <span class="string">&quot;user&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CheckUserPolicyForRead 检查是否有操作权限</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyEnforce)</span></span> CheckUserPolicyForRead(name, data, action <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    ok, _ := Enforce.Enforce(name, data, action)</span><br><span class="line">    <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化之后，可以通过上面的函数进行操作权限的配置</p>
<h1 id="设置模组"><a href="#设置模组" class="headerlink" title="设置模组"></a>设置模组</h1><p>在module文件夹中，我们定义了一些模块化的方法去组织程序。它定义了一个接口和一些函数去管理各个模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- module.go</span><br><span class="line">|-- todolist</span><br><span class="line">|   |-- add.go</span><br><span class="line">|   |-- delete.go</span><br><span class="line">|   |-- init.go</span><br><span class="line">|   |-- read.go</span><br><span class="line">|   |-- routers.go</span><br><span class="line">|   |-- seek.go</span><br><span class="line">|   `-- update.go</span><br><span class="line">`-- user</span><br><span class="line">    |-- delete.go</span><br><span class="line">    |-- init.go</span><br><span class="line">    |-- login.go</span><br><span class="line">    |-- read.go</span><br><span class="line">    |-- register.go</span><br><span class="line">    |-- routers.go</span><br><span class="line">    `-- update.go</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="module-go"><a href="#module-go" class="headerlink" title="module.go"></a>module.go</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> module</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;gin/internal/module/User&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Module <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetName() <span class="type">string</span></span><br><span class="line">    Init()</span><br><span class="line">    InitRouter(r *gin.RouterGroup)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Modules []Module</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterModule</span><span class="params">(m Module)</span></span> &#123;</span><br><span class="line">    Modules = <span class="built_in">append</span>(Modules, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init函数会在程序运行钱做必要的初始化工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    RegisterModule(&amp;User.ModuleUser&#123;&#125;)</span><br><span class="line">    RegisterModule(&amp;Todo.ModuleTodo&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>接口 <code>Module</code>:</strong> <code>Module</code> 接口要求实现它的任何结构体都有 <code>GetName()</code>, <code>Init()</code>, 和 <code>InitRouter(*gin.RouterGroup)</code> 这三个方法。</li>
<li><strong>变量 <code>Modules</code>:</strong> 切片，用来储存应用中所有的模块。</li>
<li><strong>函数 <code>RegisterModule</code>:</strong> 将<code>Module</code>其添加到 <code>Modules</code> 切片中。这样，你的应用程序就可以跟踪哪些模块已经注册。最后可以通过这个切边使所有的模块启动</li>
<li><strong>函数 <code>init</code>:</strong> 这是一个特殊的函数，它在包被Go程序调用之前自动执行。在这个函数中，它调用 <code>RegisterModule</code> 函数来注册用户模块，通过 <code>&amp;user.ModuleUser&#123;&#125;</code> 传递一个用户模块的实例。</li>
</ul>
<p>这三个方法分别位于各个不同文件中，这个模块方法的具体实现之后再讲</p>
<h2 id="init-go-1"><a href="#init-go-1" class="headerlink" title="init.go"></a>init.go</h2><p>这其实两个文件，位于Todo和User文件夹下面，但两者写的内容差不多,这里以User为例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> User</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ModuleUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *ModuleUser)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *ModuleUser)</span></span> Init() &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>ModuleUser 结构体:</strong> 代表用户模块，并实现了 <code>Module</code> 接口。在这里，它定义了 <code>GetName</code> 方法，该方法会返回模块的名称，这里是 “user”。</li>
<li><strong>Init 方法:</strong> 即使在这个例子中它没有做任何事情（是一个空方法），但它的目的是在模块初始化时执行必要的设置。例如，您可以在这里连接数据库、准备缓存等。</li>
</ol>
<h2 id="设置todolist相关路由"><a href="#设置todolist相关路由" class="headerlink" title="设置todolist相关路由"></a>设置todolist相关路由</h2><h3 id="routers-go"><a href="#routers-go" class="headerlink" title="routers.go"></a>routers.go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Todo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;gin/internal/global/middleware&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *ModuleTodo)</span></span> InitRouter(r *gin.RouterGroup) &#123;</span><br><span class="line">    r.Use(middleware.Auth())</span><br><span class="line">    r.POST(<span class="string">&quot;/&quot;</span>, Add)</span><br><span class="line">    r.PUT(<span class="string">&quot;/:id&quot;</span>, Update)</span><br><span class="line">    r.GET(<span class="string">&quot;/&quot;</span>, Read)</span><br><span class="line">    r.GET(<span class="string">&quot;/:id&quot;</span>, Seek)</span><br><span class="line">    r.DELETE(<span class="string">&quot;/:id&quot;</span>, Delete)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="设置user相关路由"><a href="#设置user相关路由" class="headerlink" title="设置user相关路由"></a>设置user相关路由</h2><h3 id="routers-go-1"><a href="#routers-go-1" class="headerlink" title="routers.go"></a>routers.go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> User</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;gin/internal/global/middleware&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *ModuleUser)</span></span> InitRouter(r *gin.RouterGroup) &#123;</span><br><span class="line">    r.POST(<span class="string">&quot;/register&quot;</span>, Register)</span><br><span class="line">    r.POST(<span class="string">&quot;/login&quot;</span>, Login)</span><br><span class="line">    r.PUT(<span class="string">&quot;/update&quot;</span>, middleware.Auth(), Update)</span><br><span class="line">    r.GET(<span class="string">&quot;/read&quot;</span>, middleware.Auth(), Read)</span><br><span class="line">    r.DELETE(<span class="string">&quot;/delete&quot;</span>, middleware.Auth(), Delete)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="前端的编写"><a href="#前端的编写" class="headerlink" title="前端的编写"></a>前端的编写</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> frontdevelop</span><br><span class="line">|   |-- static</span><br><span class="line">|   |   |-- css</span><br><span class="line">|   |   |   |-- index.css</span><br><span class="line">|   |   |   `-- style.css</span><br><span class="line">|   |   `-- js</span><br><span class="line">|   |       |-- app.js</span><br><span class="line">|   |       `-- login.js</span><br><span class="line">|   `-- templates</span><br><span class="line">|       |-- index.html</span><br><span class="line">|       `-- todo.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个是主要的文件夹</p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>cmd&#x2F;sever</p>
<h2 id="server-go"><a href="#server-go" class="headerlink" title="server.go"></a>server.go</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> server</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;gin/configs&quot;</span></span><br><span class="line">	<span class="string">&quot;gin/internal/global/casbin&quot;</span></span><br><span class="line">	<span class="string">&quot;gin/internal/global/database&quot;</span></span><br><span class="line">	<span class="string">&quot;gin/internal/global/log&quot;</span></span><br><span class="line">	<span class="string">&quot;gin/internal/global/middleware&quot;</span></span><br><span class="line">	<span class="string">&quot;gin/internal/module&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	configs.Init()</span><br><span class="line">	database.Init()</span><br><span class="line">	casbin.Init()</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> module.Modules &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Init Module: &quot;</span> + m.GetName())</span><br><span class="line">		m.Init()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.New()</span><br><span class="line">	r.Use(log.Init(), middleware.Recovery())</span><br><span class="line">	<span class="comment">//告诉gin框架静态文件去哪里找</span></span><br><span class="line">	r.Static(<span class="string">&quot;/static&quot;</span>, <span class="string">&quot;frontdevelop/static&quot;</span>)</span><br><span class="line">	<span class="comment">//告诉gin框架模板文件引用的静态文件去哪里找</span></span><br><span class="line">	r.LoadHTMLGlob(<span class="string">&quot;frontdevelop/templates/*&quot;</span>)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(<span class="number">200</span>, <span class="string">&quot;index.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> module.Modules &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;InitRouter: &quot;</span> + m.GetName())</span><br><span class="line">		m.InitRouter(r.Group(<span class="string">&quot;/&quot;</span> + m.GetName()))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">panic</span>(r.Run(<span class="string">&quot;:8080&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>现在的问题：把唯一标识符从name改到id</p>
<p>前端代码</p>
<p>todo中关于用户只能对自己的todo的删改</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>grpc入门</title>
    <url>/2024/07/13/grpc/</url>
    <content><![CDATA[<h1 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h1><h2 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h2><p>要知道什么是 gRPC ，先要了解 RPC（Remote Procedure Call，远程过程调用）</p>
<p>什么叫做远程过程调用捏？比如说，你在写程序的时候，可以很方便地调用你本地写的函数，但是，如果你想调用其他程序的函数，那该怎么办呢？</p>
<p>答案是使用 RPC ，它做到这一点，即使目标函数的程序跑在地球的另一边，都没有问题</p>
<h2 id="什么是-gRPC"><a href="#什么是-gRPC" class="headerlink" title="什么是 gRPC"></a>什么是 gRPC</h2><p><a href="https://grpc.io/">gRPC</a> 是一个出名的 RPC 框架，它速度很快，而且支持多种语言，它允许你可以在 Go 中调用 Java 乃至 Python 中的函数</p>
<p>多语言支持是怎么做到的呢？那中间必然是要借助某种通用介质，在这里就是 Protocol Buffers</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先在github<a href="https://github.com/protocolbuffers/protobuf/releases/tag/v21.5">Release Protocol Buffers v21.5 · protocolbuffers&#x2F;protobuf (github.com)</a>上安装适合自己的版本，然后在配置一下环境变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get google.golang.org/grpc</span><br><span class="line"><span class="keyword">go</span> install google.golang.org/grpc/cmd/protoc-gen-<span class="keyword">go</span>-grpc@latest</span><br><span class="line"><span class="keyword">go</span> install google.golang.org/protobuf/cmd/protoc-gen-<span class="keyword">go</span>@latest  </span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">|-- go.mod</span><br><span class="line">|-- go.sum</span><br><span class="line">|-- hello-client</span><br><span class="line">|   |-- main.go</span><br><span class="line">|   `-- proto</span><br><span class="line">|       |-- hello.pb.go</span><br><span class="line">|       |-- hello.proto</span><br><span class="line">|       `-- hello_grpc.pb.go</span><br><span class="line">`-- hello-server</span><br><span class="line">    |-- main.go</span><br><span class="line">    `-- proto</span><br><span class="line">        |-- hello.pb.go</span><br><span class="line">        |-- hello.proto</span><br><span class="line">        `-- hello_grpc.pb.go</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>hello.proto</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是在说明我们使用的是proto3语法。</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这部分的内容是关于最后生成的go文件是处在哪个目录哪个包中，,代表在当前目录生成，service代表了生成的go文件的包名是service。</span></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;.;service&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后我们需要定义一个服务，在这个服务中需要有一个方法，这个方法可以接受客户端的参数，再返回服务端的响应。</span></span><br><span class="line"><span class="comment">//其实很容易可以看出，我们定义了一个service，称为SayHello，这个服务中有一个rpc方法，名为SayHello.</span></span><br><span class="line"><span class="comment">//这个方法会发送一个HelloRequest，然后返回一个HelloResponse。</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">SayHello</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//message关键字，其实你可以理解为Golang中的结构体。</span></span><br><span class="line"><span class="comment">// 这里比较特别的是变最后面的“赋值&quot;。注意，这里并不是赋值，而是在定义这个变量在这个message中的位置。</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int64</span> age = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloResponse</span> &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是<code>server</code>和<code>client</code>共用的约束,之后cd到proto的目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS D:\work\code\GO\grpc_study\hello-server\proto&gt; protoc --go_out=. hello.proto</span><br><span class="line">PS D:\work\code\GO\grpc_study\hello-server\proto&gt; protoc --go-grpc_out=. hello.proto</span><br></pre></td></tr></table></figure>

<p>接下来就在proto中自动生成了两个文件，<code>hello.pb.go</code>和<code>hello_grpc.go</code></p>
<ol>
<li><strong>生成 Protocol Buffers 消息类型的 Go 代码</strong></li>
</ol>
<p>命令 <code>protoc --go_out=. hello.proto</code> 专门用于生成 Protocol Buffers 消息的 Go 代码。这些代码代表了 <code>.proto</code> 文件中定义的消息类型（<code>message</code>），为每种消息类型生成了一个 Go 结构体。这些结构体用于在 Go 程序中序列化和反序列化数据，使数据可以以二进制形式进行高效的存储和传输。</p>
<p>生成的代码包括：</p>
<ul>
<li>Go 结构体定义，对应于 <code>.proto</code> 文件中的每个 <code>message</code>。</li>
<li>用于序列化（将结构体数据转换为二进制格式）和反序列化（将二进制格式还原为结构体数据）的方法。</li>
</ul>
<ol start="2">
<li><strong>生成 gRPC 服务的 Go 代码</strong></li>
</ol>
<p>命令 <code>protoc --go-grpc_out=. hello.proto</code> 用于生成 gRPC 服务的代码。当 <code>.proto</code> 文件中定义了服务（<code>service</code>）和 RPC 方法时，这个命令生成与之对应的 Go 接口以及服务端和客户端的桩代码（stub）。这些代码是实现和使用 gRPC 服务的基础。</p>
<p><code>hello_grpc.go</code>中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *sayHelloClient)</span></span> SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    cOpts := <span class="built_in">append</span>([]grpc.CallOption&#123;grpc.StaticMethod()&#125;, opts...)</span><br><span class="line">    out := <span class="built_in">new</span>(HelloResponse)</span><br><span class="line">    <span class="comment">//实现业务逻辑</span></span><br><span class="line">    err := c.cc.Invoke(ctx, SayHello_SayHello_FullMethodName, in, out, cOpts...)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这句话可以在标注的地方重写方法来实现业务逻辑</p>
<h1 id="proto文件介绍"><a href="#proto文件介绍" class="headerlink" title="proto文件介绍"></a>proto文件介绍</h1><p>切片：<code>repeated string hobby = 3;</code></p>
<p>结构体：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int64</span> age = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">string</span> hobby = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="type">string</span> city = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> street = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要需要在外部重用这个消息类型就使用<code>HelloRequest.Address</code>就行了</p>
<p>服务定义：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">SearchService</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> 服务函数名(参数)<span class="keyword">returns</span>(返回参数)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h1><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240713130031634.png" alt="image-20240713130031634"></p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>main.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	service <span class="string">&quot;grpc_study/hello-server/proto&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个服务，在hello.pb.go中找到结构体</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	service.UnimplementedSayHelloServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写SayHello方法，在hello_grpc中找到方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, req *service.HelloRequest) (*service.HelloResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;service.HelloResponse&#123;Message: <span class="string">&quot;Hello &quot;</span> + req.Name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//开启端口</span></span><br><span class="line">	listen, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">	<span class="comment">//创建grpc服务</span></span><br><span class="line">	grpcServer := grpc.NewServer()</span><br><span class="line">	<span class="comment">//在grpc服务端中注册服务</span></span><br><span class="line">	service.RegisterSayHelloServer(grpcServer, &amp;server&#123;&#125;)</span><br><span class="line">	<span class="comment">//启动服务</span></span><br><span class="line">	err := grpcServer.Serve(listen)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;failed to serve: &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">	service <span class="string">&quot;grpc_study/hello-server/proto&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//与目标服务建立连接</span></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost:9090&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;grpc.Dial err: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭连接</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(conn *grpc.ClientConn)</span></span> &#123;</span><br><span class="line">		err := conn.Close()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;conn.Close err: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(conn)</span><br><span class="line">	<span class="comment">//建立连接</span></span><br><span class="line">	client := service.NewSayHelloClient(conn)</span><br><span class="line">	<span class="comment">//执行rpc调用（这个方法在服务器端来实现并返回结果）</span></span><br><span class="line">	resp, _ := client.SayHello(context.Background(), &amp;service.HelloRequest&#123;Name: <span class="string">&quot;xieyifeng&quot;</span>, Age: <span class="number">18</span>, Hobby: []<span class="type">string</span>&#123;<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;足球&quot;</span>&#125;&#125;)</span><br><span class="line">	fmt.Println(resp.GetMessage())</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>先运行sever，然后再运行client</p>
<p>得到结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello xieyifeng</span><br></pre></td></tr></table></figure>

<p>但是这样不安全，我们在客户端应该启用验证和加密</p>
<h2 id="加密和认证"><a href="#加密和认证" class="headerlink" title="加密和认证"></a>加密和认证</h2><ul>
<li>使用SSL&#x2F;TLS认证方式（http2）</li>
<li>使用token认证</li>
</ul>
<h3 id="使用ssl"><a href="#使用ssl" class="headerlink" title="使用ssl"></a>使用ssl</h3><p>[<a href="https://www.openssl.org/source/"> Downloads ] - &#x2F;source&#x2F;index.html (openssl.org)</a></p>
<p>这个需要c语言编译，可以直接使用<a href="https://slproweb.com/products/Win32OpenSSL.html">Win32&#x2F;Win64 OpenSSL Installer for Windows - Shining Light Productions (slproweb.com)</a></p>
<p>之后配一下系统变量就行了</p>
<p>在项目文件夹下建立key文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//生成私钥</span><br><span class="line">PS D:\work\code\GO\grpc_study\key&gt; openssl genrsa -out server.key 2048</span><br><span class="line">生成证书</span><br><span class="line">//PS D:\work\code\GO\grpc_study\key&gt; openssl req -new -x509 -key server.key -out server.crt -days 36500</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后会有让你填写一些信息，可以全部回车</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//生成scr：证书签名请求文件，用于提交给帧数颁发机构对证书签名。</span><br><span class="line">PS D:\work\code\GO\grpc_study\key&gt; openssl req -new -key server.key -out server.csr</span><br></pre></td></tr></table></figure>

<p>之后也是一路回车</p>
<p>接下来要更改 <a href="......%5COpenSSL-Win64%5Cbin%5Copenssl.cfg">openssl.cfg</a> （从spenssl&#x2F;bin下面复制一份到key下面）</p>
<ol>
<li><p>把copy_extensions &#x3D; copy前面的注释给去掉</p>
</li>
<li><p>把req_extensions前面的注释也给去掉</p>
</li>
<li><p>在v3_req中添加 <code>subjectAltName=@alt_names</code>，然后添加域名</p>
</li>
<li><pre><code>[ v3_req ]

# Extensions to add to a certificate request

basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment

subjectAltName=@alt_names

[ alt_names ]
DNS.1=*.kuangstudy.com

[ v3_ca ]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 生成证书私钥test.key`openssl genpkey -algorithm RSA -out test.key`</span><br><span class="line"></span><br><span class="line">6. 通过私钥生和刚才修改的配置文件成证书请求文件test.csr`openssl req -new -nodes -key test.key -out test.csr -days 3650 -subj &quot;/C=cn/OU=myorg/O=mycomp/CN=myname&quot; -config ./openssl.cfg -extensions v3_req`</span><br><span class="line"></span><br><span class="line">7. 生成SAN证书pem`openssl x509 -req -days 365 -in test.csr -out test.pem -CA server.crt -CAkey server.key -CAcreateserial -extfile ./openssl.cfg -extensions v3_req`注意cnf和cfg</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">最终需要的文件就两个，一个是test.key一个是test.pem</span><br><span class="line"></span><br><span class="line">之后修改服务端的main</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">func main() &#123;</span><br><span class="line">    creds, _ := credentials.NewServerTLSFromFile(&quot;D:\\work\\code\\GO\\grpc_study\\key\\test.pem&quot;, &quot;D:\\work\\code\\GO\\grpc_study\\keys\\test.key&quot;)</span><br><span class="line">    //开启端口</span><br><span class="line">    listen, _ := net.Listen(&quot;tcp&quot;, &quot;:9090&quot;)</span><br><span class="line">    //创建grpc服务</span><br><span class="line">    grpcServer := grpc.NewServer(grpc.Creds(creds))//放进去</span><br><span class="line">    //在grpc服务端中注册服务</span><br><span class="line">    service.RegisterSayHelloServer(grpcServer, &amp;server&#123;&#125;)</span><br><span class="line">    //启动服务</span><br><span class="line">    err := grpcServer.Serve(listen)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">       fmt.Println(&quot;failed to serve: &quot;, err)</span><br><span class="line">       return</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>这个pem和key都是保存在服务端的，所以用绝对路径</p>
<p>之后完善一下客户端代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加载客户端证书</span></span><br><span class="line">    creds, err := credentials.NewClientTLSFromFile(<span class="string">&quot;D:\\work\\code\\GO\\grpc_study\\key\\test.pem&quot;</span>, <span class="string">&quot;*.xxx.com&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       log.Fatalf(<span class="string">&quot;Failed to load credentials: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与目标服务建立连接</span></span><br><span class="line">    conn, err := grpc.Dial(<span class="string">&quot;localhost:9090&quot;</span>, grpc.WithTransportCredentials(creds))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       log.Fatalf(<span class="string">&quot;grpc.Dial err: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立客户端</span></span><br><span class="line">    client := service.NewSayHelloClient(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行RPC调用</span></span><br><span class="line">    resp, err := client.SayHello(context.Background(), &amp;service.HelloRequest&#123;Name: <span class="string">&quot;xieyifeng&quot;</span>, Age: <span class="number">18</span>, Hobby: []<span class="type">string</span>&#123;<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;足球&quot;</span>&#125;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       log.Fatalf(<span class="string">&quot;Error when calling SayHello: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(resp.GetMessage())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行就连接成功了</p>
<h3 id="使用token认证"><a href="#使用token认证" class="headerlink" title="使用token认证"></a>使用token认证</h3><p>可以直接看grpc提供的接口，这个接口有两个方法，位于credentials包下面，这个接口需要客户端去实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PerRPCCredentials <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// GetRequestMetadata gets the current request metadata, refreshing tokens</span></span><br><span class="line">	<span class="comment">// if required. This should be called by the transport layer on each</span></span><br><span class="line">	<span class="comment">// request, and the data should be populated in headers or other</span></span><br><span class="line">	<span class="comment">// context. If a status code is returned, it will be used as the status for</span></span><br><span class="line">	<span class="comment">// the RPC (restricted to an allowable set of codes as defined by gRFC</span></span><br><span class="line">	<span class="comment">// A54). uri is the URI of the entry point for the request.  When supported</span></span><br><span class="line">	<span class="comment">// by the underlying implementation, ctx can be used for timeout and</span></span><br><span class="line">	<span class="comment">// cancellation. Additionally, RequestInfo data will be available via ctx</span></span><br><span class="line">	<span class="comment">// to this call.  TODO(zhaoq): Define the set of the qualified keys instead</span></span><br><span class="line">	<span class="comment">// of leaving it as an arbitrary string.</span></span><br><span class="line">	GetRequestMetadata(ctx context.Context, uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// RequireTransportSecurity indicates whether the credentials requires</span></span><br><span class="line">	<span class="comment">// transport security.</span></span><br><span class="line">	RequireTransportSecurity() <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个方法作用是获取元数据信息，也就是客户端提供的key,value对，context用于控制超时和取消，uri是请求入口处的uri</li>
<li>第二个方法的作用是否需要基于 TLS 认证进行安全传输，如果返回值是true，则必须加上TLS验证，返回值是false则不用。</li>
</ul>
<p>在客户端中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ClientTokenAuth <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ClientTokenAuth)</span></span> GetRequestMetadata(ctx context.Context, uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;appId&quot;</span>:  <span class="string">&quot;xieyifeng&quot;</span>,</span><br><span class="line">		<span class="string">&quot;appKey&quot;</span>: <span class="string">&quot;123123&quot;</span>,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ClientTokenAuth)</span></span> RequireTransportSecurity() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写这个方法，可以向服务端返回这些个人信息来用来认证，然后在main中修改</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> opts []grpc.DialOption</span><br><span class="line">opts = <span class="built_in">append</span>(opts, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">opts = <span class="built_in">append</span>(opts, grpc.WithPerRPCCredentials(<span class="built_in">new</span>(ClientTokenAuth)))</span><br><span class="line"><span class="comment">// 与目标服务建立连接</span></span><br><span class="line">conn, err := grpc.NewClient(<span class="string">&quot;localhost:9090&quot;</span>, opts...)</span><br></pre></td></tr></table></figure>

<p>在服务端中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, req *service.HelloRequest) (*service.HelloResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">//获取元数据信息</span></span><br><span class="line">    md, ok := metadata.FromIncomingContext(ctx) <span class="comment">//可以从ctx中获取元数据信息</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;missing metadata&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(md)</span><br><span class="line">    <span class="keyword">var</span> appid <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> appkey <span class="type">string</span></span><br><span class="line">    <span class="keyword">if</span> val, ok := md[<span class="string">&quot;appid&quot;</span>]; ok &#123;</span><br><span class="line">       appid = val[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> val, ok := md[<span class="string">&quot;appkey&quot;</span>]; ok &#123;</span><br><span class="line">       appkey = val[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常是在数据库里面查询appid和appkey是否正确</span></span><br><span class="line">    <span class="keyword">if</span> appid != <span class="string">&quot;xieyifeng&quot;</span> || appkey != <span class="string">&quot;123123&quot;</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;appid or appkey is invalid&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;service.HelloResponse&#123;Message: <span class="string">&quot;Hello &quot;</span> + req.Name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把这个方法中加入校验机制</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>html介绍</title>
    <url>/2024/04/21/html%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>HTML(hypertext markup language)，用于define 网页的内容，如果说网页时房子，那么html就是地基</p>
<p>，css是决定房子的颜色，JS是house的功能控制者，可以例如门的开关。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>客户端输入网址，服务器会发送一个html文件。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>在goland中新建一个html文件，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>this is my first webpages<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">this is my first webpages</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在相应位置输入信息，打开网页</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240421164150236.png" alt="image-20240421164150236"></p>
<p>在body中我们可以决定在网页上面的显示，接下来我们学习如何是文本更加多样化</p>
<h1 id="简单网页搭建"><a href="#简单网页搭建" class="headerlink" title="简单网页搭建"></a>简单网页搭建</h1><p>在body中建立一个header的组</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>this is my first webpages<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/contact&quot;</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Post Title<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Post Content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>&lt;!DOCTYPE html&gt;</code>：声明这是一个 HTML5 文档。</p>
</li>
<li><p><code>&lt;html lang=&quot;en&quot;&gt;</code>：根元素标签，表示整个页面的内容；<code>lang=&quot;en&quot;</code> 属性声明页面主要内容是英语。</p>
</li>
<li><pre><code>&lt;head&gt;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   ：包含文档的元数据，不会显示在页面内容中。</span><br><span class="line"></span><br><span class="line">   - `&lt;meta charset=&quot;UTF-8&quot;&gt;`：设置文档的字符编码为 UTF-8，这是国际编码标准，可以支持大多数语言字符的显示。</span><br><span class="line">   - `&lt;title&gt;`：指定了网页的标题，会显示在浏览器的标签页上。</span><br><span class="line"></span><br><span class="line">4. ```</span><br><span class="line">   &lt;body&gt;</span><br></pre></td></tr></table></figure>

：包含了可见的页面内容。

- ```
  &lt;header&gt;
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">：定义了页面的头部区域。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  &lt;nav&gt;</span><br></pre></td></tr></table></figure>

    ：定义导航链接的部分。

    - ```
      &lt;ul&gt;
      <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">：无序列表，通常用于创建菜单。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  &lt;li&gt;</span><br></pre></td></tr></table></figure>

        ：列表项，通常用在列表中表示各个列表条目。

        - `&lt;a href=&quot;...&quot;&gt;`：锚标签，用来创建超链接，`href` 属性指定链接目标地址。

  - `&lt;hr&gt;`：水平线，用于内容分隔。

- ```
  &lt;section&gt;
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">：定义文档中的一个独立的区段，通常包含一组相关内容。</span><br><span class="line"></span><br><span class="line">- `&lt;h2&gt;`：二级标题。</span><br><span class="line"></span><br><span class="line">- `&lt;button&gt;`：按钮，可以通过 JavaScript 来定义点击时的行为。</span><br><span class="line"></span><br><span class="line">- `&lt;br&gt;`：换行，用于内容中断点处。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  &lt;div&gt;</span><br></pre></td></tr></table></figure>

    ：块级元素，用于布局和组织内容。

    - `&lt;strong&gt;`：加粗文本，表示重要性。

    - `&lt;span&gt;`：内联容器，用于标记文本，以便通过 CSS 或 JavaScript 进行样式化或操作。

    - `&lt;p&gt;`：段落。

    - ```
      &lt;a&gt;
      <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">：锚标签，同上。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  &lt;img src=&quot;...&quot; style=&quot;...&quot;/&gt;</span><br></pre></td></tr></table></figure>

        ：图像标签，

        <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br></pre></td></tr></table></figure>

         

        属性指定图像文件路径，

        <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">style</span><br></pre></td></tr></table></figure>

         

        属性内联定义 CSS 样式。

        - `style=&quot;width: 10vw; min-width: 60px&quot;`：CSS 样式，设置图像宽度为视口宽度的10%，最小宽度为60像素。

  - `&lt;input type=&quot;number&quot; value=&quot;1&quot; min=&quot;1&quot; max=&quot;10&quot;&gt;`：数字输入框，允许用户输入一个数字，定义了默认值、最小值和最大值。

- ```
  &lt;footer&gt;
</code></pre>
<p>  ：定义了页面的底部区域。</p>
<ul>
<li><code>&lt;p&gt;</code>：段落，用于存放文本。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>mm32学习</title>
    <url>/2024/07/15/mm32%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="使用imu660ra进行imu姿态演算"><a href="#使用imu660ra进行imu姿态演算" class="headerlink" title="使用imu660ra进行imu姿态演算"></a>使用imu660ra进行imu姿态演算</h1><p>任务描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMU姿态解算，要求使用六轴IMU解算出当前车辆的yaw轴、roll轴、pitch轴角度（可采用互补滤波等方法），由于yaw轴存在难以消除的漂移，尽量做到1分钟漂移1度以下。陀螺仪建议购买mpu6050或imu660ra。 </span><br></pre></td></tr></table></figure>

<p>任务解读：</p>
<p><strong>1.Yaw、Roll和Pitch角度</strong>：</p>
<ul>
<li><strong>Yaw（偏航角）</strong>：围绕垂直轴的旋转，如转向左或右。</li>
<li><strong>Roll（横滚角）</strong>：围绕前进方向的轴的旋转，如当车辆在弯道中侧倾时。</li>
<li><strong>Pitch（俯仰角）</strong>：围绕横向轴的旋转，如当车辆上坡或下坡时。</li>
</ul>
<p><strong>2.互补滤波器</strong>：</p>
<ul>
<li>这是一种简单有效的算法，用于结合加速度计和陀螺仪的数据，以提高角度估计的准确性。加速度计测量的是重力方向，可用来估计俯仰角和横滚角；而陀螺仪测量的是角速度，可以通过积分得到连续的角度变化。</li>
<li>互补滤波器的关键思想是将加速度计得到的稳定但慢速响应的角度估计与陀螺仪的快速但会漂移的角度估计进行合适比例的融合。</li>
</ul>
<p><strong>3.Yaw轴的漂移问题</strong>：</p>
<ul>
<li>由于陀螺仪在长时间内会积累误差导致的角度漂移，特别是在偏航角度的测量中较为显著。</li>
</ul>
<h2 id="串口的输出"><a href="#串口的输出" class="headerlink" title="串口的输出"></a>串口的输出</h2>]]></content>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础</title>
    <url>/2024/03/04/java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>半解释半编译的</p>
<p>源代码：java ——&gt;编译：javac.exe——&gt;字节码:class——&gt;解释：java.exe——&gt;机器。</p>
<h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><p>bin:该路径下存放了各种工具命令。其中比较重要的有:javac和java</p>
<p>conf:该路径下存放了相关配置文件。<br>include:该路径下存放了一些平台特定的头文件，<br>jmods:该路径下存放了各种模块。<br>legal:该路径下存放了各模块的授权文档，<br>lib:该路径下存放了工具的一些补充JAR包。</p>
<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><p>文件名为Hello.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span>&#123;<span class="comment">//类和类名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：javac Hello.java</p>
<p>生成Hello.class（这个Hello类名，不是文件名，如果文件名修改的话也不变）</p>
<p>解释：java hello</p>
<p>出现hello world</p>
<h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p>这段Java代码定义了一个简单的程序，下面是对程序各部分的解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java复制class Hello &#123; // 类和类名</span><br></pre></td></tr></table></figure>

<ul>
<li><code>class Hello &#123;</code>：这是一个类的声明。在Java中，所有的函数和变量必须存在于类中。这里定义了一个名为<code>Hello</code>的类。Java文件名通常与public类的名称相同（如果有public类的话），并且每个<code>.java</code>文件可以包含一个public类。在这个情况下，<code>Hello</code>类不是public的，所以文件名不一定要与类名相同。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java复制    public static void main(String[] args) &#123;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public</code>：这是一个访问修饰符，表示<code>main</code>方法可以被任何对象或者类访问。</li>
<li><code>static</code>：表示<code>main</code>方法不需要创建类的实例就可以执行。这是必须的，因为<code>main</code>方法是程序的入口点，必须在程序启动时就能够被调用。</li>
<li><code>void</code>：表示<code>main</code>方法不返回任何值。</li>
<li><code>main</code>：这是程序的起始点。当Java程序被启动时，JVM寻找并调用<code>main</code>方法。</li>
<li><code>String[] args</code>：<code>main</code>方法接受一个参数，即<code>args</code>，它是一个<code>String</code>数组。这允许用户传递命令行参数给程序。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java复制        System.out.println(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>System.out.println</code>：这是一个命令，用来在控制台输出信息。<code>System</code>是一个预先定义的类，它提供了访问系统相关的属性和方法。<code>out</code>是<code>System</code>类的一个静态变量，指向<code>PrintStream</code>类型的实例，它连接到标准输出，通常是控制台。<code>println</code>是一个方法，用来输出一行信息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java复制    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这些括号标记了类定义和<code>main</code>方法的结束。</li>
</ul>
<p>总的来说，这段代码定义了一个名为<code>Hello</code>的类，它包含一个执行时会被JVM调用的<code>main</code>方法。<code>main</code>方法向控制台输出字符串”hello world”。这是最基础的Java程序结构，通常用于演示和教学目的。</p>
<h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><p>文件里面有公共类（public）的定义，类名要和文件名相同，类名开头要大写</p>
<p>如果一个源文件有多个类，如果编译之后会有对应的多个class文件，可以分个解释</p>
<p>常量要全大写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AGE=<span class="number">18</span>;</span><br></pre></td></tr></table></figure>



<h1 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h1><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240311143007971.png" alt="image-20240311143007971"></p>
<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><p>以下是基本数据类型之间的转换规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 从低容量到高容量（隐式）：</span><br><span class="line">  - byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</span><br><span class="line">  - char -&gt; int</span><br><span class="line">- 从高容量到低容量（显式）：</span><br><span class="line">  - double -&gt; float -&gt; long -&gt; int -&gt; short -&gt; byte</span><br><span class="line">  - 任何类型 -&gt; char (需要显式转换，且必须是兼容的值)</span><br></pre></td></tr></table></figure>

<p>xxxxxxxxxx %d:十进制整数。%i:整数，基本等同于%d。%f:小数（包含 float 类型和 double类型) 。%Lf: long double类型浮点。%p:指针。%s:字符串。%%:输出一个百分号。%c:字符。%ld:十进制 long int类型。%lld:十进制 long long类型。c</p>
<h1 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h1><h2 id="Sanner"><a href="#Sanner" class="headerlink" title="Sanner"></a>Sanner</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//这行代码创建了一个Scanner对象sc，使用System.in作为输入流，这通常指的是键盘输入。</span></span><br><span class="line">        <span class="type">boolean</span> a=sc.nextBoolean();</span><br><span class="line">        <span class="type">int</span> b=sc.nextInt();</span><br><span class="line">        <span class="type">double</span> c=sc.nextDouble();</span><br><span class="line">        String d=sc.next();<span class="comment">//字符</span></span><br><span class="line">        System.out.println(a+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nextline"><a href="#nextline" class="headerlink" title="nextline"></a>nextline</h3><p>如果经常出现超时的情况，可以试一下用nextline而非nextint之类的，一次性读取所有数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.*; <span class="comment">//导入包</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *@param args</span></span><br><span class="line"><span class="comment"> @return void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        String[] str=sc.nextLine().split(<span class="string">&quot; &quot;</span>);<span class="comment">//将输入的字符串以空格分割</span></span><br><span class="line">        System.out.println(Float.valueOf(str[<span class="number">0</span>]));<span class="comment">//将字符串转换为浮点数</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.*; <span class="comment">//导入包</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *@param args</span></span><br><span class="line"><span class="comment"> @return void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            a =System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="面向对象编程概述-object-oriented"><a href="#面向对象编程概述-object-oriented" class="headerlink" title="面向对象编程概述(object oriented)"></a>面向对象编程概述(object oriented)</h2><p>要开一辆车</p>
<p><strong>面向过程：</strong>写一个drivecar()函数</p>
<p><strong>面向对象：</strong>先构建一个对象Car，然后在对象中声明成员的属性以及成员函数，然后就可以在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;<span class="comment">//类名,抽象,不分配内存</span></span><br><span class="line">    <span class="comment">//成员变量,数据,属性.</span></span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="comment">//成员函数,方法,行为.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">perimeter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*(width+height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">area</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width*height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRectangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Rectangle r=<span class="keyword">new</span> <span class="title class_">Rectangle</span>();<span class="comment">//创建对象r,分配内存,就是实例化,将width和height赋值为0</span></span><br><span class="line">        <span class="comment">//r里面储存了width,height,perimeter(),area()的地址</span></span><br><span class="line">        r.width=<span class="number">10</span>;</span><br><span class="line">        r.height=<span class="number">20</span>;</span><br><span class="line">        System.out.println(r.perimeter());</span><br><span class="line">        System.out.println(r.area());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>面向对象编程主要基于以下四大基本概念：</p>
<ol>
<li><strong>封装</strong>：封装是指将数据（属性）和代码（方法）包装到单一的单位——对象中，并对对象的实际实现细节进行隐藏。在Java中，通过使用类来实现封装。类的成员变量通常被声明为私有（private），这意味着它们只能被类的方法访问。对外部世界隐藏对象的内部复杂性，同时提供可以被外界public访问的接口。</li>
<li><strong>继承</strong>：继承是一种创建新类的方式，新创建的类包含了另一个类的所有属性和方法。这使得代码的重用成为可能，并且可以在现有的基础上增加新的功能。在Java中，继承是通过<code>extends</code>关键字实现的。动物extends猫，狗，猫extends老虎，豹子</li>
<li><strong>多态</strong>：多态性意味着可以将子类的对象视为其父类的实例。这主要是通过重写（Overriding）实现的，即子类有一个与父类相同名称和参数的方法。Java还支持通过接口实现多态。多态允许同一接口使用不同的实现，提高了程序的扩展性和灵活性。不同对象调用相同方法时候会不一样，比如让老鼠和猫叫，方法是一样的，但是声音是不一样的。</li>
<li><strong>抽象</strong>：抽象是一种将复杂的现实转换成简单模型的方法，这通常涉及到创建抽象类和接口。抽象类是不能被实例化的类，用于声明类的某些部分为抽象的，即没有提供实现的方法。子类负责提供这些方法的实现。接口则是完全抽象的，只包含方法声明，而没有任何实现。</li>
</ol>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>定义类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    Person(<span class="type">int</span> a)&#123;</span><br><span class="line">        age=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">()</span>&#123;</span><br><span class="line">        age++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        age+=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建对象p1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">10</span>);</span><br><span class="line">p.show();</span><br><span class="line">p.grow();</span><br><span class="line">p.show();</span><br><span class="line">p.grow(<span class="number">10</span>);</span><br><span class="line">p.show();</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>在一个类里面，方法名相同，功能类似但是参数不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">POINT_test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Point P1=<span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">        P1.printPoint();</span><br><span class="line">        P1.distance();</span><br><span class="line">        Point P2=<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        P2.printPoint();</span><br><span class="line">        P2.distance();</span><br><span class="line">        System.out.println(P1.distance(P2));</span><br><span class="line">        System.out.println(P2.distance(P1,P2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    Point(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">        x=a;</span><br><span class="line">        y=b;</span><br><span class="line">    &#125;</span><br><span class="line">    Point()&#123;</span><br><span class="line">        x=sc.nextInt();</span><br><span class="line">        y=sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printPoint</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(&quot;</span>+x+<span class="string">&quot;,&quot;</span>+y+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">distance</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(x*x+y*y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">distance</span><span class="params">(Point q)</span>&#123;<span class="comment">//这里传入不同的参数，this代表着当前的对象</span></span><br><span class="line">        <span class="keyword">return</span> Math.sqrt((<span class="built_in">this</span>.x-q.x)*(<span class="built_in">this</span>.x-q.x)+(<span class="built_in">this</span>.y-q.y)*(<span class="built_in">this</span>.y-q.y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">(Point p,Point q)</span>&#123;<span class="comment">//像这个与传入的参数没什么关系的函数可使用static，可以不产生对象直接使用Point当对象。</span></span><br><span class="line">        <span class="keyword">return</span> Math.sqrt((p.x-q.x)*(p.x-q.x)+(p.y-q.y)*(p.y-q.y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：java可以同名不同参</p>
</blockquote>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>有时候一个对象只用一次的时候，我们就直接只用new Point(1,1)来操作，从而减少内存浪费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">1</span>).distance();</span><br></pre></td></tr></table></figure>

<h2 id="实现类的封装性"><a href="#实现类的封装性" class="headerlink" title="实现类的封装性"></a>实现类的封装性</h2><p>为了实现良好的封装性，通常将成员变量设置为<strong>private</strong></p>
<p>通过<strong>public的方法</strong>来访问这个变量</p>
<p>这些public的方法一般都是读取和赋值的操作。</p>
<h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x=x;<span class="comment">//我们要使用this.才能改变对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="直接用this构造函数"><a href="#直接用this构造函数" class="headerlink" title="直接用this构造函数"></a>直接用this构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Point(<span class="type">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Point</span>(a,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Point P3=<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>这样调用是无法传入P3值的</p>
<p>可以用this构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Point(<span class="type">int</span> a)&#123;</span><br><span class="line">    <span class="built_in">this</span>(a,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意！！！！！：使用这个方法的前提是要先定义<code>Point(int a,int b)</code>这个构造函数，而且不能再它函数里面自己调用自己。</p>
<h3 id="缺省构造函数"><a href="#缺省构造函数" class="headerlink" title="缺省构造函数"></a>缺省构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 这里没有显式定义构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 调用了MyClass的缺省构造方法来创建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果一个类中没有显式地定义任何构造方法，Java编译器会自动为这个类提供一个无参的构造方法，这就是缺省构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式定义了一个有参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还需要无参数的构造方法，必须显式定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 缺省构造方法体，可以初始化默认值</span></span><br><span class="line">        <span class="built_in">this</span>.value = <span class="number">0</span>; <span class="comment">// 例如，为value成员变量赋一个默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果有显式的构造方法，那就必须定义无参数的方法。</p>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>将功能相近的类放在同一个包中，可以方便查找与使用</li>
<li>由于在不同包中可以存在同名类，所以使用包在一定程度上可以避免命名冲突</li>
<li>在Java中，某些访问权限是以包为单位的</li>
</ol>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h3><blockquote>
<p>final:使用此修饰符的类的不能被继承</p>
</blockquote>
<blockquote>
<p>abstract:该类是不允许被实例化的类，也就是说该类需要被扩展继承。被这样声明的类也称为抽象类。类中只要有一abstract方法，类就只能被定义为abstract</p>
</blockquote>
<h3 id="属性的修饰符"><a href="#属性的修饰符" class="headerlink" title="属性的修饰符"></a>属性的修饰符</h3><blockquote>
<p>final:常量，值只能分配一次，不能更改.可以同static一起使用，避免对类的每</p>
<p>个实例维护一个拷贝。</p>
</blockquote>
<blockquote>
<p>static:不用创建对象就可以直接调用.包括可以使用在成员上面，之后就可以任意使用此成员，无需另外准备,它指向同一个地址</p>
</blockquote>
<p><strong>例子：(共有的成员z，也就是所有对象的z都是一个z)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ABCD</span>&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> z=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Main&#123;</span><br><span class="line">    ABCD data1=<span class="keyword">new</span> <span class="title class_">ABCD</span>();</span><br><span class="line">&#125;<span class="comment">//无论是data1.z or ABCD.z，都是一个z=3；</span></span><br></pre></td></tr></table></figure>

<p>在静态的方法中不能调用非静态的对象，反之可以。静态的变量在类的声明的时候就已经</p>
<h3 id="方法的修饰符"><a href="#方法的修饰符" class="headerlink" title="方法的修饰符"></a>方法的修饰符</h3><blockquote>
<p>static:提供不依赖于类实例的服务并不需要创建类的实例就可以访问静态方法。静态方法只能访问静态变量，非静态的方法都可以访问。</p>
</blockquote>
<blockquote>
<p>final:防止任何子类覆盖该方法 .可以同static一起使用，避免对类的每个实例维护一个拷贝</p>
</blockquote>
<blockquote>
<p>abstract :抽象方法，类中有声明而没有实现的方法 不能将static方法、final方法或者类的构造器方法声明为abstract</p>
</blockquote>
<h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><blockquote>
<p>public:可以被所有类访问，public类必须定义在和类名相同的同名文件中</p>
</blockquote>
<blockquote>
<p>缺省:可以被同一个包中的类访问 。默认的访问权限，可以定义在和public类的同一个文件中</p>
</blockquote>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240408141935841.png" alt="image-20240408141935841"></p>
<h1 id="数组和java常用类"><a href="#数组和java常用类" class="headerlink" title="数组和java常用类"></a>数组和java常用类</h1><blockquote>
<p>数组的类型可以为基本数据类型(如int、char)，也可以为引用数据类型(如Point类、Circle类、int[])。</p>
</blockquote>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>每个初始化都必须要new 类型</p>
<h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] x=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//或者int[] x=new int[]&#123;1,2,3,4&#125;;，这里是省略了</span></span><br></pre></td></tr></table></figure>

<p>下面是错误做法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] x;</span><br><span class="line">x = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><p>一般来说在初始化数组的时候无需指定它的长度，只有在你想要创建一个具有指定大小但不立即初始化元素的数组时，你才明确指定数组的长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] months= <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">12</span>];<span class="comment">//每个数组元素默认为0</span></span><br></pre></td></tr></table></figure>

<p>说人话：初始化要么说明长度，要么说明具体元素</p>
<p>默认值的规定如下：</p>
<p><code>a) boolean类型的默认值是false。</code></p>
<p><code>b) 其它7种基本数据类型的默认值是0。其中char的默认值是编码为0的字符，而不是字符‘0’。</code></p>
<p><code>c) 引用数据类型的初始值是null。</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] x;<span class="comment">//声明但未初始化</span></span><br><span class="line">x = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>这样是可以的</p>
<h3 id="for-each-语句遍历"><a href="#for-each-语句遍历" class="headerlink" title="for each 语句遍历"></a>for each 语句遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(数据类型 变量名：数组名)</span><br><span class="line">	语句；</span><br><span class="line"><span class="comment">//数据类型必须与数组元素的数据类型相同</span></span><br></pre></td></tr></table></figure>

<p><strong>ex:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:arr)</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] xx;</span><br><span class="line">xx=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][]; </span><br><span class="line">xx[<span class="number">0</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">xx[<span class="number">1</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">xx[<span class="number">2</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240408153304214.png" alt="image-20240408153304214"></p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><strong>数据类型【】【】数组标识符 ;</strong></p>
<p>数据类型 数组标识符【】【】； </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] days;</span><br><span class="line"><span class="type">boolean</span> holidays[][];</span><br></pre></td></tr></table></figure>

<p>两种都可以</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><strong>（1）通过new关键字创建</strong></p>
<p><strong>（2）通过“{ }”创建</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] days = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">2</span>];<span class="comment">//其中的2可加可不加</span></span><br><span class="line">days[<span class="number">0</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;...&#125;</span><br><span class="line">.....</span><br><span class="line"><span class="type">boolean</span> holidays[][] = &#123; &#123; <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span> &#125;, &#123; <span class="literal">false</span>, <span class="literal">true</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><blockquote>
<p>java.util.Arrays类包含用来操作数组(如排序和搜索)的各种函数。</p>
</blockquote>
<p><code>Arrays.fill</code>函数将某个值赋值给数组全部或部分元素</p>
<p><code>Arrays.toString</code>、<code>Arrays.deepToString</code>函数打印数组元素</p>
<p><code>Arrays.copyOf</code>、<code>Arrays.copyOfRange</code>函数复制数组</p>
<p><code>Arrays.equals</code>、<code>Arrays.deepEquals</code>函数比较数组</p>
<p><code>Arrays.sort</code> 函数对数组元素从小到大排序</p>
<p><code>Arrays.binarySearch</code>函数在数组中检索目标元素是否存在</p>
<h2 id="包装类-Integer-Double-…"><a href="#包装类-Integer-Double-…" class="headerlink" title="包装类(Integer,Double …..)"></a>包装类(Integer,Double …..)</h2><blockquote>
<p>如何把一个十进制整数转化为二进制，八进制。。。。</p>
<p>如何进行基本类型的转换</p>
</blockquote>
<p>java中有一个默认的包java.lang包</p>
<p>包装类的常量<code>MAX VALUE</code>和<code>MIN VALUE</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.MAX VALUEint类型的最大值</span><br><span class="line">Integer.MIN VALUEint类型的最小值</span><br></pre></td></tr></table></figure>

<p>包装类的静态方法：</p>
<p>1.数据类型和字符串之间转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1=Integer.valueOf(<span class="number">100</span>);<span class="comment">//int转int（对象）</span></span><br><span class="line">Integer i2=Integer.valueOf(“<span class="number">123</span>”);  <span class="comment">//str转int（对象）</span></span><br><span class="line">String str=Integer.toString(<span class="number">123</span>);<span class="comment">//int转str（对象）</span></span><br><span class="line"><span class="type">double</span> i=Double.parseDouble( “<span class="number">123</span>”);<span class="comment">//字符串直接转double类型</span></span><br></pre></td></tr></table></figure>

<p>2.进制之间转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.toBinaryString(<span class="number">100</span>)<span class="comment">//2</span></span><br><span class="line">Integer.toOctalString(<span class="number">100</span>)<span class="comment">//8</span></span><br><span class="line">Integer.toHexString(<span class="number">100</span>)<span class="comment">//16</span></span><br></pre></td></tr></table></figure>

<p>3.自动拆箱装箱</p>
<p>在转化为int（对象）之后需要调用</p>
<p><code>int value = i1.intValue();</code>才可以获取值，但是在后面的版本中可以直接赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">Integer i2=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">Integer i3=<span class="number">789</span>;<span class="comment">//自动装箱 (直接给对象赋值)</span></span><br><span class="line"><span class="type">int</span> i4=i3;<span class="comment">//自动拆箱（直接获得i3对应的值到i4）</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><p>Java中的字符串作为对象处理，用字符串类封装一个字符串的字符序列及与之有关的其他操作，如求长度等。</p>
<p>字符串类位于java.lang包</p>
<p>常用有字符串类有:String、StringBuffer、!StringBuilder</p>
<h3 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h3><h4 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>.</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>首先要说明一点，与c不同，<code>char a[]=&quot;abc&quot;</code>是错误的,<code>String str=&quot;abc&quot;</code>是可以的</p>
<p><code>String s2 = new String(&quot;hello&quot;);</code>可以将<code>“hello”</code>位置的的数据转化为string类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">问题<span class="number">4</span>:以下能构造“java”字符串的语句是( )?</span><br><span class="line">    A、<span class="type">int</span> b[]= &#123;<span class="number">106</span>,<span class="number">97</span>,<span class="number">118</span>,<span class="number">97</span>&#125;;</span><br><span class="line">	   String s4=<span class="keyword">new</span> <span class="title class_">String</span>(b)</span><br><span class="line">    B、<span class="type">byte</span> c[]=&#123;<span class="number">106</span>,<span class="number">97</span>,<span class="number">118</span>,<span class="number">97</span>&#125;;</span><br><span class="line">	   String s5=<span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">	C、<span class="type">char</span> a[]=&#123; <span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;<span class="comment">//字符数组转化为String</span></span><br><span class="line">	   String s3=<span class="keyword">new</span> <span class="title class_">String</span>(a);</span><br></pre></td></tr></table></figure>

<p>A是错的，因为一个char占两个字节，int4个字节，byte一个字节，只能少不能多</p>
<h4 id="字符数组和字符串的转化"><a href="#字符数组和字符串的转化" class="headerlink" title="字符数组和字符串的转化"></a>字符数组和字符串的转化</h4><p>字符数组转化为字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] ch=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span><span class="string">&#x27;&#x27;</span>c<span class="string">&#x27;&#125;;</span></span><br><span class="line"><span class="string">String ascStr=ch.toString();//返回的是数组地址</span></span><br><span class="line"><span class="string">String str= newString(ch);//返回的是对应的字符串</span></span><br></pre></td></tr></table></figure>

<p>字符串转化为字符数组;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str= <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] ch = str.toCharArray();</span><br></pre></td></tr></table></figure>

<h4 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h4><p>1.求字符串长度<code>int length()</code></p>
<p>2.字符串的大小写转换：</p>
<p>​	<code>String toLowerCase()</code></p>
<p>​	<code>String toUppercase()</code></p>
<p>3.字符串连接：<code>String concat(String)</code></p>
<p>​	ex：<code>String str=&quot;This&quot;.concat(&quot;a demo&quot;);</code></p>
<p>4.前缀后缀判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String)</span>判断前缀是否匹配</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String)</span>判断后缀是否匹配</span><br></pre></td></tr></table></figure>

<p>5.是否相同：</p>
<p>“&#x3D;&#x3D;”是字符串储存地址比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object)</span>区分大小写</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String)</span>不区分大小写</span><br></pre></td></tr></table></figure>

<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415144917881.png" alt="image-20240415144917881"></p>
<p>6.比较大小(前减去后)，返回负数或者true，相同？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String)</span>区分大小写 </span><br><span class="line"><span class="type">int</span> <span class="title function_">compareToIgnoreCase</span><span class="params">(String)</span>不区分大小写</span><br></pre></td></tr></table></figure>

<p>7.检索字符</p>
<p> <img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415151429887.png" alt="image-20240415151429887"></p>
<p>8.截取子串</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415163402973.png" alt="image-20240415163402973"></p>
<h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p><strong>String类</strong></p>
<blockquote>
<p>定义不可变对象，一旦被创建，就不能修改它的值，对于已经存在的String对象的修改都是重新创建一个新的对象，然后把新的值保存进去。</p>
</blockquote>
<p><strong>StringBuffer类、StringBuilder类</strong></p>
<blockquote>
<p>定义可变对象，当对它进行修改的时候不会像String那样重新建立只能通过构造函数来建立StringBuffer可安全用于多线程编程StringBuilder用于多线程编程不安全，但速度更快</p>
</blockquote>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是一种创建新类的方式，新创建的类包含了另一个类的所有属性和方法。这使得代码的重用成为可能，并且可以在现有的基础上增加新的功能。在Java中，继承是通过<code>extends</code>关键字实现的。动物extends猫，狗，猫extends老虎，豹子</p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415145518728.png" alt="image-20240415145518728"></p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415145813680.png" alt="image-20240415145813680"></p>
<h2 id="方法的重写（override）"><a href="#方法的重写（override）" class="headerlink" title="方法的重写（override）"></a>方法的重写（override）</h2><p>重载是方法的参数改变了</p>
<p>在子类中声明与父类相同名字的函数，如果调用的话就遵守子类的声明，前提的参数，返回类型要一致，权限不能缩小，不能抛出新的异常。</p>
<p>final:写在成员变量前面，则此成员变量无法被修改</p>
<p>​	写在方法前面，则此方法无法重写</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415152840881.png" alt="image-20240415152840881"></p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240415152617052.png" alt="image-20240415152617052"></p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super变量表示父类对象</p>
<p>在子类中使用已经被这个子类重写过的方法，使用super.xxxx</p>
<h2 id="子类对象实例化"><a href="#子类对象实例化" class="headerlink" title="子类对象实例化"></a>子类对象实例化</h2><p>父类有无参构造函数，子类没有构造函数，在子类对象实例化的时候会直接调用父类的构造函数</p>
<p>父类有有参构造函数，子类用super使用,子类想要方法重载自己的构造函数，则可以直接使用this</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    Animal(String n,<span class="type">int</span> a)&#123;</span><br><span class="line">        name=n;</span><br><span class="line">        age=a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    String color;</span><br><span class="line">    Cat(String n,<span class="type">int</span> a,String c)&#123;</span><br><span class="line">        <span class="built_in">super</span>(n,a);<span class="comment">//必须在第一句</span></span><br><span class="line">        color=c;</span><br><span class="line">    &#125;</span><br><span class="line">    Cat()&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">2</span>,<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用时</span></span><br><span class="line">Cat c=<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;tom&quot;</span>,<span class="number">5</span>,<span class="string">&quot;white&quot;</span>);</span><br><span class="line">Cat b=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>

<p>要注意的是，虽然调用了子类自己的构造方法，但还是会隐式调用父类的无参构造方法</p>
<h1 id="多态-1"><a href="#多态-1" class="headerlink" title="多态"></a>多态</h1><p>多态是面向对象基本特征之一。</p>
<p>通常使用方法的重载（Overload）和重写（Override)实现类的多态性。</p>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>方法的重载是指在一个类中，出现多个<strong>方法名相同，但参数个数或参数类型不同</strong>的方法。</p>
<p>重载的方法之间并不一定必须有联系，但是为了提高程序的可读性，一般只重载功能相似的方法。</p>
<p>通过方法重载实现<strong>静态的多态</strong></p>
<h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>重写方法必须和被重写方法具有<strong>相同的方法名称、参数列表和返回值类型。</strong></p>
<p>通过重写父类的方法来实现，在运行时根据传递的对象引用，来调用相应的方法。</p>
<p>通过方法的重写，实现<strong>动态的多态性</strong></p>
<h2 id="向上（下）转型"><a href="#向上（下）转型" class="headerlink" title="向上（下）转型"></a>向上（下）转型</h2><h5 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h5><p>一个对象可以看做本类类型，也可以看做它的父类类型。取得一个对象的引用并将它看做父类的对象，称为向上转型。</p>
<h5 id="对象的类型转换"><a href="#对象的类型转换" class="headerlink" title="对象的类型转换"></a>对象的类型转换</h5><p>子类对象可以自动转换成父类对象</p>
<p>父类对象不能转换成子类对象</p>
<p>可以用instanceof 操作符来判断一个实例对象是否属于一个类</p>
<p>强制转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">shape s=Circle(<span class="string">&quot;cir&quot;</span>,<span class="number">10</span>);<span class="comment">//向上</span></span><br><span class="line">c=(Circle)s;<span class="comment">//向下</span></span><br></pre></td></tr></table></figure>

<h2 id="特殊类"><a href="#特殊类" class="headerlink" title="特殊类"></a>特殊类</h2><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>使用final关键字修饰的类不能被继承</p>
<h5 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h5><p>抽象类不能被实例化，只能被子类继承。</p>
<p>如果一个子类没有实现抽象父类中所有的抽象方法，则子类也成为一个抽象类；如果一个子类实现抽象父类中所有的抽象方法，则子类不是一个抽象类。</p>
<p>我们可以将一个没有任何抽象方法的类声明为abstract，避免由这个类产生任何的对象。</p>
<p>构造方法、static方法、private方法、final方法不能被声明为抽象的方法。</p>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>内部类就是在其他类内部定义的类。</p>
<blockquote>
<p>内部类的作用</p>
</blockquote>
<p> 隐藏你不想让别人知道的操作，也即封装性。</p>
<p> 一个内部类对象可以访问创建它的外部类对象的内容，甚至包括私有变量。</p>
<p>内部类有以下四种形式：成员内部类、局部内部类、静态内部类、匿名内部类。</p>
<h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index=<span class="number">100</span>; <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        Inner i=<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        i.print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123; <span class="comment">// 成员内部类</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> out.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.print()</span><br></pre></td></tr></table></figure>

<p>只有创建了成员内部类的实例，才能使用成员内部类的变量和方法。</p>
<h4 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h4><p>就是没有名名称的内部类，一般格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ClassName</span>()&#123;……&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Apple</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">introduction</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是一个匿名类，但是谁也无法使用它。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>object是 所有java类的祖先，所有类中隐含了extends Object</p>
<p>所以说每个类都有这个方法</p>
<p><code>toString（）</code>方法</p>
<p><code>equals（）</code>方法，<code>hashCode()</code>方法</p>
<p><code>clone（）</code> 方法</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Garbage</span> &#123;</span><br><span class="line">    <span class="type">int</span> index; <span class="comment">//当前对象的索引值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> count; <span class="comment">//当前产生了几个对象</span></span><br><span class="line">    Garbage()&#123;</span><br><span class="line">        count++;</span><br><span class="line">        index=count;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span>+index+<span class="string">&quot;个对象构建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Garbage</span>(); <span class="comment">//垃圾内存</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Garbage</span>(); <span class="comment">//垃圾内存</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span>+index+<span class="string">&quot;个对象被回收&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java中的finalize()方法</p>
<p>用于在对象被垃圾回收机制销毁之前执行一些资源回收工作，由垃</p>
<p>圾回收系统调用，可以重写该方法。</p>
<p>System.gc()的作用</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java只支持单继承，不支持多继承，即一个类只能有一个父类。但是在实际应用中，又经常需要使用<strong>多继承</strong>来解决问题。为了解决该问题，Java提供了接口来实现类的多继承功能。</p>
<p>如果一个抽象类中的所有方法都是抽象的，我们就可以将这个类用另外一种方式来定义，也就是接口定义。（也就是把&#x3D;相当于抽象类更加规范化）</p>
<p>接口是抽象方法和常量值的定义的集合，从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。</p>
<h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] interface 接口名 [extends 父接口名列表]&#123;</span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] 常量;</span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">abstract</span>] 方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和public类一样，public接口也必须定义在与接口同名的文件中。</p>
<p>接口中所有的方法都是public abstract。</p>
<p>接口中可以有数据成员，这些成员默认都是public static final。可以用类名或对象名直接访问！</p>
<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class &lt;类名&gt; [extends 父类][implements 接口列表]</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>可以implements 多个接口，用逗号连接。</p>
<p><strong>在类中必须实现接口中的所有方法。方法的名字、返回值类型、参数的个数及类型必须与接口中的完全一致</strong></p>
<p>一个接口路</p>
<p>接口举例子</p>
<h3 id="接口多继承"><a href="#接口多继承" class="headerlink" title="接口多继承"></a>接口多继承</h3><p>一个接口可以继承多个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Sofa</span> <span class="keyword">extends</span> <span class="title class_">Sittable</span>,Lie<span class="comment">//这是两个接口</span></span><br></pre></td></tr></table></figure>





<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>如果使用大量的if语句的话会非常麻烦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">readFile &#123; </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    打开文件；</span><br><span class="line">    判断大小;</span><br><span class="line">    分配内存;</span><br><span class="line">    读入内存; </span><br><span class="line">    关掉文件; </span><br><span class="line">    &#125; <span class="keyword">catch</span> (文件打开失败) &#123; 处理代码；</span><br><span class="line">    &#125; <span class="keyword">catch</span> (大小取不到失败) &#123; 处理代码;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (内存分配失败) &#123; 处理代码;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (读取失败) &#123; 处理代码;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (文件关闭失败) &#123; 处理代码; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优雅</strong></p>
<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>异常通常分为三种类型：</p>
<blockquote>
<p>第一类是Java虚拟机由于某些内部错误产生的异常，这类异常不在用户程序的控制之内，用户不需要处理这类异常；</p>
</blockquote>
<blockquote>
<p>第二类是标准异常，这类异常通常是由程序代码中的错误产生的，例如被0除、数组下标越界等。这是需要用户程序处理的异常；</p>
</blockquote>
<blockquote>
<p>第三类是用户根据需要在程序中自定义的异常</p>
</blockquote>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240506145218933.png" alt="image-20240506145218933"></p>
<h3 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h3><p>Error类及其子类通常用来描述Java运行系统中的内部错误以及资源耗尽的错误。Error表示的异常是比较严重，仅靠修改程序本身是不能恢复执行的，被称为致命异常类。</p>
<h3 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h3><p>Exception类可称为非致命异常类，它代表了另一种异常。发生该异常的程序，通过捕获处理后可正常运行，保持程序的可读性及可靠性</p>
<h2 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="Java中的异常处理机制"><a href="#Java中的异常处理机制" class="headerlink" title="Java中的异常处理机制"></a>Java中的异常处理机制</h3><blockquote>
<p>声明异常、抛出异常、捕获异常、处理异常</p>
</blockquote>
<h3 id="5个关键字"><a href="#5个关键字" class="headerlink" title="5个关键字"></a>5个关键字</h3><blockquote>
<p>try、catch、finally、throw、throws</p>
</blockquote>
<p>处理过程：</p>
<p>Java程序在执行过程中如出现异常，会自动生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为**抛出(throw)**异常。</p>
<p>当Java运行时系统接收到异常对象时，会寻找能处理这一异常的代码并把当前异常对象交给其处理，这一过程称为**捕获(catch)**异常。</p>
<p>如果Java运行时系统找不到可以捕获异常的方法，则运行时系统将终止，相应的Java程序也将退出。</p>
<p>使用<strong>try-catch-finally</strong>语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">	可能出现异常的程序代码</span><br><span class="line">&#125;<span class="keyword">catch</span> ( IOException 异常对象e )&#123; </span><br><span class="line">	进行IOException异常处理的代码<span class="comment">//这里调用异常类的方法</span></span><br><span class="line">&#125; <span class="keyword">catch</span>( NullPointerException 异常对象e ) &#123;</span><br><span class="line">	进行NullPointerException异常处理的代码</span><br><span class="line">&#125; ... ... </span><br><span class="line"><span class="keyword">catch</span> (Exception 异常对象e )&#123; </span><br><span class="line">		进行Exception异常处理的代码</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	最终清理的程序代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、每个try语句块后至少必须紧跟一个catch语句块或finally语句块。</p>
<p>2、在try语句与catch语句之间、相邻catch语句之间，不允许出现其他程序代码。</p>
<p>3、finally语句也可以没有。如有，无论有无异常，最后必须执行finally语句中的语句体。</p>
<p>4、catch语句仅需要一个参数，必须是Throwable类及其子类的对象。</p>
<p>常见以 <code>Exception</code> 为父类的异常对象包括：</p>
<ol>
<li><code>NullPointerException</code>（空指针异常）：当应用程序试图访问空对象或者对 <code>null</code> 值的对象进行操作时抛出。</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组下标越界异常）：当应用程序试图访问数组的索引超出有效范围时抛出。</li>
<li><code>NumberFormatException</code>（数字格式异常）：当应用程序试图将一个字符串转换为数字，但字符串无法被正确解析为数字时抛出。</li>
<li><code>ClassCastException</code>（类转换异常）：当尝试将一个对象强制转换为与其实际类型不兼容的类型时抛出。</li>
<li><code>ArithmeticException</code>（算术异常）：当在进行算术运算时发生错误，例如除数为零时抛出。</li>
<li><code>IllegalArgumentException</code>（非法参数异常）：当传递给方法的参数不符合预期时抛出。</li>
<li><code>IOException</code>（输入&#x2F;输出异常）：当发生与输入&#x2F;输出相关的错误时抛出，例如文件无法打开、读取或写入。</li>
<li><code>InterruptedException</code>（中断异常）：当线程在等待、休眠或被中断时抛出。</li>
</ol>
<p>如果不知道是什么类型错误，那就在最后使用expection</p>
<h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p>throws对方法可能出现的异常进行声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">devide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x/y; </span><br><span class="line">        <span class="keyword">return</span> result; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123; </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            	<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>().devide(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123; </span><br><span class="line">            	System.out.println(e.getMessage()); </span><br><span class="line">    		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>devide</code>函数要求调用它的函数必须要有异常处理，这就落在了<code>TestException</code>,如果<code>TestException</code>也使用了<code>throws</code>，那就调用<code>TestException</code>的函数来进行异常处理</p>
<h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>throw抛出具体异常对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">check</span><span class="params">(String strage)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(strage);</span><br><span class="line">    <span class="keyword">if</span>(age&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(“年龄不能为负数！”);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">myage</span> <span class="operator">=</span> check(“-<span class="number">101</span>”);</span><br><span class="line">            System.out.println(myage);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">       		System.out.println(“出错原因：” + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛出throw异常之后,使用try-catch语句捕获throw抛出的异常并进行处理</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>由用户自己定义的异常称为自定义异常。自定义异常一般通过继承Exception类来实现。其一般语法格式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 自定义异常类名 <span class="keyword">extends</span> <span class="title class_">Exception</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于自定义异常，Java系统不会自动为用户抛出属于该类的对象，</p>
<p>用户须在程序中使用throw关键字来自行抛出异常对象。throw语</p>
<p>句的通常形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常类对象；</span><br></pre></td></tr></table></figure>

<p>ex:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、定义一个检查邮件字符串的方法checkEmail(String)，对参数中的邮件地址进行检查。</span></span><br><span class="line"><span class="comment">//2、定义一个邮件地址异常类，处理如下几种情况：</span></span><br><span class="line"><span class="comment">//（1）邮件地址中没有”@”符号；  （提示： indexOf函数）</span></span><br><span class="line"><span class="comment">//（2）邮件地址中的“@“符号之前的字符个数至少为6位。</span></span><br><span class="line"><span class="comment">//3、从键盘输入邮件地址，进行测试。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">EmailException</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testException</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkEmail</span><span class="params">(String mail)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(mail.indexOf(<span class="string">&quot;@&quot;</span>)&lt;<span class="number">0</span>) </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmailException</span>(<span class="string">&quot;邮件地址中没有”@”符号&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(mail.indexOf(<span class="string">&quot;@&quot;</span>)&lt;<span class="number">6</span>) </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmailException</span>(<span class="string">&quot;邮件地址中的“@“符号之前的字符个数至少为6位。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			checkEmail(<span class="string">&quot;1245@54&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (EmailException e) &#123;</span><br><span class="line">			System.out.println(e);</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h1><h2 id="AWT"><a href="#AWT" class="headerlink" title="AWT"></a>AWT</h2><h1 id="文件和流"><a href="#文件和流" class="headerlink" title="文件和流"></a>文件和流</h1><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul>
<li><p>流（stream）是一组有序的数据序列。</p>
</li>
<li><p>数据流就是一串连续不断的数据的集合，就像水管里的水流。</p>
</li>
<li><p>文件是数据的静态存储形式，而流是指数据传输时的形态</p>
</li>
</ul>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;123.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(f.exists())</span><br><span class="line">                f.delete();</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f.createNewFile();</span><br><span class="line">                System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在Java中，所有的文件都是字节组成的。因此，使用字节流来读写文件是很常见的。</p>
</li>
<li><p>为了创建一个与文件相链接的字节流 ， 需要使用 FileInputStream 或FileOutputStream。要打开文件，只需要创建这两个类的一个对象，将文件名指定为构造函数的一个参数。一旦文件被打开，就可以对其进行读取和写入操作了。</p>
</li>
</ul>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>字节流是以字节（8位）为单位来处理数据的，由于字节流不会</p>
<p>对数据做任何转换，因此在读写二进制数据时就会使用字节流。</p>
<p> 字节流顶端是两个抽象类：</p>
<p> InputStream：字节输入流，是所有输入流的父类</p>
<p> OutputStream：字节输出流，是所有输出流的父类</p>
<h3 id="inputstream类"><a href="#inputstream类" class="headerlink" title="inputstream类"></a>inputstream类</h3><p><code>read(byte[] bytes) </code></p>
<p>从输入数据流中读取字节并存入数组b中</p>
<p><code>read(byte[] bytes,int off,int len) </code></p>
<p>从输入数据流读取len个字节，并存入数组bytes中</p>
<p><code>close() </code></p>
<p>关闭当前输入流，并释放任何与之关联的系统资源</p>
<p><code>abstract read() </code></p>
<p>从当前数据流中读取一个字节。若已到达流结尾，则返回-1</p>
<h3 id="outputstream类"><a href="#outputstream类" class="headerlink" title="outputstream类"></a>outputstream类</h3><p><code>write(byte[] bytes) </code></p>
<p>将byte[]数组中的数据写入到当前输出流</p>
<p><code>write(byte[] bytes,int off,int len) </code></p>
<p>将byte[]数组下标off开始的len长度的数据写入到当前输出流</p>
<p><code>flush() </code></p>
<p>刷新当前输出流，并强制写入所有缓冲的字节数据</p>
<p><code>close() </code></p>
<p>关闭当前输出流，并释放所有与当前输出流有关的系统资源</p>
<p><code>abstract write(int b) </code></p>
<p>写入一个byte数据到当前输出流</p>
<h3 id="使用字节流读文件"><a href="#使用字节流读文件" class="headerlink" title="使用字节流读文件"></a>使用字节流读文件</h3><p>在Java中，所有的文件都是字节组成的。因此，使用字节流来读写文件是很常见的。</p>
<p>为了创建一个与文件相链接的字节流 ， 需要使用 FileInputStream 或FileOutputStream。要打开文件，只需要创建这两个类的一个对象，文件名指定为构造函数的一个参数。一旦文件被打开，就可以对其进行读取和写入操作了。</p>
<h4 id="从文件输入FileInputStream"><a href="#从文件输入FileInputStream" class="headerlink" title="从文件输入FileInputStream"></a>从文件输入FileInputStream</h4><p>一种写法:<code>FileInputStream（String filePath）</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>另一种写法：<code>FileInputStream(File file)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(“test.txt”);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br></pre></td></tr></table></figure>

<p>ex：读取文件数据显示在控制台</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Test.txt&quot;</span>); </span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">    <span class="type">int</span> rs;</span><br><span class="line">    <span class="keyword">if</span>((rs=fis.read(bytes)) != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           System.out.write(bytes,<span class="number">0</span>,rs);</span><br><span class="line">        &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    	e.printStackTrace(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写入文件FileOutputStream"><a href="#写入文件FileOutputStream" class="headerlink" title="写入文件FileOutputStream"></a>写入文件FileOutputStream</h4><p><code>FileOutputStream(String filePath)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(“test.txt”);</span><br></pre></td></tr></table></figure>

<p><code>FileOutputStream(File file,boolean append) </code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(“test.txt”);</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>ex:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Test2.txt&quot;</span>); </span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">System.out.println(<span class="string">&quot;请输入你想存入文本的内容：&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!f.exists())</span><br><span class="line">    	f.createNewFile();</span><br><span class="line">    <span class="type">int</span> rs=System.in.read(bytes,<span class="number">0</span>,<span class="number">1024</span>); <span class="comment">//从控制台读取一串信息</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f, <span class="literal">true</span>);</span><br><span class="line">    fos.write(bytes,<span class="number">0</span>,rs); <span class="comment">//将读取的信息写入到文件中</span></span><br><span class="line">    fos.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">   		 e.printStackTrace(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>在处理字符文本的时候更加方便</p>
<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><p>字符流有两个父类一个是Reader类，用于字符输入，一个是Writer类，用于字符输出</p>
<p><code>read() </code></p>
<p>读入一个字符。若已读到流结尾，则返回值为−1</p>
<p><code>read(char[]) </code></p>
<p>读取一些字符到char[]数组内，并返回所读入的字符的数量。若已到达流结尾，则返回-1</p>
<p><code>reset()</code> </p>
<p>将当前输入流重新定位到最后一次调用mark() 方法时的位置</p>
<p><code>skip(long n) </code></p>
<p>跳过参数n指定的字符数量，并返回所跳过字符的数量</p>
<p><code>close() </code></p>
<p>关闭该流并释放与之关联的所有资源。在关闭该流后，再调用 read()、ready()、mark()、reset() 或 skip() 将抛出异常</p>
<h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><p><code>write(int c) </code></p>
<p>将字符c写入输出流</p>
<p><code>write(String str) </code></p>
<p>将字符串str写入输出流</p>
<p><code>write(char[] cbuf) </code></p>
<p>将字符数组的数据写入到字符输出流</p>
<p><code>flush() </code></p>
<p>刷新当前输出流，并强制写入所有缓冲的字节数据</p>
<p><code>close() </code></p>
<p>向输出流写入缓冲区的数据，然后关闭当前输出流，并释放所有与当前输出流有关的系统资源</p>
<h3 id="字符流读文件FileReader"><a href="#字符流读文件FileReader" class="headerlink" title="字符流读文件FileReader"></a>字符流读文件FileReader</h3><p>和字节流一样，有</p>
<p>FileReader(String filePath)</p>
<p>FileReader(File file)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Java\\A.txt&quot;</span>);</span><br><span class="line">    FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(f); <span class="comment">// 创建文件字符输入流</span></span><br><span class="line">    <span class="type">char</span>[] data=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">512</span>]; <span class="comment">//读取到的是char</span></span><br><span class="line">    <span class="type">int</span> rs=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((rs=fr.read(data))!= -<span class="number">1</span>)&#123;</span><br><span class="line">   		String str=<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,rs);</span><br><span class="line">    	System.out.println(str);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   		 e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字符流写文件FileWriter"><a href="#字符流写文件FileWriter" class="headerlink" title="字符流写文件FileWriter"></a>字符流写文件FileWriter</h3><p>FileWriter(String filePath)</p>
<p>FileWriter(File file)</p>
<p>A文件复制到B文件中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Java\A.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!f.exists()) <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    	f.createNewFile();</span><br><span class="line">    FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;C:\\Java\\B.txt&quot;</span>);<span class="comment">// 创建文件字符输入流</span></span><br><span class="line">    FileWriter fWriter=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(f); <span class="comment">// 创建文件字符输出流</span></span><br><span class="line">    <span class="type">int</span> is;</span><br><span class="line">    <span class="keyword">while</span>((is=fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    	fWriter.write(is); <span class="comment">// 将数据写入输出流</span></span><br><span class="line">    &#125;</span><br><span class="line">    fr.close();</span><br><span class="line">    fWriter.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字节流和字符流之间的转换"><a href="#字节流和字符流之间的转换" class="headerlink" title="字节流和字符流之间的转换"></a>字节流和字符流之间的转换</h2><p>字节流与字符流之间的桥梁</p>
<p><code>InputStreamReader</code>可以使用特定字符集将字节转换成Unicode字符</p>
<p><code>OutputStreamWriter</code>从程序中接收Unicode字符，将这些字符使用特定字符集转换为字节并将这些字节写入到一个输出流中。</p>
<h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240618142734474.png" alt="image-20240618142734474"></p>
<h3 id="OutStreamWriter"><a href="#OutStreamWriter" class="headerlink" title="OutStreamWriter"></a>OutStreamWriter</h3><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240618142829216.png" alt="image-20240618142829216"></p>
<h2 id="I-O流"><a href="#I-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h2><ul>
<li><p>Java的I&#x2F;O库提供了一个称做链接的机制，可以将一个流与另一个流首尾相接，形成一个流管道的链接。这种机制实际上是一种被称为Decorator(装饰)设计模式的应用。</p>
</li>
<li><p> 通过流的链接，可以动态地增加流的功能，而这种功能的增加是通过组合一些流的基本功能而动态获取的。</p>
</li>
<li><p> <strong>过滤流（FilterStream）</strong>是对字节或字符数据流提供扩展功能的包装。例如基本输入流提供的读取方法，只能用来读取字节或字符；而过滤流能够读取整数值、双精度值或字符串，但需要一个过滤流类来包装输入流。</p>
</li>
</ul>
<img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240618143205080.png" alt="image-20240618143205080" style="zoom: 33%;" />



<img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240618143240291.png" alt="image-20240618143240291" style="zoom: 33%;" />

<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240618143352421.png" alt="image-20240618143352421"></p>
<p>写入文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.txt&quot;</span>);<span class="comment">//文件输出流</span></span><br><span class="line">            <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);<span class="comment">//缓冲流,提高效率</span></span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(bos);<span class="comment">//数据流,写入基本数据类型</span></span><br><span class="line">            dos.writeDouble(<span class="number">9.8</span>);</span><br><span class="line">            dos.writeInt(<span class="number">100</span>);</span><br><span class="line">            dos.writeUTF(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            dos.close();</span><br><span class="line">            bos.close();</span><br><span class="line">            fos.close();</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">            System.out.println(dis.readDouble());<span class="comment">//写入数据的时候可以把read改成writer</span></span><br><span class="line">            System.out.println(dis.readInt());</span><br><span class="line">            System.out.println(dis.readUTF());</span><br><span class="line">            dis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">copyfile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc= <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;Enter the file name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">        FileInputStream fis=<span class="literal">null</span>;</span><br><span class="line">        InputStreamReader isr=<span class="literal">null</span>;</span><br><span class="line">        BufferedReader reader=<span class="literal">null</span>;</span><br><span class="line">        BufferedWriter writer=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            isr = <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis);</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//把file内容通过BufferedWriter写入file_copy</span></span><br><span class="line">                writer = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(file + <span class="string">&quot;_copy&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">                writer.write(line);</span><br><span class="line">                writer.newLine();</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;File not found&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(reader!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(isr!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    isr.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(fis!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240618143954044.png" alt="image-20240618143954044"></p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240618144010538.png" alt="image-20240618144010538"></p>
<h2 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h2><p>懒得写</p>
<h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h1><p>用来储存对象，长度可变</p>
<h2 id="集合中主要接口"><a href="#集合中主要接口" class="headerlink" title="集合中主要接口"></a><strong>集合中主要接口</strong></h2><h4 id="-Collection与Map的区别"><a href="#-Collection与Map的区别" class="headerlink" title=" Collection与Map的区别"></a> Collection与Map的区别</h4><p>Collection类型：集合中每个元素是一个独立的对象。</p>
<p>Map类型：集合中每个元素都是一对Key&#x2F;Value（键&#x2F;值）对象；同一集合中，每个元素的键都不能与其他元素的键相同。</p>
<h4 id="-List与Set的区别"><a href="#-List与Set的区别" class="headerlink" title=" List与Set的区别"></a> List与Set的区别</h4><p>List： 按照对象的插入顺序排列。 元素可重复，实质是可变长度的数组。</p>
<p>Set：数学意义上的集合，在Set中的对象元素不能重复。</p>
<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a><strong>List</strong>集合</h2><ul>
<li><p>List集合为<strong>列表</strong>类型，以<strong>线性方式</strong>存储对象，可以通过对象的<strong>索引</strong>操作对象。</p>
</li>
<li><p>List是<strong>有序</strong>的collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。</p>
</li>
<li><p>List接口的常用实现类有ArrayList和LinkedList。</p>
<ul>
<li><strong>ArrayList</strong>: 是一种类似数组的形式进行存储，因此它的随机访问速度极快。在插入之后后面的对象索引向后移位，删除向前</li>
<li><strong>LinkedList</strong>:内部实现是链表，它适合于在链表中间需要频繁进行插入和删除操作</li>
</ul>
</li>
</ul>
<h3 id="从arrayList集合中取数据"><a href="#从arrayList集合中取数据" class="headerlink" title="从arrayList集合中取数据"></a>从arrayList集合中取数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">String</span>(“a”));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">String</span>(“b”));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size(); i++)</span><br><span class="line">System.out.println(list.get(i));</span><br></pre></td></tr></table></figure>

<h3 id="list实例化"><a href="#list实例化" class="headerlink" title="list实例化"></a>list实例化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">// 利用ArrayList类实例化List集合</span></span><br><span class="line">List&lt;String&gt; l2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;(); <span class="comment">// 利用LinkedList类实例化List集合</span></span><br></pre></td></tr></table></figure>

<h3 id="list常用方法"><a href="#list常用方法" class="headerlink" title="list常用方法"></a>list常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(<span class="type">int</span> index, Object obj) <span class="comment">//指定索引位置添加对象</span></span><br><span class="line">set(<span class="type">int</span> index, Object obj)<span class="comment">// 替换指定索引位置的对象</span></span><br><span class="line">indexOf(Object obj) <span class="comment">//获得指定对象的最小的索引位置</span></span><br><span class="line">lastIndexOf(Object obj) <span class="comment">//获得指定对象的最大的索引位置</span></span><br></pre></td></tr></table></figure>

<h3 id="linkedlist常用方法"><a href="#linkedlist常用方法" class="headerlink" title="linkedlist常用方法"></a>linkedlist常用方法</h3><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240604170549220.png" alt="image-20240604170549220"></p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240604171133204.png" alt="image-20240604171133204"></p>
<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a><strong>Set</strong>集合</h2><ul>
<li><p>存放于Set集中的对象不按特定方式排序，只是简单地把对象加入集合中，类似于向口袋里放东西。</p>
</li>
<li><p>在Set集中不能存放重复对象。</p>
</li>
</ul>
<h3 id="HashSet类（散列集）"><a href="#HashSet类（散列集）" class="headerlink" title="HashSet类（散列集）"></a>HashSet类（散列集）</h3><ul>
<li><p>HashSet 实现了Set接口，它的元素不能有重复值出现。在HashSet中没有get()方法，但可以通过iterator()来遍历数据。</p>
</li>
<li><p>散列集为每个放入的对象计算一个整数hashCode(散列码),散列码的计算非常迅速，默认情况下根据对象的内存地址来派生散列码。由HashSet类实现的Set集合按照散列码排序，根据对象的散列码确定对象的存储位置。</p>
</li>
</ul>
<p>如果要在HashSet集合类中存放一些自定义的对象，需要在对象所属的类中重写hashCode()与equals()方法，从而保证插入集合中的对象是惟一的，而且能够合理地分布在集合中，以便于快速定位集合中的对象。</p>
<p>定义的值有什么用吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//自定义一个散列码（必须是整数）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//判断两个对象的成员是否相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a><strong>Map</strong>集合</h2><ul>
<li>Map集合为映射类型，映射中的每个对象都是成对存在的。</li>
<li>映射中存储的每个对象都有一个相应的<strong>键（key）</strong>对象，在检索对象时必须通过相应的键对象来获取<strong>值（value）对象</strong>，类似于在字典中查找单词一样，所以要求<strong>键对象必须是唯一的</strong>。</li>
<li>键对象还决定了存储对象在映射中的存储位置，但并不是键对象本身决定的，需要通过<strong>散列码</strong>进行处理，由此来确定存储对象在映射中的存储位置</li>
<li>Map集合允许以null作为键对象，但是因为键对象不可以重复，所以这样的键对象只能有一个。允许值对象为null，并且没有个数限制。</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240604171508397.png" alt="image-20240604171508397"></p>
<h3 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h3><p>HashMap通过哈希码对其内部的映射关系进行快速查找、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从控制台输入一句英语，统计各单词出现的次数，使用HashMap完成。</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testMap</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		 Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		 <span class="comment">//使用 nextLine()可以读一行</span></span><br><span class="line">		 String read=sc.nextLine();</span><br><span class="line">		 <span class="comment">//把一句单词用“ ”分割为一个字符串数组 </span></span><br><span class="line">		 String str[]=read.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		 <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)</span><br><span class="line">			 System.out.println(str[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		 <span class="comment">//&lt;单词，出现的次数&gt; 键为单词，值为该单词出现次数 </span></span><br><span class="line">         HashMap&lt;String,Integer&gt; hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">        	 <span class="comment">//如果该单词不存在 ，则新增 </span></span><br><span class="line">        	<span class="keyword">if</span>(!hm.containsKey(str[i]))&#123;</span><br><span class="line">        		hm.put(str[i], <span class="number">1</span>);<span class="comment">//自动装箱</span></span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123; <span class="comment">//如果单词存在则使其次数  +1</span></span><br><span class="line">        		<span class="type">int</span> n=hm.get(str[i]);</span><br><span class="line">        		hm.put(str[i], ++n);</span><br><span class="line">        	&#125;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(<span class="string">&quot;统计单词出现的个数，结果如下：&quot;</span>);</span><br><span class="line"> 		<span class="comment">//hello java hdu hel java haha java </span></span><br><span class="line">       <span class="comment">//hello  1</span></span><br><span class="line">       <span class="comment">//java  3</span></span><br><span class="line">       <span class="comment">//hdu  1</span></span><br><span class="line">       <span class="comment">//hel   1</span></span><br><span class="line">       <span class="comment">//haha  1</span></span><br><span class="line">         <span class="comment">//将集合中的所有键对象保存到Set集合中</span></span><br><span class="line">         Set&lt;String&gt; s=hm.keySet();</span><br><span class="line">         <span class="comment">//遍历Set集合的键值</span></span><br><span class="line">         Iterator&lt;String&gt; it=s.iterator();</span><br><span class="line">         <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        	 String a=it.next();</span><br><span class="line">        	 <span class="comment">//使用get函数，根据HashMap的键求值</span></span><br><span class="line">        	 System.out.println(a+<span class="string">&quot;=&quot;</span>+hm.get(a));</span><br><span class="line">         &#125;  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Treemap"><a href="#Treemap" class="headerlink" title="Treemap"></a>Treemap</h3><p>TreeMap中的映射关系存在一定的顺序</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>程序一次执行就是一个进程，一个进程可以有很多线程（程序中可以独立运行的片段）共享内存资源。</p>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p> java.lang.Thread类</p>
<ul>
<li>创建一个Tread类的实例对象，形成一个新的线程</li>
</ul>
<h3 id="方法（static）"><a href="#方法（static）" class="headerlink" title="方法（static）"></a>方法（static）</h3><ul>
<li><p><code>currentThread()</code> 返回正在运行的Thread对象。</p>
</li>
<li><p><code>yield()</code> 停止运行当前线程，将CPU控制权主动移交到下一个可运行线程。</p>
</li>
<li><p><code>sleep(int n)</code> 让当前线程睡眠n毫秒,n毫秒后,线程可以再次运行</p>
</li>
</ul>
<h3 id="Thread类的实例方法（非static方法"><a href="#Thread类的实例方法（非static方法" class="headerlink" title="Thread类的实例方法（非static方法)"></a>Thread类的实例方法（非static方法)</h3><ul>
<li><p><code>start()</code>为本线程建立一个执行环境，然后调用本线程的run()方法。</p>
</li>
<li><p><code>run()</code> 在该方法中编写运行本线程将要执行的代码，也是Runnable接口的唯一方法。当一个线程初始化后，由start() 方法来调用它，一旦run()方法返回，本线程也就终止了。</p>
</li>
<li><p><code>setPriority(int p)</code> 给线程设置优先级1&lt;&#x3D;p&lt;&#x3D;10 </p>
</li>
<li><p><code>getPriority()</code> 返回线程的优先级</p>
</li>
<li><p><code>setName(String name)</code> 赋予线程一个名字name </p>
</li>
<li><p><code>getName()</code> 取得由setName()方法设置的线程名字的字符串</p>
</li>
<li><p><code>wait(long timeout)</code> 停止当前线程，直到另外的线程对这个对象使用</p>
</li>
<li><p><code>notify()</code>或<code>notifyAll()</code> 唤醒指定对象的一个或所有线程</p>
</li>
</ul>
<h2 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">testThread</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">	t.setName(<span class="string">&quot;单线程&quot;</span>); <span class="comment">//对线程取名为“单线程 &quot;</span></span><br><span class="line">	t.setPriority(<span class="number">8</span>); <span class="comment">//设置线程优先级为8，最高为10，最低为1，默认为5</span></span><br><span class="line">	System.out.println(<span class="string">&quot;The running thread: &quot;</span> + t);</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Sleep time &quot;</span> + i);</span><br><span class="line">			Thread.sleep(<span class="number">100</span>); &#125; <span class="comment">// 睡眠100毫秒</span></span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;<span class="comment">// 捕获异常</span></span><br><span class="line">			System.out.println(<span class="string">&quot;thread has wrong&quot;</span>); &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The running thread: Thread[单线程,8,main]</span><br><span class="line">Sleep time 0</span><br><span class="line">Sleep time 1</span><br><span class="line">Sleep time 2</span><br></pre></td></tr></table></figure>

<h2 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>可通过继承Thread类并重写其中的run()方法来定义线程体以实现线程的具体行为，然后创建该子类的对象以创建线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSubclassName</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadSubclassName</span><span class="params">()</span>&#123; ..... 此处编写子类的构造方法，可缺省 &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123; ..... 此处编写自己的线程代码 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadSubclassName</span> <span class="variable">ThreadObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSubclassName</span>();</span><br><span class="line">ThreadObject.start(); <span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>编写多线程程序的另一种的方法是实现Runnable接口。在一个类中实现Runnable接口，并在该类中定义run()方法，然后用带有Runnable参数的Thread类构造方法创建线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123; ..... <span class="comment">// 编写自己的线程代码 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mythread mt=<span class="keyword">new</span> <span class="title class_">Mythread</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Thread</span>(mt); <span class="comment">// 新建线程对象，指向Runnable类的实例，// 使用Runnable类实例为线程提供run()方法</span></span><br><span class="line">t.start(); <span class="comment">// 启动线程</span></span><br></pre></td></tr></table></figure>

<p>不同之处在于实现接口之后，还要创建thread对象</p>
<p>线程执行的时候，输出可能回不一致，下面这个例子结果可能是全是yes也有可能全是no</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123; </span><br><span class="line">    <span class="type">String</span> <span class="variable">myString</span> <span class="operator">=</span> <span class="string">&quot;Yes &quot;</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="built_in">this</span>.myString = <span class="string">&quot;No &quot;</span>; &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123; </span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(); </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(t).start(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">            System.out.print(t.myString); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li>同步代码块作用：多个线程间共享资源操作容易引起冲突，这些容易引起冲突的代码块称之为<strong>临界区</strong>，在临界区通过引入监视器，并用<strong>synchronized</strong>使多个线程在临界区同步起来，从而避免可能引起的冲突。</li>
<li>synchronized可修饰一个代码块或一个方法，使修饰对象在任一时刻只能有一个线程访问。从而提供了程序的异步执行功能。</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>（<span class="built_in">this</span>）&#123;......&#125; <span class="comment">// 修饰一个代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> methodName（parameters）&#123; <span class="comment">// 修饰一个方法</span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>发博客步骤</title>
    <url>/2023/12/27/%E5%8F%91%E5%8D%9A%E5%AE%A2%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h1 id="如何开始写博客发布文章"><a href="#如何开始写博客发布文章" class="headerlink" title="如何开始写博客发布文章"></a>如何开始写博客发布文章</h1><h2 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a>第一种方式：</h2><p>   进入博客所在目录，右键打开 Git Bash Here，创建博文：<br>    <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure></p>
<p>然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。</p>
<p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。以后每次发布文章都是这两条命令。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo d   # 部署发布</span><br></pre></td></tr></table></figure>

<h2 id="第二种方式："><a href="#第二种方式：" class="headerlink" title="第二种方式："></a>第二种方式：</h2><p>​    也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 hexo g 和 hexo d 发布。</p>
<pre><code> <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line"><span class="bullet">-</span> Diary</span><br><span class="line">tags: # 标签</span><br><span class="line"><span class="bullet">-</span> PS3</span><br><span class="line"><span class="bullet">-</span> Games</span><br><span class="line">摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="第三种："><a href="#第三种：" class="headerlink" title="第三种："></a>第三种：</h2><p>有了typora之后，直接在typora里面新建就行了</p>
<h2 id="Typora一些快捷方式："><a href="#Typora一些快捷方式：" class="headerlink" title="Typora一些快捷方式："></a>Typora一些快捷方式：</h2><p><strong>引用</strong>: &gt;+   ，按住shift+tap退出引用</p>
<blockquote>
<p>this is a quote</p>
</blockquote>
<p><strong>无序列表</strong>：ctrl+shift+]</p>
<ul>
<li>这是一个列表<ul>
<li>tap子列表</li>
</ul>
<p>	</p>
</li>
<li>shift+tap回退</li>
</ul>
<p><strong>有序列表</strong>：ctrl+shift+[</p>
<ol>
<li>这是一个有序列表<ol>
<li>这是一个子列表</li>
</ol>
</li>
<li>回退（都与无序列表相同）</li>
</ol>
<p><strong>加链接</strong>：<a href="www.baidu.com">百度</a></p>
<p><strong>高亮</strong>：&#x3D;&#x3D;key&#x3D;&#x3D;(重启时生效)</p>
<p><strong>加粗</strong>：ctrl+B</p>
<p><strong>划重点</strong>：<code>emphasize</code>两个飘号</p>
<p><strong>表格</strong>：ctrl+T插入表格</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>代码块：</strong>输入三个&#96;加回车，然后输入代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><del><strong>删除线</strong></del>：格式</p>
<h2 id="typora使用技巧："><a href="#typora使用技巧：" class="headerlink" title="typora使用技巧："></a>typora使用技巧：</h2><p><strong>修改参数</strong>：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20231229160522068.png" alt="image-20231229160522068"></p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>blogging</tag>
      </tags>
  </entry>
  <entry>
    <title>利用huggingface处理nlp任务</title>
    <url>/2024/07/06/%E8%AF%86%E5%88%AB%E4%B8%8D%E8%89%AF%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p> 前段时间在搞AI的竞赛，因为想速成，所以直接去看BERT要如何使用，虽然自己了解了一点nlp的知识，但是其实要自己创建一个模型真的需要很多的前置知识比如词向量wordvec之类的，还好在网上冲浪的时候发现huggingface这个东西，这个东西配置简单，有大量现成的AI模型可以去使用，甚至可以开箱即用，只需了解一点AI的知识就行了。</p>
<h1 id="huggingface入门"><a href="#huggingface入门" class="headerlink" title="huggingface入门"></a>huggingface入门</h1><p>安装huggingface最主要的包</p>
<p><a href="https://huggingface.co/docs/transformers/main/en/index">🤗 Transformers (huggingface.co)</a></p>
<p>这个里面包含了各种完整的教程，比如我想微调模型，我就看这个<a href="https://huggingface.co/docs/transformers/main/en/training">Fine-tune a pretrained model (huggingface.co)</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install transformers</span><br></pre></td></tr></table></figure>

<p>然后可以试用pipline的功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> pipeline</span><br><span class="line">classifer=pipeline(<span class="string">&quot;sentiment-analysis&quot;</span>)<span class="comment">#会直接从huggingface上下载模型到C盘的用户//cache中</span></span><br><span class="line">result=classifer(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">&quot;I hate you&quot;</span>,</span><br><span class="line">        <span class="string">&quot;I love you&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;&#x27;label&#x27;: &#x27;NEGATIVE&#x27;, &#x27;score&#x27;: 0.9991129040718079&#125;, &#123;&#x27;label&#x27;: &#x27;POSITIVE&#x27;, &#x27;score&#x27;: 0.9998656511306763&#125;]</span><br></pre></td></tr></table></figure>

<p>证明你已经成功使用了</p>
<h1 id="原理解析-通过情感解析"><a href="#原理解析-通过情感解析" class="headerlink" title="原理解析(通过情感解析)"></a>原理解析(通过情感解析)</h1><p>Tokenizer:分词器</p>
<p>Model:这里使用BERT之类的</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240709163613725.png" alt="image-20240709163613725"></p>
<p>首先要分词，要把每个词转化为唯一的ID，比如<code>This</code>转化为<code>101</code>，把一句话转化为<code>IDlist</code>,把<code>list</code>输入到<code>Model</code>中，会返回一个预测结果<code>Logit</code>,再经过<code>Post proccessing</code>就可以出现最终结果了 </p>
<h2 id="Tokenizer"><a href="#Tokenizer" class="headerlink" title="Tokenizer"></a>Tokenizer</h2><ul>
<li>分词，分字，分特殊字符</li>
<li>对于每个token映射得到一个ID</li>
<li>还可以得到 一些辅助信息，比如当前的词属于哪个句子</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line">modelname=<span class="string">&quot;distilbert/distilbert-base-uncased-finetuned-sst-2-english&quot;</span><span class="comment">#你要使用的模型名字，可以在huggingface中直接找到</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(modelname)</span><br><span class="line"></span><br><span class="line">raw_text = [</span><br><span class="line">    <span class="string">&quot;I love you very much&quot;</span>,</span><br><span class="line">    <span class="string">&quot;I hate you&quot;</span>,</span><br><span class="line">]</span><br><span class="line">inputs = tokenizer(raw_text, padding=<span class="literal">True</span>, truncation=<span class="literal">True</span>, return_tensors=<span class="string">&quot;pt&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>autotokenizer</code>来根据模型来自动选择分词器</p>
<p><code>padding</code>用来把短句子补齐成为长句子加0，<code>truncation</code>可以用来截断过长的文本 ，这个代码没用到。<code>return_tensors=&quot;pt&quot;</code>说明这个模型底层是用pytorch做的<br>结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;input_ids&#x27;: tensor([[ 101, 1045, 2293, 2017, 2200, 2172,  102],</span><br><span class="line">        [ 101, 1045, 5223, 2017,  102,    0,    0]]), &#x27;attention_mask&#x27;: tensor([[1, 1, 1, 1, 1, 1, 1],</span><br><span class="line">        [1, 1, 1, 1, 1, 0, 0]])&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么多了两个id</strong>，是因为在前面加了<code>[CLS]</code>,最后加了<code>[SEP]</code>作为特殊字符</p>
<p><code>attention_mask</code>中有用的字符为1，如果是被补齐的就是0</p>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>相应的，我们也可以直接调用其模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModel, AutoTokenizer</span><br><span class="line">modelname=<span class="string">&quot;distilbert/distilbert-base-uncased-finetuned-sst-2-english&quot;</span><span class="comment">#你要使用的模型名字</span></span><br><span class="line">model=AutoModel.from_pretrained(modelname)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DistilBertModel(</span><br><span class="line">  (embeddings): Embeddings(</span><br><span class="line">    (word_embeddings): Embedding(30522, 768, padding_idx=0)</span><br><span class="line">    (position_embeddings): Embedding(512, 768)</span><br><span class="line">    (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True)</span><br><span class="line">    (dropout): Dropout(p=0.1, inplace=False)</span><br><span class="line">  )</span><br><span class="line">  (transformer): Transformer(</span><br><span class="line">    (layer): ModuleList(</span><br><span class="line">      (0-5): 6 x TransformerBlock(</span><br><span class="line">        (attention): MultiHeadSelfAttention(</span><br><span class="line">          (dropout): Dropout(p=0.1, inplace=False)</span><br><span class="line">          (q_lin): Linear(in_features=768, out_features=768, bias=True)</span><br><span class="line">          (k_lin): Linear(in_features=768, out_features=768, bias=True)</span><br><span class="line">          (v_lin): Linear(in_features=768, out_features=768, bias=True)</span><br><span class="line">          (out_lin): Linear(in_features=768, out_features=768, bias=True)</span><br><span class="line">        )</span><br><span class="line">        (sa_layer_norm): LayerNorm((768,), eps=1e-12, elementwise_affine=True)</span><br><span class="line">        (ffn): FFN(</span><br><span class="line">          (dropout): Dropout(p=0.1, inplace=False)</span><br><span class="line">          (lin1): Linear(in_features=768, out_features=3072, bias=True)</span><br><span class="line">          (lin2): Linear(in_features=3072, out_features=768, bias=True)</span><br><span class="line">          (activation): GELUActivation()</span><br><span class="line">        )</span><br><span class="line">        (output_layer_norm): LayerNorm((768,), eps=1e-12, elementwise_affine=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们把上面的<code>inputs</code>传到<code>model</code>中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">outputs = model(**inputs)</span><br><span class="line"><span class="built_in">print</span>(outputs.last_hidden_state.shape)</span><br></pre></td></tr></table></figure>

<p>打印最后隐藏结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.Size([2, 7, 768])</span><br></pre></td></tr></table></figure>

<p>2代表两个<code>batch</code>,每个<code>batch</code>有7个<code>token</code>，都编码成一个768的向量</p>
<p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240709210427414.png" alt="image-20240709210427414"></p>
<p>如果我们加上输出头（用于分类的输出头）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForSequenceClassification, AutoTokenizer</span><br><span class="line">modelname=<span class="string">&quot;distilbert/distilbert-base-uncased-finetuned-sst-2-english&quot;</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(modelname)</span><br><span class="line"></span><br><span class="line">raw_text = [</span><br><span class="line">    <span class="string">&quot;I love you very much&quot;</span>,</span><br><span class="line">    <span class="string">&quot;I hate you&quot;</span>,</span><br><span class="line">]</span><br><span class="line">inputs = tokenizer(raw_text, padding=<span class="literal">True</span>, truncation=<span class="literal">True</span>, return_tensors=<span class="string">&quot;pt&quot;</span>) </span><br><span class="line">model=AutoModelForSequenceClassification.from_pretrained(modelname)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line">outputs = model(**inputs)</span><br></pre></td></tr></table></figure>



<p>结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DistilBertForSequenceClassification(</span><br><span class="line">  (distilbert): DistilBertModel(</span><br><span class="line">    (embeddings): Embeddings(</span><br><span class="line">      (word_embeddings): Embedding(<span class="number">30522</span>, <span class="number">768</span>, padding_idx=<span class="number">0</span>)</span><br><span class="line">      (position_embeddings): Embedding(<span class="number">512</span>, <span class="number">768</span>)</span><br><span class="line">      (LayerNorm): LayerNorm((<span class="number">768</span>,), eps=<span class="number">1e-12</span>, elementwise_affine=<span class="literal">True</span>)</span><br><span class="line">      (dropout): Dropout(p=<span class="number">0.1</span>, inplace=<span class="literal">False</span>)</span><br><span class="line">    )</span><br><span class="line">    (transformer): Transformer(</span><br><span class="line">      (layer): ModuleList(</span><br><span class="line">        (<span class="number">0</span>-<span class="number">5</span>): <span class="number">6</span> x TransformerBlock(</span><br><span class="line">          (attention): MultiHeadSelfAttention(</span><br><span class="line">            (dropout): Dropout(p=<span class="number">0.1</span>, inplace=<span class="literal">False</span>)</span><br><span class="line">            (q_lin): Linear(in_features=<span class="number">768</span>, out_features=<span class="number">768</span>, bias=<span class="literal">True</span>)</span><br><span class="line">            (k_lin): Linear(in_features=<span class="number">768</span>, out_features=<span class="number">768</span>, bias=<span class="literal">True</span>)</span><br><span class="line">            (v_lin): Linear(in_features=<span class="number">768</span>, out_features=<span class="number">768</span>, bias=<span class="literal">True</span>)</span><br><span class="line">            (out_lin): Linear(in_features=<span class="number">768</span>, out_features=<span class="number">768</span>, bias=<span class="literal">True</span>)</span><br><span class="line">          )</span><br><span class="line">          (sa_layer_norm): LayerNorm((<span class="number">768</span>,), eps=<span class="number">1e-12</span>, elementwise_affine=<span class="literal">True</span>)</span><br><span class="line">          (ffn): FFN(</span><br><span class="line">            (dropout): Dropout(p=<span class="number">0.1</span>, inplace=<span class="literal">False</span>)</span><br><span class="line">            (lin1): Linear(in_features=<span class="number">768</span>, out_features=<span class="number">3072</span>, bias=<span class="literal">True</span>)</span><br><span class="line">            (lin2): Linear(in_features=<span class="number">3072</span>, out_features=<span class="number">768</span>, bias=<span class="literal">True</span>)</span><br><span class="line">            (activation): GELUActivation()</span><br><span class="line">          )</span><br><span class="line">          (output_layer_norm): LayerNorm((<span class="number">768</span>,), eps=<span class="number">1e-12</span>, elementwise_affine=<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (pre_classifier): Linear(in_features=<span class="number">768</span>, out_features=<span class="number">768</span>, bias=<span class="literal">True</span>)</span><br><span class="line">  (classifier): Linear(in_features=<span class="number">768</span>, out_features=<span class="number">2</span>, bias=<span class="literal">True</span>)</span><br><span class="line">  (dropout): Dropout(p=<span class="number">0.2</span>, inplace=<span class="literal">False</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>相比起上面的多了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(pre_classifier): Linear(in_features=768, out_features=768, bias=True)</span><br><span class="line">  (classifier): Linear(in_features=768, out_features=2, bias=True)</span><br><span class="line">  (dropout): Dropout(p=0.2, inplace=False)</span><br></pre></td></tr></table></figure>

<p>这些组件共同构成了用于序列分类的输出头，它们直接处理从<code> DistilBERT</code>（或其他类似模型）提取的特征，并输出用于分类的 logits。这样的设计使得模型能够适应特定的分类任务，同时通过简单的微调过程就可以达到很好的效果。</p>
<p>最后我们使用<code>torch</code>的<code>softmax</code>来输出概率，这些概率表示模型预测每个类别的相对置信度。我们打印一下<code>id2label</code>就可以知道对应的概率的指向的情感</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predications = torch.nn.functional.softmax(outputs.logits, dim=-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(outputs.logits.shape)</span><br><span class="line"><span class="built_in">print</span>(predications)</span><br><span class="line"><span class="built_in">print</span>(model.config.id2label)</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.Size([2, 2])</span><br><span class="line">tensor([[1.2578e-04, 9.9987e-01],</span><br><span class="line">        [9.9911e-01, 8.8707e-04]], grad_fn=&lt;SoftmaxBackward0&gt;)</span><br><span class="line">&#123;0: &#x27;NEGATIVE&#x27;, 1: &#x27;POSITIVE&#x27;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>outputs.logits</code> 的形状是 <code>[2, 2]</code>。这表示你有两个输入样本（”I love you very much” 和 “I hate you”），每个样本都有两个输出 logits，这些 logits 分别对应两个情感类别（NEGATIVE 和 POSITIVE）。</p>
</li>
<li><p>对于第一个样本 “I love you very much”：</p>
<ul>
<li>概率 <code>[1.2578e-04, 9.9987e-01]</code> 表示模型几乎确定这是一个正面的表达（概率为 99.987%），而负面的可能性几乎可以忽略不计（概率为 0.01258%）。</li>
</ul>
</li>
<li><p>对于第二个样本 “I hate you”：</p>
<ul>
<li>概率 <code>[9.9911e-01, 8.8707e-04]</code> 表示模型几乎确定这是一个负面的表达（概率为 99.911%），而正面的可能性非常低（概率为 0.088707%）。</li>
</ul>
</li>
<li><p><code>model.config.id2label</code> 显示了类别索引与情感标签之间的映射关系，其中 <code>0: &#39;NEGATIVE&#39;</code> 和 <code>1: &#39;POSITIVE&#39;</code>。这有助于解释模型的输出，明白每个概率值对应哪种情感。</p>
</li>
</ul>
<h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h2 id="从datasets获取数据"><a href="#从datasets获取数据" class="headerlink" title="从datasets获取数据"></a>从datasets获取数据</h2><p><img src="http://typora-images-bed.oss-cn-beijing.aliyuncs.com/img/image-20240710115350708.png" alt="image-20240710115350708"></p>
<p>huggingface上有现成的datasets可以使用，并且数据格式都是统一的真正做到开箱即用</p>
<p>测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset</span><br><span class="line">raw_datasets=load_dataset(<span class="string">&quot;glue&quot;</span>,<span class="string">&quot;mrpc&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(raw_datasets)</span><br></pre></td></tr></table></figure>

<p>这里使用了 <code>datasets</code> 库的 <code>load_dataset</code> 函数来加载一个具体的数据集。<code>&quot;glue&quot;</code> 是一个广泛使用的自然语言理解基准测试套件，而 <code>&quot;mrpc&quot;</code> 是 GLUE 套件中的一个任务，全名为 Microsoft Research Paraphrase Corpus，这个任务的目标是判断两个句子是否是相互改写（即语义等价）。</p>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DatasetDict(&#123;</span><br><span class="line">    train: Dataset(&#123;</span><br><span class="line">        features: [<span class="string">&#x27;sentence1&#x27;</span>, <span class="string">&#x27;sentence2&#x27;</span>, <span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;idx&#x27;</span>],</span><br><span class="line">        num_rows: <span class="number">3668</span></span><br><span class="line">    &#125;)</span><br><span class="line">    validation: Dataset(&#123;</span><br><span class="line">        features: [<span class="string">&#x27;sentence1&#x27;</span>, <span class="string">&#x27;sentence2&#x27;</span>, <span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;idx&#x27;</span>],</span><br><span class="line">        num_rows: <span class="number">408</span></span><br><span class="line">    &#125;)</span><br><span class="line">    test: Dataset(&#123;</span><br><span class="line">        features: [<span class="string">&#x27;sentence1&#x27;</span>, <span class="string">&#x27;sentence2&#x27;</span>, <span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;idx&#x27;</span>],</span><br><span class="line">        num_rows: <span class="number">1725</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>train</code>、<code>validation</code>、<code>test</code> 分别代表训练集、验证集和测试集。</p>
</li>
<li><p><code>features</code> 表示数据集中包含的字段，通常对于 MRPC 来说包括 <code>sentence1</code>、<code>sentence2</code> 和一个 <code>label</code>，<code>label</code> 为 <code>1</code> 表示两个句子是相互改写的，为 <code>0</code> 则表示不是。</p>
</li>
<li><p><code>num_rows</code> 显示了每个数据集划分中的行数（即样本数量）。</p>
</li>
</ul>
<p>我们使用其中的训练集看看</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raw_train_dataset=raw_datasets[<span class="string">&quot;train&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(raw_train_dataset[<span class="number">100</span>])</span><br><span class="line"><span class="built_in">print</span>(raw_train_dataset.features)</span><br></pre></td></tr></table></figure>

<p>我们打印了其中索引为100的数据</p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;sentence1&#x27;: &#x27;The Nasdaq composite index inched up 1.28 , or 0.1 percent , to 		         1,766.60 , following a weekly win of 3.7 percent .&#x27;, </span><br><span class="line">&#x27;sentence2&#x27;: &#x27;The technology-laced Nasdaq Composite Index .IXIC was off 24.44 points ,       or 1.39 percent , at 1,739.87 .&#x27;, </span><br><span class="line">&#x27;label&#x27;: 0, #0表示不相关</span><br><span class="line">&#x27;idx&#x27;: 114</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#x27;sentence1&#x27;: Value(dtype=&#x27;string&#x27;, id=None), </span><br><span class="line"> &#x27;sentence2&#x27;: Value(dtype=&#x27;string&#x27;, id=None), </span><br><span class="line"> &#x27;label&#x27;: ClassLabel(names=[&#x27;not_equivalent&#x27;, &#x27;equivalent&#x27;], id=None), </span><br><span class="line"> &#x27;idx&#x27;: Value(dtype=&#x27;int32&#x27;, id=None)&#125;  </span><br></pre></td></tr></table></figure>

<p><code>sentence1</code> 和 <code>sentence2</code> 是进行比较的两个句子。</p>
<p><code>label</code>: 标签 <code>0</code> 表示这两个句子被标记为<strong>不等价</strong>（not equivalent）。</p>
<p><code>idx</code>: 是样本在数据集中的唯一索引号，这里是 <code>114</code>。</p>
<h2 id="处理datasets中数据"><a href="#处理datasets中数据" class="headerlink" title="处理datasets中数据"></a>处理datasets中数据</h2><p>先选择使用合适的分词器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"><span class="comment"># 加载预训练模型的分词器</span></span><br><span class="line">model_name = <span class="string">&quot;bert-base-uncased&quot;</span>  <span class="comment"># 选择合适的模型</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_name)</span><br></pre></td></tr></table></figure>



<p>可以使用pandas，但是huggingface官方推荐使用这种方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tokenize_function</span>(<span class="params">example</span>):</span><br><span class="line">    <span class="keyword">return</span> tokenizer(example[<span class="string">&quot;sentence1&quot;</span>],example[<span class="string">&quot;sentence2&quot;</span>],truncation=<span class="literal">True</span>)</span><br><span class="line">tokenized_datasets=raw_datasets.<span class="built_in">map</span>(tokenize_function,batched=<span class="literal">True</span>)<span class="comment">#batched根据电脑性能分批处理</span></span><br><span class="line"><span class="built_in">print</span>(tokenized_datasets)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DatasetDict(&#123;</span><br><span class="line">    train: Dataset(&#123;</span><br><span class="line">        features: [&#x27;sentence1&#x27;, &#x27;sentence2&#x27;, &#x27;label&#x27;, &#x27;idx&#x27;, &#x27;input_ids&#x27;, &#x27;token_type_ids&#x27;, &#x27;attention_mask&#x27;],</span><br><span class="line">        num_rows: 3668</span><br><span class="line">    &#125;)</span><br><span class="line">    validation: Dataset(&#123;</span><br><span class="line">        features: [&#x27;sentence1&#x27;, &#x27;sentence2&#x27;, &#x27;label&#x27;, &#x27;idx&#x27;, &#x27;input_ids&#x27;, &#x27;token_type_ids&#x27;, &#x27;attention_mask&#x27;],</span><br><span class="line">        num_rows: 408</span><br><span class="line">    &#125;)</span><br><span class="line">    test: Dataset(&#123;</span><br><span class="line">        features: [&#x27;sentence1&#x27;, &#x27;sentence2&#x27;, &#x27;label&#x27;, &#x27;idx&#x27;, &#x27;input_ids&#x27;, &#x27;token_type_ids&#x27;, &#x27;attention_mask&#x27;],</span><br><span class="line">        num_rows: 1725</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>相比起之前未处理的数据多了 <code>input_ids</code>, <code>token_type_ids</code>, <code>attention_mask</code>三个字段，这三个字段是有用的，可以把前三个给删掉。</p>
<p>tokenizer只是预处理，还要封装成一个个batch才可以丢到模型里面去</p>
<p>使用了<code>DataCollatorWithPadding</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> DataCollatorWithPadding</span><br><span class="line">data_collator = DataCollatorWithPadding(tokenizer=tokenizer)</span><br><span class="line">samples=tokenized_datasets[<span class="string">&quot;train&quot;</span>][:<span class="number">8</span>]<span class="comment">#取前8个样本</span></span><br><span class="line">samples = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> samples.items() <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&quot;idx&quot;</span>, <span class="string">&quot;sentence1&quot;</span>, <span class="string">&quot;sentence2&quot;</span>]&#125;<span class="comment">#去掉不需要的字段</span></span><br><span class="line"><span class="built_in">print</span>([<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> samples[<span class="string">&quot;input_ids&quot;</span>]])<span class="comment">#每一个batch的长度</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[50, 59, 47, 67, 59, 50, 62, 32]</span><br></pre></td></tr></table></figure>

<p>再经过<code>data_collator</code>的处理，每个样本的长度都是取最大值，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch = data_collator(samples)</span><br><span class="line"><span class="built_in">print</span>(&#123;k: v.shape <span class="keyword">for</span> k, v <span class="keyword">in</span> batch.items()&#125;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;input_ids&#x27;: torch.Size([8, 67]),</span><br><span class="line">&#x27;token_type_ids&#x27;: torch.Size([8, 67]), </span><br><span class="line">&#x27;attention_mask&#x27;: torch.Size([8, 67]), </span><br><span class="line">&#x27;labels&#x27;: torch.Size([8])&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是最后处理过的数据了  </p>
<h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p>训练需要</p>
<h2 id="训练参数"><a href="#训练参数" class="headerlink" title="训练参数"></a>训练参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> TrainingArguments</span><br><span class="line">training_args = TrainingArguments(<span class="string">&quot;test_trainer&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(training_args)</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TrainingArguments(</span><br><span class="line">_n_gpu=0,</span><br><span class="line">accelerator_config=&#123;&#x27;split_batches&#x27;: False, &#x27;dispatch_batches&#x27;: None, &#x27;even_batches&#x27;: True, &#x27;use_seedable_sampler&#x27;: True, &#x27;non_blocking&#x27;: False, &#x27;gradient_accumulation_kwargs&#x27;: None, &#x27;use_configured_state&#x27;: False&#125;,</span><br><span class="line">adafactor=False,</span><br><span class="line">adam_beta1=0.9,</span><br><span class="line">adam_beta2=0.999,</span><br><span class="line">adam_epsilon=1e-08,</span><br><span class="line">auto_find_batch_size=False,</span><br><span class="line">batch_eval_metrics=False,</span><br><span class="line">bf16=False,</span><br><span class="line">bf16_full_eval=False,</span><br><span class="line">data_seed=None,</span><br><span class="line">dataloader_drop_last=False,</span><br><span class="line">dataloader_num_workers=0,</span><br><span class="line">dataloader_persistent_workers=False,</span><br><span class="line">dataloader_pin_memory=True,</span><br><span class="line">dataloader_prefetch_factor=None,</span><br><span class="line">ddp_backend=None,</span><br><span class="line">ddp_broadcast_buffers=None,</span><br><span class="line">ddp_bucket_cap_mb=None,</span><br><span class="line">ddp_find_unused_parameters=None,</span><br><span class="line">ddp_timeout=1800,</span><br><span class="line">debug=[],</span><br><span class="line">deepspeed=None,</span><br><span class="line">disable_tqdm=False,</span><br><span class="line">dispatch_batches=None,</span><br><span class="line">do_eval=False,</span><br><span class="line">do_predict=False,</span><br><span class="line">do_train=False,</span><br><span class="line">eval_accumulation_steps=None,</span><br><span class="line">eval_delay=0,</span><br><span class="line">eval_do_concat_batches=True,</span><br><span class="line">eval_on_start=False,</span><br><span class="line">eval_steps=None,</span><br><span class="line">eval_strategy=no,</span><br><span class="line">evaluation_strategy=None,</span><br><span class="line">fp16=False,</span><br><span class="line">fp16_backend=auto,</span><br><span class="line">fp16_full_eval=False,</span><br><span class="line">fp16_opt_level=O1,</span><br><span class="line">fsdp=[],</span><br><span class="line">fsdp_config=&#123;&#x27;min_num_params&#x27;: 0, &#x27;xla&#x27;: False, &#x27;xla_fsdp_v2&#x27;: False, &#x27;xla_fsdp_grad_ckpt&#x27;: False&#125;,</span><br><span class="line">fsdp_min_num_params=0,</span><br><span class="line">fsdp_transformer_layer_cls_to_wrap=None,</span><br><span class="line">full_determinism=False,</span><br><span class="line">gradient_accumulation_steps=1,</span><br><span class="line">gradient_checkpointing=False,</span><br><span class="line">gradient_checkpointing_kwargs=None,</span><br><span class="line">greater_is_better=None,</span><br><span class="line">group_by_length=False,</span><br><span class="line">half_precision_backend=auto,</span><br><span class="line">hub_always_push=False,</span><br><span class="line">hub_model_id=None,</span><br><span class="line">hub_private_repo=False,</span><br><span class="line">hub_strategy=every_save,</span><br><span class="line">hub_token=&lt;HUB_TOKEN&gt;,</span><br><span class="line">ignore_data_skip=False,</span><br><span class="line">include_inputs_for_metrics=False,</span><br><span class="line">include_num_input_tokens_seen=False,</span><br><span class="line">include_tokens_per_second=False,</span><br><span class="line">jit_mode_eval=False,</span><br><span class="line">label_names=None,</span><br><span class="line">label_smoothing_factor=0.0,</span><br><span class="line">learning_rate=5e-05,</span><br><span class="line">length_column_name=length,</span><br><span class="line">load_best_model_at_end=False,</span><br><span class="line">local_rank=0,</span><br><span class="line">log_level=passive,</span><br><span class="line">log_level_replica=warning,</span><br><span class="line">log_on_each_node=True,</span><br><span class="line">logging_dir=test_trainer\runs\Jul10_17-06-30_LAPTOP-7RJ6Q229,</span><br><span class="line">logging_first_step=False,</span><br><span class="line">logging_nan_inf_filter=True,</span><br><span class="line">logging_steps=500,</span><br><span class="line">logging_strategy=steps,</span><br><span class="line">lr_scheduler_kwargs=&#123;&#125;,</span><br><span class="line">lr_scheduler_type=linear,</span><br><span class="line">max_grad_norm=1.0,</span><br><span class="line">max_steps=-1,</span><br><span class="line">metric_for_best_model=None,</span><br><span class="line">mp_parameters=,</span><br><span class="line">neftune_noise_alpha=None,</span><br><span class="line">no_cuda=False,</span><br><span class="line">num_train_epochs=3.0,</span><br><span class="line">optim=adamw_torch,</span><br><span class="line">optim_args=None,</span><br><span class="line">optim_target_modules=None,</span><br><span class="line">output_dir=test_trainer,</span><br><span class="line">overwrite_output_dir=False,</span><br><span class="line">past_index=-1,</span><br><span class="line">per_device_eval_batch_size=8,</span><br><span class="line">per_device_train_batch_size=8,</span><br><span class="line">prediction_loss_only=False,</span><br><span class="line">push_to_hub=False,</span><br><span class="line">push_to_hub_model_id=None,</span><br><span class="line">push_to_hub_organization=None,</span><br><span class="line">push_to_hub_token=&lt;PUSH_TO_HUB_TOKEN&gt;,</span><br><span class="line">ray_scope=last,</span><br><span class="line">remove_unused_columns=True,</span><br><span class="line">report_to=[&#x27;tensorboard&#x27;],</span><br><span class="line">restore_callback_states_from_checkpoint=False,</span><br><span class="line">resume_from_checkpoint=None,</span><br><span class="line">run_name=test_trainer,</span><br><span class="line">save_on_each_node=False,</span><br><span class="line">save_only_model=False,</span><br><span class="line">save_safetensors=True,</span><br><span class="line">save_steps=500,</span><br><span class="line">save_strategy=steps,</span><br><span class="line">save_total_limit=None,</span><br><span class="line">seed=42,</span><br><span class="line">skip_memory_metrics=True,</span><br><span class="line">split_batches=None,</span><br><span class="line">tf32=None,</span><br><span class="line">torch_compile=False,</span><br><span class="line">torch_compile_backend=None,</span><br><span class="line">torch_compile_mode=None,</span><br><span class="line">torchdynamo=None,</span><br><span class="line">tpu_metrics_debug=False,</span><br><span class="line">tpu_num_cores=None,</span><br><span class="line">use_cpu=False,</span><br><span class="line">use_ipex=False,</span><br><span class="line">use_legacy_prediction_loop=False,</span><br><span class="line">use_mps_device=False,</span><br><span class="line">warmup_ratio=0.0,</span><br><span class="line">warmup_steps=0,</span><br><span class="line">weight_decay=0.0,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>非常长，在实际训练的过程中需要我们去微调，要参照官方的API文档<a href="https://huggingface.co/docs/transformers/main/en/main_classes/trainer#transformers.TrainingArguments">Trainer (huggingface.co)</a></p>
<p>比如<code>output_dir</code>是输出模型的保存位置，<code>overwrite_output_dir</code>是否要覆盖原来的模型之类的<br><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240710172017285.png" alt="image-20240710172017285"></p>
<p>把鼠标光标放上去就行了 </p>
<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> TrainingArguments,AutoModelForSequenceClassification</span><br><span class="line">training_args = TrainingArguments(<span class="string">&quot;test_trainer&quot;</span>)</span><br><span class="line"><span class="comment">#修改训练参数保存位置</span></span><br><span class="line">training_args.output_dir=<span class="string">&quot;test_trainer&quot;</span></span><br><span class="line"><span class="comment">#100次保存一次模型</span></span><br><span class="line">training_args.save_steps=<span class="number">100</span></span><br><span class="line">training_args.logging_steps=<span class="number">50</span><span class="comment">#每50次保存一次日志</span></span><br><span class="line"></span><br><span class="line">model=AutoModelForSequenceClassification.from_pretrained(model_name,num_labels=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> Trainer</span><br><span class="line">trainer=Trainer(</span><br><span class="line">                model,</span><br><span class="line">                data_collator=data_collator,<span class="comment">#数据收集器</span></span><br><span class="line">                args=training_args,<span class="comment">#训练参数</span></span><br><span class="line">                train_dataset=tokenized_datasets[<span class="string">&quot;train&quot;</span>],<span class="comment">#训练集</span></span><br><span class="line">                eval_dataset=tokenized_datasets[<span class="string">&quot;validation&quot;</span>],<span class="comment">#验证集</span></span><br><span class="line">                tokenizer=tokenizer,<span class="comment">#分词器</span></span><br><span class="line">                )</span><br><span class="line">trainer.train()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里在使用 Hugging Face 的 <code>transformers</code> 库中的 <code>AutoModelForSequenceClassification</code> 类时，<code>num_labels</code> 参数指定了模型用于序列分类任务的输出类别数。这个参数是非常关键的，因为它告诉模型你期望它在输出层有多少个可能的分类结果。结果的<code>logits</code>会为每一个类别生成一个分数</p>
<p>如果对于<code>Trainer</code>中的参数不理解的话，可以把ta复制到<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240710193107073.png" alt="image-20240710193107073"></p>
<p>就可以查看具体的细节了</p>
<p>训练完成之后打印结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predictions=trainer.predict(tokenized_datasets[<span class="string">&quot;validation&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(predictions.predictions.shape,predictions.label_ids.shape)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(408, 2) (408,)</span><br></pre></td></tr></table></figure>

<p>当你调用 <code>Trainer.predict()</code> 方法时，它返回一个 <code>PredictionOutput</code> 对象，这个对象包含几个关键属性：</p>
<ol>
<li><strong><code>predictions</code></strong>:<ul>
<li>这是模型输出的原始 logits 或得分，每个输入样本对应一个 logits 数组。在二分类或多分类问题中，这个数组的每个元素代表一个类别的预测得分。</li>
<li>形状通常是 <code>(num_samples, num_labels)</code>，其中 <code>num_samples</code> 是输入样本的数量，<code>num_labels</code> 是类别的数量。</li>
</ul>
</li>
<li><strong><code>label_ids</code></strong>:<ul>
<li>这包含输入数据的真实标签（如果提供）。这些是用于评估模型性能的实际标签。</li>
<li>形状通常是 <code>(num_samples,)</code>，每个样本一个标签。</li>
</ul>
</li>
<li><strong><code>metrics</code></strong> (如果设置了):<ul>
<li>如果在 <code>TrainingArguments</code> 中设置了评估指标，这将包含计算出的评估指标（如准确率、F1 分数等）。</li>
</ul>
</li>
</ol>
<p>如果你只是想查看模型的输出结构，可以打印 <code>predictions</code> 和 <code>label_ids</code> 的形状，这可以帮助你理解模型是如何为每个输入样本生成预测的。</p>
<p>如果你想对预测结果进行进一步的分析或处理（比如计算准确率或其他指标），你可能需要实际的预测值和标签。</p>
<p>比如这里我们打印了<code>prediction</code>的输出形状</p>
<p><strong>408</strong>：验证集中有408个样本。 </p>
<p><strong>2</strong>：模型为每个样本输出两个预测值，这通常对应于二分类任务中的两个类别的 logits。这些 logits 是模型对每个类别的原始分数，通常需要通过 softmax 函数转换成概率，才能更直观地表示为每个类别的预测概率。</p>
<p><code>label_ids</code>的形状</p>
<p><strong>408</strong>：这与上面的预测结果一致，也是408个样本，每个样本都有一个真实的标签。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">preds=np.argmax(predictions.predictions,axis=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_metric</span><br><span class="line">metric=load_metric(<span class="string">&quot;glue&quot;</span>,<span class="string">&quot;mrpc&quot;</span>,trust_remote_code=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(metric.compute(predictions=preds,references=predictions.label_ids))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里，<code>np.argmax()</code> 函数用于找出预测结果（logits）中每个样本最大值的索引，即模型认为最可能的类别。<code>axis=-1</code> 表示沿着最内层的维度进行操作，适用于处理每个样本的类别得分。</p>
</li>
<li><p><code>preds</code> 数组将包含模型对所有验证集样本的预测类别。</p>
</li>
<li><p>使用 <code>load_metric</code> 函数从 <code>datasets</code> 库加载 MRPC 任务的评估指标。MRPC 任务主要关注判断两个句子是否表达了相同的意思，常用的评估指标包括准确率、F1 分数等。</p>
</li>
<li><p><code>metric.compute()</code> 方法用于计算加载的指标。这里传入两个参数：<code>predictions</code> 是模型预测的类别，<code>references</code> 是数据集中的真实标签。</p>
</li>
<li><p>这个方法将根据提供的真实标签和预测结果来计算指标，为 MRPC 通常计算准确率和 F1 分数。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;accuracy&quot;: 0.85,</span><br><span class="line">  &quot;f1&quot;: 0.89</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>accuracy</code>: 表示模型预测正确的比例</li>
<li><code>f1</code>: 表示模型预测的 F1 分数，这是精确率和召回率的调和平均，特别重视在正类预测上的表现。</li>
</ul>
<p>再实际项目中，通常是以封装的形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_metric</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_metrics</span>(<span class="params">eval_preds</span>):</span><br><span class="line">    metric=load_metric(<span class="string">&quot;glue&quot;</span>,<span class="string">&quot;mrpc&quot;</span>)</span><br><span class="line">    logits,labels=eval_preds</span><br><span class="line">    predictions=np.argmax(logits,axis=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> metric.compute(predictions=predictions,references=labels)</span><br><span class="line"></span><br><span class="line">training_args =TrainingArguments(<span class="string">&quot;test_trainer&quot;</span>,output_dir=<span class="string">&quot;test_trainer&quot;</span>,save_steps=<span class="number">100</span>,logging_steps=<span class="number">100</span>,num_train_epochs=<span class="number">1</span>,evaluation_strategy=<span class="string">&quot;epoch&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> Trainer</span><br><span class="line">trainer=Trainer(</span><br><span class="line">                model,</span><br><span class="line">                data_collator=data_collator,<span class="comment">#数据收集器</span></span><br><span class="line">                args=training_args,<span class="comment">#训练参数</span></span><br><span class="line">                train_dataset=tokenized_datasets[<span class="string">&quot;train&quot;</span>],<span class="comment">#训练集</span></span><br><span class="line">                eval_dataset=tokenized_datasets[<span class="string">&quot;validation&quot;</span>],<span class="comment">#验证集</span></span><br><span class="line">                tokenizer=tokenizer,<span class="comment">#分词器</span></span><br><span class="line">                compute_metrics=compute_metrics<span class="comment">#计算指标,这个是新增的一行</span></span><br><span class="line">                )</span><br></pre></td></tr></table></figure>

<h1 id="实战-微调模型"><a href="#实战-微调模型" class="headerlink" title="实战(微调模型)"></a>实战(微调模型)</h1><p>首先生成虚拟环境并激活它</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m venv venv</span><br><span class="line">.\venv\Scripts\activate</span><br></pre></td></tr></table></figure>

<p>然后就在这个环境下安装各种包</p>
<p>csv文件使用utf-8保存</p>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
</search>
